# 基础知识 


## 嵌入式操作系统基本概念

嵌入式操作系统（Embedded Operating System）是用在嵌入式设备的操作系统。嵌入式设备一般使用专用的嵌入式操作系统，它们通常是实时操作系统。

嵌入式操作系统一般由分成四部分组成：

1. 驱动程序：最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口； 
2. 内核：操作系统内核部分，通常运行在最高特权级，负责提供基础性、结构性的功能； 
3. 接口库：是一系列特殊的程序库，它们职责在于把系统所提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分； 
4. 外围：是指操作系统中除以上三类以外的所有其他部分，通常是用于提供特定高级服务的部件。 

操作系统的主要功能是资源管理、程序控制和人机交互等。计算机系统的资源可分为设备资源和信息资源两大类。设备资源指的是组成计算机的硬件设备，如中央处理器、主存储器、磁盘存储器、打印机、磁带存储器、显示器、键盘鼠标等设备。信息资源指的是存放于计算机内的各种数据，如文件、程序库、系统软件和应用软件等。  

操作系统位于底层硬件与应用软件或用户之间，是两者沟通的桥梁。应用程序或者用户可以通过操作系统提供的各种接口来操作计算机。一个标准的操作系统应该提供以下功能： 
 
- 任务管理（Task management）；
- 内存管理（Memory management）；
- 文件系统（File system）；
- 网络通讯（Networking）；
- 安全机制（Security）；
- 用户界面（User interface）；
- 驱动程序（Device drivers）。

## POSIX标准

POSIX是Portable Operating System Interface（可移植操作系统接口）的缩写。

从1970第一款现代操作系统——UNIX诞生至今，出现了多款现代操作系统，例如：Windows、Linux、BSD、Solaris等，为了方便应用程序以及中间件的移植，大多数操作系统都采用与UNIX兼容的API（Windows除外）。为了保证操作系统API的相互兼容性制定了POSIX标准。

POSIX是IEEE（Institue of Electrical and ElectronicsEngineers，电气和电子工程师学会）为了规范各种UNIX操作系统提供的API接口而定义的一系列互相关联的标准的总称，其正式称呼为IEEE1003，国际标准名称为ISO/IEC9945。此标准源于一个大约开始于1985年的项目。其中POSIX标准对实时操作系统定义了一个称作1003.1b的子协议，该协议定义了标准实时操作系统的基本行为，HYSylixOS符合此协议的要求。

当前的POSIX主要分为四个部分：Base Definitions（基本功能定义）、System
Interfaces（系统接口）、Shell andUtilities（shell与相关工具）和Rationale（基本原理）。HYSylixOS兼容这四部分的大多数规范。由于HYSylixOS对POSIX的支持，其他兼容POSIX系统上的应用程序可以非常方便的移植到SylixOS操作系统之上。

下表中列出了HYSylixOS支持的POSIX标准头文件。

|头文件名|说明|头文件名|说明|
|---|---|---|---|
|<dirent.h>|目录项|<dlfcn.h>|动态链接库操作函数|
|<fcntl.h>|文件控制|<fmtmsg.h>|消息显示结构|
|<fnmatch.h>|文件名匹配类型|<ftw.h>|文件树漫游|
|<grp.h>|组文件|<iconv.h>|代码集转换实用程序|
|<netdb.h>|网络数据库操作|<langinfo.h>|语言信息常量|
|<pwd.h>|口令文件|<libgen.h>|模式匹配函数定义|
|<regex.h>|正则表达式|<monetary.h>|货币类型|
|<tar.h>|TAR归档值|<ndbm.h>|数据库操作|
|<termios.h>|终端I/O|<nl_types.h>|消息类别|
|<unistd.h>|符合常量|<poll.h>|轮询函数|
|<arpa/inet.h>|Internet定义|<search.h>|搜索表|
|<netinet/in.h>|Internet地址族|<strings.h>|字符串操作|
|<netinet/tcp.h>|传输控制协议定义|<syslog.h>|系统出错日志记录|
|<sys/mman.h>|内存管理声明|<ulimit.h>|用户限制|
|<sys/select.h>|select函数|<utmpx.h>|用户账户数据库|
|<sys/socket.h>|套接字接口|<sys/ipc.h>|IPC机制|
|<sys/stat.h>|文件状态|<sys/msg.h>|消息队列|
|<sys/times.h>|进程时间|<sys/resource.h>|资源操作|
|<sys/types.h>|基本系统数据类型|<sys/sem.h>|信号量|
|<sys/un.h>|UNIX域套接字定义|<sys/shm.h>|共享内存|
|<sys/utsname.h>|系统名|<sys/statvfs.h>|文件系统信息|
|<sys/wait.h>|进程控制|<sys/time.h>|时间类型|
|<cpio.h>|cpio归档值|<sys/timeb.h>|附加的日期和时间定义|
|<sys/uio.h>|矢量I/O操作|<aio.h>|异步I/O|
|<mqueue.h>|消息队列|<pthread.h>|线程|
|<sched.h>|执行调度|<semaphore.h>|信号量|
|<spawn.h>|实时spawn接口|<stropts.h>|XSI STREAMS接口|
|<trace.h>|时间跟踪|||

## HYSylixOS简介

### 工具链

HYSylixOS的工具链是在GCC的基础上加入了HYSylixOS元素形成的编译工具。GCC工具链是由编译、链接、对象文件打包等工具和标准的C库形成的编译工具集。

### 集成开发环境

HYSylixOS使用的集成开发环境是海鹰工坊。

海鹰工坊是一套基于Eclipse开发的HYSylixOS集成开发环境，其中包含了一系列开发及调试插件。海鹰工坊对EclipseC/C++插件CDT进行了大量的扩展和改造，使之更加符合HYSylixOS的开发流程，Eclipse使用java 语言开发，因此海鹰工坊的运行依赖于java虚拟机（JRE 1.8以上版本）。

海鹰工坊的主要功能是对HYSylixOS代码的管理（编辑、编译等）、程序调试以及文件推送等。

### HYSylixOS概述

HYSylixOS作为抢占式多任务硬实时操作系统，主要支持ARMCortex-A9架构处理器，具有如下功能与特点：

- 兼容IEEE 1003（ISO/IEC 9945）操作系统接口规范；
- 兼容POSIX 1003.1b（ISO/IEC 9945-1）实时编程的标准；
- 兼容GJB-7714-2012标准；
- 支持无限多任务；
- 抢占式调度支持256个优先级；
- 支持协程（windows称为纤程）；
- 支持优先级继承，防止优先级反转；
- 核心代码使用C编写，可移植性好；
- 支持紧耦合同构多处理器（SMP），例如：ARM Cortex-A9 SMP Core；
- 支持标准I/O、多路I/O复用与异步I/O接口；
- 支持多种新兴异步事件同步化接口，例如：signalfd、timerfd、eventfd等；
- 支持众多标准文件系统：FAT、YAFFS等；
- 支持内存管理单元（MMU）；
- 支持动态装载应用程序、动态链接库以及模块；
- 支持标准IPv4网络协议栈，提供标准的socket操作接口；
- 内部集成众多网络工具，例如：FTP、TFTP、NAT、PING、TELNET、NFS等；
- 内部集成Shell接口；
- 内部集成可重入ISO/ANSI C库（支持80%以上标准函数）；
- 内核、驱动、应用程序支持GDB调试。  
  

# Shell功能

Shell是操作系统“外壳”程序，它向使用者提供了一个基于命令行类型的使用界面，也可称作命令解析器，系统开发人员通常使用此接口来操作计算机。

HYSylixOS的Shell程序是ttinyShell。ttinyShell程序是系统开发人员操作HYSylixOS操作系统最为简单与便捷的接口，ttinyShell运行在内核空间，它不是一个应用程序，所以ttinyShell不仅可以运行应用程序，而且可以运行內建在SylixOS内核里的命令。ttinyShell内建的命令，可分为系统命令、文件命令、网络命令、时间命令、动态装载命令和其他命令，详见《海鹰翼辉嵌入式操作系统Shell命令手册》。

# 线程管理

## 线程

线程又称为任务，是某个单一顺序的指令流，它是HYSylixOS操作系统调度的最小单位。一个标准的线程由线程句柄（或ID）、当前指令指针（PC）、CPU寄存器集合和线程堆栈组成。每一个线程都是操作系统调度的单位。

线程本身只拥有有限的在运行中必不可少的资源，例如CPU寄存器与堆栈等。内核线程共享内核所有资源，例如内核文件描述符表，而进程内线程则共享使用进程内所有资源，例如进程文件描述符表。

一个CPU在一个时刻只能运行一个线程（多CPU系统可同时运行多个线程），如果系统中存在多个线程，则CPU需要在几个线程之间切换运行，从宏观上来看相当于多个线程并发执行。CPU什么时刻运行哪一个线程是由操作系统调度算法决定的，例如分时操作系统将时间分成若干小的片段称之为时间片，每个线程运行一段时间后操作系统将会命令CPU切换到另一个线程执行。实时操作系统则不然，实时操作系统中每一个线程都拥有自己的优先级，当优先级高的线程需要执行时，操作系统会立即切换当前CPU执行的线程到高优先级线程，这样的调度算法满足系统对实时信号响应的需要。

## 线程状态机

同一进程或内核中的多个线程之间可以并发执行。但由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有阻塞、就绪和运行三种基本状态。这三种状态的含义如下：

- 阻塞：线程缺少使其运行的条件或资源，必须等条件满足后方可进入就绪态。
- 就绪：线程已经拥有使其运行的一切资源，只待操作系统调度。
- 运行：线程已被操作系统调度（操作系统将一个CPU分配给线程用于执行线程代码）。

HYSylixOS系统中被创建出来的线程总是处于这三种状态中的任意一种，其中阻塞态又因阻塞原因不同分为：等待信号量、等待消息、被停止等。线程之间的状态轮状，如下图所示。

@import "./image/线程状态转换图.jpg"

初始态只是线程被创建前的一个状态，三种状态的转换关系：

- 就绪 → 运行 就绪态的线程开始被系统调度，获得了CPU的使用权；
- 运行 → 就绪 运行态线程被其他线程抢占或主动放弃了CPU的使用权；
- 就绪 → 阻塞 由于缺少某资源或者其他线程主动将其挂起；
- 阻塞 → 就绪 等待的资源变的可用；
- 运行 → 阻塞 等待信号量、接收消息、睡眠等使其进入阻塞。

## HYSylixOS线程

HYSylixOS为多线程操作系统，系统能同时创建多个线程，具体最大线程数量取决于系统内存的大小以及编译HYSylixOS操作系统时的配置。

## POSIX线程

所有POSIX线程属性通过一个属性对象表示，该属性对象定义为结构体pthread_attr_t。POSIX定义了一系列函数设置和读取各个属性值，用户不需要知道pthread_attr_t定义的细节。

## 线程的调度

HYSyilxOS的线程调度行为受两个因素影响：调动策略和任务优先级。每个任务都有一个优先级，系统为每个允许的优先级维护一个就绪任务列表，列表具有某种顺序，表首任务和表尾任务，如果有新的任务就绪将被置于此列表的合适位置。
HYSyilxOS支持FIFO调度、优先级调度和RMS调度。
POSIX标准规定优先级高的线程优先级数字大。HYSylixOS中优先级定义与之相反。

## HYSylixOS协程

协程，又称作协同程序是比线程还小的可执行代码序。一个线程内可以拥有多个协程，这些协程共享线程除了栈之外的所有资源，例如优先级、内核对象等。由于线程内的所有协程共享线程本身的内核对象，所有调度器本身并不知道协程的存在，协程是靠所属线程被调度时执行的。一个线程内的协程共享所属线程的优先级。一个线程内部的协程不可被抢占，只能轮转运行，而且当前正在运行的协程必须主动放弃处理器同线程内的另一个协程才能得以运行，当线程被删除时，线程内的所有协程也同时被删除。

HYSylixOS在内核中引入协程概念，而不是使用库模拟出的协程，这样HYSylixOS内部的协程管理更加便捷。HYSylixOS的线程操作详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》。HYSylixOS中POSIX标准的线程操作详见《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 线程间通信

## 共享资源

一个可供线程访问的变量、设备或内存块等类型的实体被称为资源。
可供多个线程访问的资源被称为共享资源；而同时访问共享资源的行为被称为共享资源竞争。
如果在访问共享资源时不独占该共享资源，可能会造成资源异常（如变量值混乱、设备出错或内存块内容不是期望值等），进而导致程序运行异常甚至崩溃。
需要线程独占访问权的共享资源为临界区。
如果临界区保护的代码不可被打断，那么称为原子操作，不可打断意味着临界区内不存在阻塞和硬件中断发生，原子操作屏蔽了当前CPU核心的硬件中断响应，所以原子操作应该尽量简短。

HYSylixOS操作系统提供多种线程间通信机制，如信号量、互斥锁、消息队列等。

## 线程间通信类型

线程在执行的过程中免不了要与其他线程进行通信，如线程A处理完毕某个事件后通知线程B事件的处理结果，线程B得到事件的处理结果后继续运行。 

线程间通信主要有以下几种类型： 

1. 互斥型通信
共享资源需要独占访问，可以使用信号量、互斥量进行互斥型通信。
1. 通知型通信
上述的线程A通知线程B，可以用信号量、事件集、条件变量进行通知型通信。
1. 消息型通信
某线程或中断服务程序只负责采集数据，但并不直接加工数据，而是将数据传递给另一线程进行数据加工，可以使用消息队列进行消息型通信。

## 信号量

### HYSylxOS信号量

HYSylixOS信号量有两种类型：二进制信号量和计数型信号量。
二进制信号量的取值限定于FALSE和TRUE；而计数型信号量的最小取值为0，最大取值在创建计数型信号量时决定。

二进制信号量主要应用在以下场合：

- 有允许线程访问的一个资源，使用二进制信号量作为互斥手段，初始值为TRUE；
- 线程或中断通知另一个线程某件事件发生，初始值为FALSE。

计数型信号量主要应用在以下场合：
- 有允许线程访问的n个资源，使用计数型信号量作为资源剩余计数，初始值为n；
- 线程或中断通知另一个线程某种事件发生，使用计数型信号量作为事件计数，初始值为0。

### POSIX信号量

POSIX信号量有两种类型：匿名信号量和命名信号量。线程间通信使用匿名信号量，进程间通信使用命名信号量。POSIX信号量的本质还是计数型信号量。

## 互斥量

### 优先级翻转

有三个线程（线程A、线程B、线程C）和一个变量V，线程A和线程B需要同时访问变量V。很显然我们需要一把锁（即保护变量V的锁L）。 线程A的优先级为1，线程B的为3，线程C的为2；即优先级：线程A>线程C>线程B。  

我们假设现在线程A和线程C处于阻塞状态，线程B处于运行态。线程B占有了锁L（下图中的#1），这时线程C等待的事件到来进入就绪状态，由于线程C的优先级较线程B的高，线程C将抢占了线程B的执行（下图中的#2）；这时线程A等待的事件到来又进入就绪状态，由于线程A的优先级较线程C的高，线程A将抢占线程C的执行（下图中的#3）；线程A也去申请锁L，由于锁L已经被线程B所占有，线程A将阻塞，中等优先级的线程C将运行（下图中的#4），这显然有违RTOS的实时性原则。

@import "./image/优化级翻转.jpg"


一个高优先级线程通过信号量机制访问共享资源时，该信号量已被一低优先级线程占有，而这个低优先级线程在访问共享资源时可能又被其他的一些中等优先级线程抢占，因此造成高优先级线程被许多具有较低优先级的线程阻塞，我们称此现象为优化级翻转。

解决优先级翻转问题有优先级天花板（priority ceiling）和优先级继承（priority inheritance）两种办法。

优先级天花板是当线程申请某共享资源时，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级，这个优先级称为该资源的优先级天花板。这种方法简单易行，不必进行复杂的判断，不管线程是否阻塞了高优先级线程的运行，只要线程访问共享资源都会提升线程的优先级。

优先级继承是当线程A申请共享资源V时，如果共享资源V正在被线程B使用，通过比较线程B与自身的优先级，如发现线程B的优先级小于自身的优先级，则将线程B的优先级提升到自身的优先级，线程B释放共享资源V后，再恢复线程B的原优先级。这种方法只在占有资源的低优先级线程阻塞了高优先级线程时才动态地改变线程的优先级。

二进制信号量和计数信号量均不支持优先级天花板和优先级继承，只有互斥信号量才支持优先级天花板和优先级继承。

### HYSylixOS互斥量

互斥量用在解决共享资源需要互斥使用的场合，可以理解为初始值为TRUE的带有优先级天花板及优先级继承协议的二进制信号量。因为互斥量需要记录拥有者线程和调整优先级，所以中断服务程序不能等待和释放互斥信号量，并且只有互斥信号量的拥有者线程才有权释放互斥信号量。

### POSIX互斥量

POSIX互斥信号量的类型为pthread_mutex_t。使用时需定义一个pthread_mutex_t类型的变量，如：一个POSIX互斥信号量必须要调用pthread_mutex_init函数创建之后才能使用。

线程如果需要等待一个互斥信号量，可以调用pthread_mutex_lock函数。释放一个互斥信号量使用pthread_mutex_unlock函数。
当一个互斥信号量使用完毕后（并确保以后也不再使用），应该调用pthread_mutex_destroy函数删除它，HYSylixOS会回收该互斥信号量占用的内核资源。

## 条件变量

条件变量是在多线程程序中用来实现“等待->唤醒”逻辑常用的方法。例如，应用程序A中包含两个线程t1和t2。t1需要在bool变量test_cond为true时才能继续执行，而test_cond的值是由t2来改变的，这种情况下，可供选择的方案有两种：

第一种是t1定时的去轮询变量test_cond，如果test_cond为false，则继续休眠；如果test_cond为true，则开始执行。
第二种是使用条件变量，t1在test_cond为false时调用cond_wait进行等待，t2在改变test_cond的值后，调用cond_signal，唤醒在等待中的t1，告诉t1test_cond的值变了，这样t1便可继续往下执行。
很明显，上面两种方案中，第二种方案是比较优的。在第一种方案中，在每次轮询时，如果t1休眠的时间比较短，会导致cpu浪费很厉害；如果t1休眠的时间比较长，又会导致应用逻辑处理不够及时，致使应用程序性能下降。第二种方案就是为了解决轮询的弊端而生的。

### HYSylixOS条件变量

HYSylixOS条件变量的类型为LW_THREAD_COND。使用时需要定义一个LW_THREAD_COND型的变量。

HYSylixOS条件变量需要与HYSylixOS互斥量结合使用，使用HYSylixOS条件变量前，我们需要创建一个用于共享资源锁用途的HYSylixOS互斥信号量，中断服务程序不能使用条件变量。

### POSIX条件变量

POSIX条件变量的类型为pthread_cond_t，使用时需要定义一个pthread_cond_t类型的变量，如：POSIX条件变量需要与POSIX互斥信号量结合使用，使用POSIX条件变量前，我们需要创建一个用于共享资源锁用途的POSIX互斥信号量，中断服务程序不能使用条件变量。

## 消息队列

消息队列是线程间传递数据的常用方法，例如，两个线程（线程A、线程B，线程A的优先级较线程B的高）和一个变量V，线程A需要写变量V，线程B需要读变量V。

我们假设只有在变量V的值改变时，线程B才需要读变量V，在变量V的值不变时，线程B需要阻塞。如果我们继续使用条件变量进行线程间通信，在线程A快速频繁地修改变量V的值时，可能会造成线程B丢失一部分对变量V值改变的响应——应该被读出的旧值已经被新值所覆盖。

消息队列是一个可以存放多则消息的FIFO(先入先出)队列。如果我们改用消息队列作为线程A、B间的通信手段，线程A将修改后变量V的值作为一则消息存入消息队列，线程B只需要从消息队列读出消息（即修改后变量V的值），那么在消息队列满前就不会出现线程B丢失一部分对变量V值改变的响应。

消息队列使得应用软件更容易按功能模块划分和实现，不同功能模块使用不同线程实现，功能模块之间使用消息队列进行通信解耦合而不是定义调用接口。

### HYSylixOS消息队列

HYSylixOS消息队列支持紧急消息的发送，紧急消息直接插入到消息队列的首部，紧急消息将最先被处理，保证了某些异常情况下的安全。

一个HYSylixOS消息队列必须要调用Lw_MsgQueue_Create函数创建之后才能使用，如果创建成功，Lw_MsgQueue_Create函数会返回一个消息队列的句柄，该句柄用于后续操作。

中断服务程序可以使用Lw_MsgQueue_TryReceive函数尝试接收消息，Lw_MsgQueue_TryReceive函数在消息队列为空队列时会立即返回，不会阻塞当前线程，不建议在中断服务函数中使用消息队列，因为极易造成系统错误。

### POSIX消息队列

一个POSIX消息队列必须要调用mq_open函数创建之后才能使用，如果创建成功，mq_open函数会返回一个消息队列的句柄，该句柄用于后续操作。

线程间通信可使用匿名消息队列，进程间通信可使用命名消息队列。不推荐在中断服务程序中使用消息队列。

## HYSylixOS事件

事件集被定义为ULONG型，每一位代表一个事件。一个HYSylixOS事件集必须要调用Lw_Event_Create函数创建之后才能使用，如果创建成功，Lw_Event_Create函数会返回一个事件集的句柄，该句柄用于后续操作。

线程如果需要等待事件，可以调用Lw_Event_Wait函数。中断服务程序不能调用Lw_Event_Wait函数等待事件，中断服务程序可以使用Lw_Event_TryWait函数尝试等待事件，Lw_Event_TryWait函数在事件无效时会立即返回，不会阻塞当前线程。

## HYSylixOS原子量及原子操作

当我们的程序存在较多类似于变量V这样的变量或对这样的变量访问较多时，我们的程序必然存在较多的锁和锁操作，一方面这使得我们的程序难以编写和维护，另一方面不合理地锁操作可能会发生死锁。

为了避免这些问题，HYSylixOS提供了原子量类型atomic_t及其API，原子量类型可储存一个整型INT类型的值，同时使用原子量API对原子量进行的操作是一个原子操作，因为原子操作不可打断，这样在多线程环境下也就不会存在混乱风险。HYSylixOS原子量的类型为atomic_t，使用时需要定义一个atomic_t类型的变量。

## POSIX读写锁

为了解决普通锁机制在对共享资源“读多写少”情况下读并发效率低下的问题，POSIX标准定义了读写锁机制，例如，有十个线程（线程1、线程2...线程10）和一个变量V，线程1需要写变量V，线程[2-10]需要读变量V。变量V的读者线程多于写者线程。在这种情况下，如果我们继续使用初始值为TRUE的二进制信号量或初始值为1的计数信号量或互斥信号量作为锁，那么当有一个读者线程占有该锁时，则其他的读者线程都会阻塞在该锁上，显然这造成了读取共享资源并发效率不高，因为多个线程同时直接对变量V进行读操作并不会使变量V的值混乱。

POSIX读写锁的类型为pthread_rwlock_t。使用时需要定义一个pthread_rwlock_t类型的变量。一个POSIX读写锁必须要调用pthread_rwlock_init函数创建之后才能使用。中断服务程序不能调用任何POSIX读写锁函数。

## POSIX线程屏障

对超大数组进行排序的程序中，为了发挥多核处理器的并发性能，可以使用10个线程分别对这个超大数组的10个部分进行排序。必须要等这10个线程都完成了各自的排序后，才能进行后续的归并操作。先完成的线程会挂起等待，直到所有线程都完成后，才唤醒所有等待的线程。

以上应用场景我们可以使用信号量、条件变量等线程间通信方法完成，但为了更为高效地实现，POSIX标准定义了线程屏障机制。线程屏障Barrier又名线程栅栏，它主要用于协调多个线程并行共同完成某项任务。一个线程屏障对象可以使得每个线程阻塞，直到所有协同（合作完成某项任务）的线程执行到某个指定的点，才让这些线程继续执行。

一个POSIX线程屏障必须要调用pthread_barrier_init函数创建之后才能使用。
线程如果需要等待一个线程屏障，可以调用pthread_barrier_wait函数，中断服务程序不能调任何的POSIX线程屏障API。

## POSIX自旋锁

自旋锁是为实现保护共享资源而提出一种轻量级的锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对共享资源的互斥使用。

无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个拥有者，也就说，在任何时刻最多只能有一个线程获得锁。但是两者在调度机制上有很大的不同。对于互斥锁，如果互斥锁已经被占有，申请者只能进入睡眠状态。但是自旋锁不会引起申请者睡眠，如果自旋锁已经被别的线程占有，申请者就一直在那里循环判断该自旋锁的拥有者是否已经释放了该锁，“自旋”一词就是因此而得名。

由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁机制可能存在以下两个问题：

- 死锁，申请者试图递归地获得自旋锁必然会引发死锁。
- 消耗过多CPU资源，如果申请不成功，申请者一直在循环判断，只有相同或更高优先级的线程才能运行。

由此可见，自旋锁适用于锁使用者保持锁时间比较短的情况。信号量适用于保持锁时间较长的情况。在自旋锁保护的区域内不能调用任何可能引发系统任务调度的API，中断服务程序不能调任何的POSIX自旋锁API。

## POSIX信号

信号就是通知某个线程或进程发生了某个事件，有时也称为软件中断。信号通常是异步发生的，即线程或进程预先不知道信号准确发生的时刻。

信号处理流程如下图所示。很多比较重要的应用程序都需要处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序。

@import "./image/信号处理流程.jpg"

每个信号都有自己的名字，信号的名字都以“SIG”开头。例如，SIGTERM是终止信号，向进程发送此信号可以终止一个进程。目前HYSylixOS可支持64种不同的信号，其中包括标准信号和实时信号。

很多条件可以产生信号：

- 当用户按某些键时，引发终端产生信号，例如：Ctrl+C产生SIGINT信号；
- alarm函数设置的定时器超时后产生SIGALRM信号；
- 子进程退出或被异常终止后产生SIGCHLD信号；
- 访问非法内存产生SIGSEGV信号；
- 用户可调用kill命令将信号发送给其他进程，常用此命令终止一个失控的后台进程。

信号异步性意味着，应用程序不用等待事件的发生，当信号发生时应用程序自动陷入到对应的信号处理函数中。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。

在某信号发生时，可以告诉内核按下列3种方式之一进行处理：

- 忽略信号。大多数信号都可使用这种方式进行处理，但有两种信号不能被忽略。它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是：它们向内核提供了进程终止的可靠方法。另外，如果忽略某些由硬件异常产生的信号（如非法内存访问）则进程的运行行为是未定义的；
- 捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户想要的动作。例如，捕捉到SIGALRM信号后，用户可在相应的处理函数中去控制某个线程。如果捕捉到SIGCHLD信号，则表示一个子进程已经终止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的退出状态。又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除临时文件。需要注意的是，不能捕捉SIGKILL和SIGSTOP信号。
- 执行系统默认动作。对大多数信号的系统默认动作是终止该进程。

HYSylixOS中支持的信号，如下表所示。

|信号名|说明|
|---|---|
|SIGHUP|挂断控制终端或进程。通常用此通知守护进程再次读取它们的配置文件，因为守护进程不会有控制终端，通常决不会接收到这种信号|
|SIGINT|来自键盘的中断。一般采用Ctrl + C来产生此信号。当一个进程在运行时失控，特别是他正在屏幕上产生大量不需要的输出时，常用此信号终止|
|SIGQUIT|来自键盘的退出|
|SIGILL|非法指令|
|SIGTRAP|跟踪断点|
|SIGABRT|异常结束|
|SIGUNUSED|未使用|
|SIGFPE|协处理出错，如除以0、浮点溢出等|
|SIGKILL|强迫进程结束。此信号不能被捕捉和忽略，它向系统提供了一个可以杀进程的可靠方法|
|SIGBUS|总线错误，通常是指示一个实现定义的硬件故障|
|SIGSEGV|无效内存引用|
|SIGUNUSED2|未使用2|
|SIGPIPE|管道写错误，无读者|
|SIGALRM|实时定时器报警|
|SIGTERM|进程终止。这是kill命令的默认动作，由于这个信号是由应用程序捕获的，使用SIGTERM也让程序有机会在退出之前做好清理工作，从而优雅的终止|
|SIGCNCL|线程取消|
|SIGSTOP|停止进程执行。此信号不能被捕获和忽略|
|SIGTSTP|tty发出停止进程|
|SIGCONT|恢复进程继续执行|
|SIGCHLD|子进程停止或者被终止。系统默认是忽略此信号|
|SIGTTIN|后台进程请求输入|
|SIGTTOU|后台进程请求输出|
|SIGCANCEL|同SIGTERM相同|
|SIGIO|异步I/O事件|
|SIGXCPU|进程超出了软CPU事件限制|
|SIGXFSZ|进程超出了软文件长度限制|
|SIGVTALRM|函数setitimer设置的虚拟间隔定时器已经超时|
|SIGPROF|函数setitimer设置的梗概间隔定时器已经超时|
|SIGWINCH|更改了窗口的大小|
|SIGINFO|信息请求|
|SIGPOLL|同SIGIO相同|
|SIGUSR1|用户定义信号1|
|SIGUSR2|用户定义信号2|
|SIGPWR|电源失败重新开始|
|SIGSYS|错误的系统调用|
|SIGURG|网络连接上接到带外的数据时，可选择地产生此信号|
|SIGRTMIN-SIGRTMAX|HYSylixOS实现SIGRTMIN = 48、SIGRTMAX = 63，系统没有指定明确的含义，由用户自定义，并且不应该使用某数值|

## POSIX一次性初始化


有时候我们需要对一些POSIX对象只进行一次性初始化，如线程键pthread_key_t。如果我们进行多次初始化就会出现错误。

在传统的顺序编程中，一次性初始化经常通过使用布尔BOOL类型的变量来管理。布尔类型的控制变量被静态初始化为FALSE，而任何依赖于初始化的代码都能测试该变量。如果变量的值为FALSE，则实行初始化，然后将变量的值设置为TRUE。以后检查的代码将将跳过初始化。

但是在多线程程序中，如果多个线程并发地执行初始化序列代码，可能有多个线程同时发现变量的值为FALSE，并且都实行初始化，而该过程本该仅仅执行一次。使用POSIX标准提供的pthread_once_t变量和pthread_once函数可高效的保证操作系统的POSIX对象只执行一次初始化代码。

线程通信API详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》及《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 进程管理

## 实时进程

进程是操作系统中资源的容器，所有应用程序都必须依附于进程运行，进程管理程序的代码、数据、线程、信号量等资源。当一个进程销毁时，所有属于该进程的资源也会被销毁，如：文件句柄、socket套接字、线程等。

HYSylixOS支持进程，HYSylixOS进程是充分考虑实时系统需求设计的称之为实时进程。HYSylixOS主要从以下两个方面改进进程实时性：

- 进程中的所有线程使用实时调度算法调度；
- 所有进程共用一个地址空间，在任务切换过程中不需要切换页表，进程的存在对任务切换实时性没有任何影响。

在HYSylixOSShell中执行一个可执行文件，便会在系统中建立一个进程。HYSylixOS系统中进程的用户程序部分从main函数开始执行，main函数所在线程便是进程的主线程，主线程可以通过API创建其他线程。

## 进程状态机

进程状态反映进程执行过程的不同阶段，进程状态随着进程的执行和外界条件的变化而转换。HYSylixOS进程存在以下四种状态。

- 初始化态：进程尚在初始化过程中，正在执行程序加载、内存初始化等操作，尚不具备运行条件；
- 运行态：进程正在运行，进程中的线程或参与调度，或处于阻塞状态；
- 退出态：进程已经结束运行，进程在进入退出态时会发送信号给其父进程，由父进程适时回收子进程残余资源。如果是僵尸进程，则在进入退出态后由系统回收资源；
- 停止态：部分进程在运行过程中会进入停止态，在停止态下，进程所有线程停止运行，不参与调度。如在调试进程时，调试器会经常让进程进入停止态进而观察进程数据。

@import "./image/进程状态机.jpg"

## POSIX进程

除了在HYSylixOSShell中执行程序创建进程外，HYSylixOS也提供在程序中创建进程以及设置进程参数的API。

当一个进程创建另外一个进程时，本进程成为被创建进程的父进程，被创建进程则成为本进程的子进程。父子进程相互关联，可以利用API相互查找到对方，而在子进程退出时，子进程会发送信号通知父进程，此时父进程可以获取子进程退出码，回收子进程资源。如果一个进程的父进程先于子进程退出，则子进程成为孤儿进程，孤儿进程的资源回收工作在退出时由系统自动完成。

HYSylixOS提供POSIX posix_spawn系列函数用于进程操作。

## SylixOS进程

在POSIX标准兼容进程API之外，HYSylixOS也提供系统独有的API实现一些系统相关的进程操作。在编写程序时推荐使用POSIX标准进程API。

## 进程调度

HYSylixOS的进程调度是对进程的主线程进行调度。

## 亲和度设置

HYSylixOS提供sched_setaffinity函数锁定进程所有线程在指定cpu集上运行，只用于多核情况。

进程管理详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》及《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 进程间通信

进程间通信是指两个或两个以上的进程之间传送数据或信号的一些技术或方法。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，需要进程间通信机制。

常见的进程间通信方法有：管道、命名消息队列、命名信号量、共享内存、信号等，信号见4.12。

## 匿名管道


管道是HYSylixOS进程间通信的一种方式。和现实世界的传输管道类似，管道有两个端口：读端和写端，并且只允许数据从写端流向读端，所以管道是一种流式设备。

管道分为匿名管道pipe和命名管道fifo。创建一个匿名管道使用pipe函数，pipe函数的输出参数为两个文件描述符：一个为读端文件描述符，一个为写端文件描述符。创建匿名管道后往往使用posix_spawn簇或spawn簇函数创建一个子进程，由于子进程继承了父进程的文件描述符，所以子进程和父进程均能使用read和write函数对匿名管道进行读和写操作。

虽然子进程和父进程均有匿名管道的两个文件描述符：读端文件描述符和写端文件描述符。但并不意味着匿名管道能进行父子进程间的全双工通信。匿名管道只有两端口：读端和写端，并且只允许数据从写端流向读端，所以匿名管道只能进行半双工通信。如果需要全双工通信，可以创建两个匿名管道。

@import "./image/匿名管道.jpg"

## 命名管道

虽然匿名管道是一个文件，但匿名管道并不存在于文件系统中，所以匿名管道只能用于父子进程间的通信。没有血缘关系的进程，由于不存在文件描述符的继承，所以无法使用匿名管道进行通信，但可以使用命名管道进行通信。

创建一个命名管道使用mkfifo函数，mkfifo函数指定了命名管道的设备文件路径，其他的进程可以使用标准的文件打开函数——open函数打开该命名管道，然后使用read和write函数对命名管道进行读和写操作。

@import "./image/命名管道.jpg"

## POSIX命名信号量

POSIX匿名信号量只能用于同一进程内的线程间通信，为了实现进程间的同步，可以使用POSIX命名信号量。

一个POSIX命名信号量必须要调用sem_open函数创建或打开之后才能使用。当一个POSIX命名信号量使用完毕后，应该调用sem_close函数关闭它；当一个POSIX命名信号量不再有任何用途时，应该调用sem_unlink函数删除它，HYSylixOS会回收该信号量占用的内核资源。

## POSIX命名消息队列

POSIX命名消息队列的句柄的类型为mqd_t。使用时需要定义一个mqd_t类型的变量。

一个POSIX命名消息队列必须要调用mq_open函数创建或打开之后才能使用。

线程如果需要接收消息，可以调用mq_receive函数，发送消息使用mq_send函数。当一个POSIX命名消息队列使用完毕后，应该调用mq_close函数关闭它；当一个POSIX命名消息队列不再有任何用途时，应该调用mq_unlink函数删除它，HYSylixOS会回收该消息队列占用的内核资源。

## POSIX共享内存

虽然管道和POSIX命名消息队列都能实现进程间的数据通信，但当数据量较大时，管道和POSIX命名消息队列的效率就有点低了，这时建议使用POSIX共享内存进行直接的数据通信。

为了避免有多个写者进程对同一块POSIX共享内存进行写操作，往往需要使用一个POSIX命名信号量作为该共享内存的写锁。同时为了让读者进程能及时知道写者进程已经修改POSIX共享内存的内容，往往需要使用一个POSIX命名信号量作为该共享内存的读通知信号。

创建一个POSIX共享内存使用shm_open函数，shm_open函数指定了POSIX共享内存的设备文件路径，其他的进程可以使用shm_open函数打开该共享内存，shm_open函数返回一个文件描述符，然后使用mmap函数映射该共享内存到进程的虚拟空间内，mmap函数返回一个虚拟地址，之后便可通过这个虚拟地址对共享内存进行读和写操作，从而达到高效的进程间直接大数据量通信的目的。

当一个POSIX共享内存使用完毕后，应该调用close函数关闭它；当一个POSIX共享内存不再有任何用途时，应该调用shm_unlink函数删除它，HYSylixOS会回收该共享内存占用的内核资源。

进程间通信详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》及《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 内存管理


## HYSylixOS内存管理

### 定长内存管理

所谓定长内存，指的是我们每次分配获得的内存大小是相同的，即使用的是有确定长度的内存块。同时，这些内存块总的个数也是确定的，即整个内存总的大小也是确定的。这和我们通常理解的内存池的概念是一样的。

使用这样的内存，有两大优点：一是由于事先已经分配好了足够的内存，可极大提高关键应用的稳定性；二是对于定长内存的管理通常有更为简单的算法，分配/释放的效率更高。在HYSylixOS中，将管理的一个定长内存称作PARTITION，即内存分区。

### 变长内存管理

变长内存相对于定长内存，最大的不同就是每次分配的内存可能大小是不同的。同时，在使用上，它和malloc/free类似，唯一的区别是所使用的内存由用户提供。HYSylixOS中，将变长内存称作REGION，即内存区域。

由于使用malloc/free这类函数操作的是系统中的同一个内存堆，当一个应用程序中某个组件存在频繁分配/释放内存的操作时，可能会产生很多内存碎片，同时还会影响其他应用程序使用内存堆的效率，该情况下应该考虑为此组件创建一个单独的内存区域，可有效地避免上面的情况。

### 虚拟内存管理

#### 内存划分

HYSylixOS作为一个多进程操作系统，像其他多进程操作系统一样，有内核空间和用户空间之分。内核线程、驱动程序和内核模块均存在于内核空间，应用程序（即进程）和动态链接库均存在于用户空间。

@import "./image/系统内存划分.jpg"

上图描述了HYSylixOS在物理内存上的布局以及与虚拟内存的关系。通用内存区就是操作系统本身使用的内存空间，即内核空间，主要包括操作系统镜像、系统使用的内存堆和栈空间，它们的物理地址和虚拟地址是完全相同的，因此可以看到，它们没有对应的虚拟页面。VMM（VirtualMemoryManagement），即虚拟内存管理单元，以页面的方式管理除通用内存区外的所有物理内存，VMM还负责以页面的方式管理一片虚拟内存空间，并在需要的时候，将虚拟内存页面映射到物理内存页面。虚拟页面和物理页面的大小是相同的，通常为4KB。

上图中，有一个特别的DMA页面区，专门用于DMA数据传输（因为DMA硬件只能访问物理地址）。HYSylixOS专门提供了分配DMA内存的API，仅供内核模块和驱动程序使用，应用程序不应该使用这些API，因此这里不作介绍。剩下的就是供应用程序和动态链接库使用的物理页面，它们均有对应的虚拟页面。通常我们所说的虚拟内存就是这一片地址连续的虚拟页面空间。操作系统会保证虚拟页面地址不会与通用内存和DMA内存地址有任何重叠。

设想一下，若有任何重叠，则进程本身的数据（全局变量、栈空间、代码等）都可能会映射到系统内存或DMA内存，造成严重错误。我们把这片不能重叠的空间通常叫做操作系统保留空间。上图中的虚拟页面与物理页面的映射关系仅仅表示两者之间有页面的对应关系（后面将会讲到应用程序使用特殊的方法在虚拟空间直接访问DMA内存），但DMAPage物理地址空间不能与虚拟地址空间重合，因此图中将DMA Page与PhysicalPage作了明显的区分。

#### 进程页面管理

HYSylixOS中，进程访问的都是虚拟地址，这包括两方面：其一是创建进程时，装载器会为进程自身分配虚拟页面，包括进程的数据段、代码段、堆内存等；其二是进程运行时，访问栈内存或使用前面所讲的内存分配函数分配的内存。HYSylixOS当前为每个新创建的进程预分配32MB地址连续的虚拟内存页面，并会为进程自身的某些必要数据（如代码段、数据段等）分配物理内存，除此之外，只有进程在运行时，根据内存访问的需要才分配物理内存。

虚拟内存空间可以大于物理内存空间的范围，系统可同时支持的进程数不仅受限于物理内存的大小，同时也受限于虚拟内存空间的大小。前面介绍过，由于保留空间的原因，虚拟空间总是小于硬件所能访问的最大空间（如在32位CPU中，虚拟空间小于4GB），这是所有多进程操作系统的共同特点。目前HYSylixOS虚拟空间默认配置是从3GB到4GB的范围，大小为1GB，在这种配置下，最大可支持32个进程，这是一个可接收并能广泛适应当前嵌入式系统的配置。当然，不同的硬件平台可以通过操作系统启动参数配置合适的虚拟空间范围，通常在BSP包里面完成。

VMM可保证每次分配的虚拟页面是地址连续的，但对应的物理页面地址不一定连续。当进程释放内存时，仅仅释放对应的物理页面内存，虚拟页面不会被回收。当进程退出时，虚拟页面和物理页面均全部被回收。

#### 虚拟内存映射

应用程序可以使用mmap函数将一个设备文件与应用程序虚拟空间建立映射关系，将对文件的I/O访问转变为内存访问。

## POSIX内存管理

POSIX标准内存管理相关的函数在功能和内部行为上与HYSylixOS变长内存管理完全相同。POSIX规定，通过malloc、calloc和realloc分配的内存地址必须对齐。规定地址对齐的目的是为了在任何硬件平台上高效地访问任意类型的数据结构，同时还可以避免在某些硬件平台上，因为在不对齐的地址上进行多字节访问造成的硬件异常错误。每创建一个新的进程，系统内部会自动分配内存为其创建内存堆，而不是像内存区域那样需要用户指定内存空间。
内存管理详见《海鹰翼辉嵌入式操作系统内存管理编程手册》及《海鹰翼辉嵌入式操作系统POSIX内存管理编程手册》。。

# 时间管理

## HYSylixOS时间管理

### 系统时间

HYSylixOS内部记录了自系统启动后所产生的时钟节拍（我们称作TICK）计数，该计数即代表系统时间。时钟节拍以一个固定的频率产生。通过调用函数Lw_Time_Get可获取系统时间。

### 定时器

使用定时器可以让应用程序在指定的时间到达时处理预先设定的事务。

## POSIX时间管理

### UTC时间与本地时间

UTC，即世界协调时间，在实际使用中，它等同于GMT，即格林威治标准时间。UTC时间以1970年1月1日0时0分0秒为基准时间，并以秒为最小计数单位。以英国伦敦格林威治（本初子午线）为中时区，将地球分为东西各12个时区，各时区之间相差1小时，这就是各个时区的本地时间。由于地球自西向东旋转，因此东时区时间早于中时区时间，西时区时间晚于中时区时间。
函数time 可获取UTC时间，函数timelocal可获得的本地时间。

### 高精度时间

POSIX标准中，函数clock返回自系统启动后到目前为止经过的时钟计数，即Tick数。使用clock_getres可以获得系统不同时钟源的时钟计数。

|时钟源名称|说明|
|---|---|
|CLOCK_REALTIME|代表实际的物理时间|
|CLOCK_MONOTONIC|单调增长时间|
|CLOCK_PROCESS_CPUTIME_ID|进程从启动开始所消耗的CPU时间|
|CLOCK_THREAD_CPUTIME_ID|线程从启动开始所消耗的CPU时间|

详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》及《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 日志系统

## HYSylixOS日志系统

为了能够实时记录系统发生的各种事件，HYSylixOS加入了日志管理功能，用户通过分析日志文件可以及时发现和处理系统运行过程中的问题。

HYSylixOS提供以下宏来表示不同的日志等级：

- KERN_EMERG：会导致主机系统不可用的情况；
- KERN_ALERT：必须马上采取措施解决的问题；
- KERN_CRIT：比较严重的情况；
- KERN_ERR：运行出现错误；
- KERN_WARNING：可能会影响系统功能的事件；
- KERN_NOTICE：不会影响系统但值得注意；
- KERN_INFO：一般信息；
- KERN_DEBUG：程序或系统调试信息等。

日志等级从上到下依次变低，通常对于系统来说，如果发现等级KERN_EMERG的日志，则代表发生了严重的问题导致系统不可以再运行。等级KERN_DEBUG通常被用于一些调试信息的打印，在HYSylixOS驱动的开发中，经常使用等级KERN_ERR来打印一些错误信息，使用等级KERN_INFO来打印一些普通信息。

## POSIX日志系统

当没有控制终端时，我们不能将错误信息简单地写到标准错误上,也不希望将错误信息写到指定文件中，所以需要有一种集中记录错误信息的方法。syslog可以将错误信息写到终端，也可以发送给指定主机。

syslog协议提供了一种传递方式，允许一个设备通过网络把事件信息传递给事件信息接收者（也称作日志服务器）。详见《海鹰翼辉嵌入式操作系统POSIX内核应用程序编程接口》。

# 文件系统

HYSylixOS提供了多种标准的文件系统，方便用户使用，这些文件系统是HYSylixOS内建的，如果需要更多的文件系统，则需要通过内核模块加入。

HYSylixOS的文件系统实际上是一组虚拟的设备驱动，它提供两组API接口，对上符合I/O系统虚拟文件系统（VFS）标准，对下要求设备驱动符合块设备标准。
HYSylixOS文件系统使用I/O系统提供的标准VFS进行挂载，然后通过标准I/O操作函数进行访问，换句话说，操作一个普通文件与操作一个设备文件没有什么区别。

HYSylixOS目前内建的文件系统包括：

- ROOT文件系统；
- FAT文件系统；
- YAFFS文件系统。

## ROOT文件系统

ROOTFS（根文件系统）是一种特殊的文件系统，是内核启动时挂载的第一个文件系统，根文件系统包括HYSylixOS启动时所必须的目录和关键性的文件。

HYSylixOS操作系统的ROOTFS属于虚拟类型的根文件系统，因为此文件系统并不存在于具体的物理磁盘中，而是系统启动后动态创建的，并将此系统保存于内存中。

ROOTFS的目录结构，如下表所示。

|根文件系统|符号链接|功能|
|---|---|---|
|/ tmp|/yaffs2/n1/tmp|存放临时文件|
|/var|/yaffs2/n1/var|存放可变的数据|
|/root|/yaffs2/n1/root|根用户的目录|
|/home|/yaffs2/n1/home|普通用户的目录|
|/apps|/yaffs2/n1/apps|存放应用程序|
|/sbin|/yaffs2/n1/sbin|系统级的可执行程序|
|/bin|/yaffs2/n1/bin|普通的可执行程序|
|/usr|/yaffs2/n1/usr|存放共享数据|
|/lib|/yaffs2/n1/lib|存放共享库和内核模块|
|/etc|/yaffs2/n0/etc|存放常用配置文件|
|/boot|/yaffs2/n0/boot|存放加载器所需的文件|
|/yaffs2|无|YAFFS文件系统分区|
|/mnt|无|卷标挂载根节点|
|/dev|无|设备挂载根节点|

## FAT文件系统

FAT（File AllocationTable）是与Windows兼容的文件系统，HYSylixOS系统中常用的移动存储设备（U盘，SD卡等）常使用FAT文件系统格式进行挂载。

FatFs是一个嵌入式系统设计的通用FAT（File AllocationTable）文件系统模块。FatFs的编写遵循ANSIC，并且完全与磁盘I/O层分开，它独立（不依赖）于硬件架构。

FatFs文件系统主要特点：

- Windows兼容的FAT文件系统；
- 不依赖于平台，易于移植；
- 代码和工作区占用空间非常小；
- 多种配置选项。

## YAFFS文件系统

YAFFS（Yet Another Flash File System）是一个专门为NANDFlash存储器设计的嵌入式日志型文件系统，适用于大容量的存储设备。

YAFFS是基于日志的文件系统，提供磨损平衡和掉电恢复的健壮性。它还为大容量的Flash芯片做了很好的调整，针对启动时间和RAM的使用做了优化。它适用于大容量的存储设备。详见《海鹰翼辉嵌入式操作系统文件系统编程手册》。

# 网络系统

为TCP/IP协议设计的应用层编程接口称为socketAPI，针对网络系统，HYSylixOS提供标准socket操作。

在很多底层网络应用开发者的眼里一切编程都是socket（套接字），几乎所有的网络编程都要依靠socket。我们每天打开浏览器浏览网页时，浏览器进程和Web服务器之间需要socket来进行通信的。socket是网络通信中应用程序对应的进程和网络协议之间的接口。

socket在网络传输中有如下作用：

- socket位于协议之上，屏蔽了不同网络协议之间的差异：
- socket是网络编程的入口，它提供了大量的系统调用，构成了网络程序的主体；
- socket是HYSylixOS文件系统中的一个设备，可以通过标准I/O函数对socket进行操作，这使得我们对网络的控制和对文件的控制一样方便。

常用的socket类型有三种：流式（SOCK_STREAM）、数据报式（SOCK_DGRAM）以及原始式（SOCK_RAW），流式是一种面向连接的socket，针对于面向连接的TCP服务应用，数据报式socket是一种无连接的socket，对应于无连接的UDP服务应用。详见《海鹰翼辉嵌入式操作系统网络系统编程手册》。

# 动态加载

## ELF文件格式

ELF（Executable and LinkingFormat）文件是由编译器和链接器生成，用于保存二进制程序和数据，以方便处理器加载执行的文件格式。

最初是由UNIX系统实验室（UNIXSystem Laboratories，USL）开发并发布，作为应用程序二进制接口（Application BinaryInterface，ABI）的一部分。ELF文件格式分为三种：

- 可重定位文件（RelocatableFile），包含可以与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据；
- 可执行文件（ExecutableFile），包含可以执行的一个程序，此文件规定了exec函数如何创建一个程序的进程映像；
- 共享目标文件（Shared ObjectFile），包含可在两种上下文中链接的代码和数据。首先链接器可以将它和其他可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（DynamicLinker）可能将它与某个可执行文件以及其他共享目标一起组合，创建进程映像。

## HYSylixOS中的ELF文件

HYSylixOS中的ELF文件有以下几种：

- 内核模块文件（.ko结尾），由源文件编译得到的目标文件链接生成，属于“可重定位文件”；
- 可执行文件，由编译得到的目标文件链接生成，是一种位置无关的“共享目标文件”，应用程序文件必须指定程序入口；
- 动态链接库文件（.so结尾），由编译得到的目标文件链接生成，是一种位置无关的“共享目标文件”，但是没有程序入口；
- 静态链接库文件（.a结尾）。根据编译得到的目标文件使用归档命令（ar）生成，用于程序链接。

HYSylixOS应用程序源码编写完成后，首先要使用gcc将源文件编译成中间目标文件，然后再根据实际情况链接成内核模块、应用程序或库文件。

## HYSylixOS动态加载器功能

HYSylixOS动态加载器具备以下功能：

- 支持内核模块、位置无关的可执行程序及动态库加载；
- 支持加载应用时自动加载应用所依赖的库文件，自动解决依赖关系；
- 支持程序运行过程中通过API接口手动加载。
详见《海鹰翼辉嵌入式操作系统动态链接库编程手册》

# 内核跟踪器

HYSylixOS内核跟踪器支持系统运行过程中系统状态的查询。

## 内核

提供内核版本查询及内核重启操作。

## 对象

提供内核对象(进程、线程、进程间通信、线程间通信)信息查询。

## 显示

提供线程栈信息、进程所属线程信息的查询等功能。
详见《海鹰翼辉嵌入式操作系统内核应用程序编程接口》。
