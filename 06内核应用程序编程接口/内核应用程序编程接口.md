# 概述

操作系统是计算机系统中的系统软件，有效的组织和管理计算机系统中的软硬件资源，合理的组织计算机工作流程，控制程序执行，并向用户提供各种服务，使得用户能够方便、灵活、有效的计算机。

操作系统一般由内核和扩展功能部件组成。内核包括进程/线程管理调度、进程/线程间通信机制以及中断/异常处理等功能；扩展功能部件包括内存管理、文件系统、网络系统等功能。

本文档描述了海鹰翼辉嵌入式操作系统的内核应用程序编程接口

# 原子操作

## Lw_Atomic_Add：原子加操作

### 函数原型：

```c
    INT  Lw_Atomic_Add 
    (
	    INT  iVal, 
	    atomic_t  * patomic
    );
```

### 描述：

该接口执行原子加法运算操作。patomic被加数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：加数。
- patomic ：被加数的结构体指针。

### 返回值：

成功返回加法运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL：参数无效。

### 备注：

无。

### 样例：

```c
#include<stdio.h>
int main (int argc, char **argv)
{
    int         add;
    atomic_t    a;
    a.counter = 5;

    add = Lw_Atomic_Add (-1, &a);                /*  原子加操作                 */
    if( (errno == EINVAL) && (add == -1) )
    {
        printf ("fun Lw_Atomic_Add error\n");
        return -1;
    }

    printf ("add result :%d\n", add);
    return 0;
}
```

## Lw_Atomic_Sub：原子减操作

### 函数原型：


```c
INT  Lw_Atomic_Sub 
(
	INT  iVal, 
	atomic_t  * patomic
);

```


### 描述：

该接口执行原子减法运算操作。patomic被减数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：减数。
- patomic ：被减数的结构体指针。

### 返回值：

成功返回减法运算的结果。失败返回-１，并置错误码。


### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         sub;
    atomic_t    a;
    a.counter = 5;

    sub = Lw_Atomic_Sub (6, &a);                /*  原子减操作                 */
    if ( (sub == -1) && (errno == EINVAL) )
    {
        printf ("func Lw_Atomic_Sub error\n");
        return -1;
    }

    printf ("sub result :%d\n", sub);
    return (0);
}

```

## Lw_Atomic_Inc：原子加1操作

### 函数原型：

```c
INT  Lw_Atomic_Inc 
( 
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子加1运算操作。patomic被加数的结构体，最后结果放在结构体的成员中。

### 参数：

- patomic ：被加数的结构体指针。

### 返回值：

成功返回加法运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         inc;
    atomic_t    a;
    a.counter = 2;

    inc = Lw_Atomic_Inc (&a);                   /*  原子自加一操作             */
    if ( (errno == EINVAL) && (inc == -1) )
    {
        printf ("func Lw_Atomic_Inc error\n");
        return -1;
    }

    printf ("inc result :%d\n", inc);
    return  (0);
}

```

## Lw_Atomic_Dec：原子减1操作 


### 函数原型：

```c
INT  Lw_Atomic_Dec 
( 
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子减1运算操作。patomic被减数的结构体，最后结果放在结构体的成员中。

### 参数：

- patomic ：被减数的结构体指针。

### 返回值：

成功返回减法运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         dec;
    atomic_t    a;
    a.counter = 2;

    dec = Lw_Atomic_Dec (&a);                  /*  原子自减一操作             */
    if ( (errno == EINVAL) && (dec == -1) )
    {
        printf ("func Lw_Atomic_Dec error\n");
        return -1;
    }

    printf ("inc result :%d\n", dec);
    return  (0);
}

```

## Lw_Atomic_And：原子按位与操作

### 函数原型：

```c
INT  Lw_Atomic_And
(
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子按位与运算操作。patomic被与数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：要按位与的数。
- patomic ：被按位与的结构体指针。

### 返回值：

成功返回按位与运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         and;
    atomic_t    a;
    a.counter = 0x87A;

    and = Lw_Atomic_And (0xfb7, &a);           /*  原子与操作                 */
    if( (errno == EINVAL) && (and == -1) )
    {
        printf ("func Lw_Atomic_And error\n");
        return -1;
    }
    printf ("and result : %#x\n", and);
    return (0);
}

```

## Lw_Atomic_Nand：按位与非操作


### 函数原型：

```c
INT  Lw_Atomic_Nand
(
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子按位与非运算操作。patomic被与非数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：要按位与非的数。
- patomic ：被按位与非的结构体指针。

### 返回值：

成功返回按位与非运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         nand;
    atomic_t    a;
    a.counter = 0x87F;

    nand = Lw_Atomic_Nand (0xfb7, &a);           /*  原子与非操作               */
    if( (errno == EINVAL) && (nand == -1) )
    {
        printf ("fun Lw_Atomic_Nand error\n");
        return -1;
    }

    printf ("nand result : %#x\n", nand);
    return 0;
}

```

## Lw_Atomic_Or：原子或操作

### 函数原型：

```c
INT  Lw_Atomic_Or
(
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子按位或运算操作。patomic被或数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：要按位或的数。
- patomic ：被按位或的结构体指针。

### 返回值：

成功返回按位或运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         or;
    atomic_t    a;
    a.counter = 0x87F;

    or = Lw_Atomic_Or (0xfb7, &a);         /*  原子或操作                 */
    if( (errno == EINVAL) && (or == -1) )
    {
        printf ("fun Lw_Atomic_Or error\n");
        return -1;
    }

    printf ("or result : %#x\n", or);
    return 0;
}

```

## Lw_Atomic_Xor：按位异或操作


### 函数原型：

```c
INT  Lw_Atomic_Xor
( 
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子按位异或运算操作。patomic被异或数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：要按位异或的数。
- patomic ：被按位异或的结构体指针。

### 返回值：

成功返回按位异或运算的结果。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         xor;
    atomic_t    a;
    a.counter = 0x87F;

    xor = Lw_Atomic_Xor (0xfb7, &a);       /*  原子异或操作               */
    if( (errno == EINVAL) && (xor == -1) )
    {
        printf ("fun Lw_Atomic_Xor error\n");
        return -1;
    }

    printf ("xor result : %#x\n", xor);
    return (0);
}
```

## Lw_Atomic_Set：原子赋值操作

### 函数原型：

```c
VOID  Lw_Atomic_Set
( 
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子赋值运算操作。patomic被赋值数的结构体，最后结果放在结构体的成员中。

### 参数：

- iVal ：要赋值的数。
- patomic ：被赋值的结构体指针。

### 返回值：

无。

### 错误码：

无。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         add;
    atomic_t    a;
    a.counter = 10;

    Lw_Atomic_Set (20, &a);                  /*  原子赋值操作                 */
    printf ("set result :%d\n", a.counter);

    add = Lw_Atomic_Add (5, &a);            /*  原子加操作                    */
    if ( (errno == EINVAL) && (add == -1) )
    {
        printf ("func Lw_Atomic_Add error\n");
        return -1;
    }

    printf ("add result :%d\n", add);
    return 0;
}

```

## Lw_Atomic_Get：原子获取值操作

### 函数原型：

```c
INT  Lw_Atomic_Get
( 
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子取值运算操作。patomic被取值的结构体。

### 参数：

- patomic ：被取值的结构体指针。

### 返回值：

成功返回结构体中变量的值。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int         add, get;
    atomic_t    a;
    a.counter = 10;

    // ……

    get = Lw_Atomic_Get (&a);                  /*  获取原子值                 */
    if( (errno == EINVAL) && (get == -1) )
    {
        printf ("func Lw_Atomic_Get error\n");
        return -1;
    }

    // ……
    return 0;
}

```

## Lw_Atomic_Swp：原子交换操作

### 函数原型：

```c
INT  Lw_Atomic_Swp
(
	INT  iVal,
	atomic_t  * patomic
);

```

### 描述：

该接口执行原子交换操作。将patomic结构体中的原值返回，并将iVal的值赋值给patomic。

### 参数：

- iVal ：要交换的数。
- patomic ：被交换的结构体指针。

### 返回值：

成功返回patomic的原值。失败返回－１，并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
int main (int argc, char **argv)
{
    int      swp;
    atomic_t a;
    a.counter = 20;
    swp       = 10;

    swp = Lw_Atomic_Swp (swp, &a);             /*  原子交换操作               */
    if( (errno == EINVAL) && (swp == -1) )
    {
        printf ("fun Lw_Atomic_Add error\n");
        return -1;
    }

    printf ("swp result: %d , a result: %d\n", swp, a.counter);
    return 0;
}

```

# 线程

## Lw_Thread_SetAffinity：将线程锁定到指定的CPU上

### 函数原型

```c
ULONG  Lw_Thread_SetAffinity
(
	LW_OBJECT_HANDLE  ulId,
	size_t  stSize,
	const   PLW_CLASS_CPUSET  pcpuset
);

```

### 描述：

该接口将任务锁定到一个CPU上，如果指定的CPU没有激活则其他所有核均可调度。当前只能将任务锁定到一个
CPU 上, 如果指定的 CPU 没有激活则其他所有核均可调度。

### 参数：

- ulId ：需要设置的线程句柄。
- stSize ：cpu掩码集内存大小。
- pcpuset ：cpu掩码。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

- EINVAL ：参数无效。

- EPERM ：操作不许可。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static PVOID Thread1(PVOID arg)
{
	ULONG ret ;
	LW_CLASS_CPUSET CPUSet;
	LW_CPU_ZERO(&CPUSet);
	LW_CPU_SET(0, &CPUSet);

	ret = Lw_Thread_SetAffinity(Lw_Thread_Self(), 2, &CPUSet);
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetAffinity error\n");
		return (PVOID)-1;
	}
	// ……
	return LW_NULL;
}

```

## Lw_Thread_GetAffinity：获取线程CPU的亲和度情况

### 函数原型:

```c
ULONG  Lw_Thread_GetAffinity
(
	LW_OBJECT_HANDLE  ulId, 
	size_t  stSize, 
	PLW_CLASS_CPUSET  pcpuset
);

```

### 描述：

获取线程CPU的亲和度情况。

### 参数：

- ulId ：线程句柄。
- stSize ：cpu掩码集内存大小。
- pcpuset ：cpu掩码。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static PVOID Thread1(PVOID arg)
{
	ULONG ret ;
	int i = 0 ;
	LW_CLASS_CPUSET CPUSet;
	LW_CPU_ZERO(&CPUSet);

	// ……

	ret = Lw_Thread_GetAffinity(Lw_Thread_Self(), sizeof(LW_CLASS_CPUSET), 	&CPUSet);
	if(ret != 0)
	{
		perror("fun Lw_Thread_GetAffinity error\n");
		return (PVOID)-1;
	}

	for(i = 0; i < sizeof(LW_CLASS_CPUSET)/ sizeof(ULONG); i++)
	{
		printf("cpu %d : %lu\n", i, CPUSet.cpus_bits[i]);
	}

	// ……

	return LW_NULL;
}

```

## Lw_ThreadAttr_GetDefault：获取线程默认属性块

### 函数原型

```c
LW_CLASS_THREADATTR  Lw_ThreadAttr_GetDefault 
(
	VOID
);

```

### 描述：

该接口获取线程默认的属性块。

### 参数：

无。

### 返回值：

返回线程默认属性块信息。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;

	// ……

	threadattr = Lw_ThreadAttr_GetDefault();

    // ……
}

```

## Lw_ThreadAttr_Get：获取指定线程的属性块相关属性

### 函数原型

```c
LW_CLASS_THREADATTR  Lw_ThreadAttr_Get 
(
	LW_OBJECT_HANDLE  ulId
);

```


### 描述：

该接口用来获取指定线程的属性块的相关属性。

### 参数：

- ulId ：需要获取的线程ID号。

### 返回值：

错误，如指定的线程不存在或ID无效，返回线程默认属性块并置错误标志位。成功返回指定线程的属性块相关属性。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：线程句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>

static LW_HANDLE			hThreadId1, hThreadId2;

static PVOID Thread1 (PVOID arg)
{
	LW_CLASS_THREADATTR		threadattr;

	// ……

	threadattr = Lw_ThreadAttr_Get(hThreadId1);

	// ……

	printf("thread id :%lu\n", tid);
}

```

## Lw_ThreadAttr_Build：创建线程属性

### 函数原型：

```c
ULONG Lw_ThreadAttr_Build
(
	PLW_CLASS_THREADATTR pthreadattr,
	size_t					stStackByteSize,
	UINT8					ucPriority,
	ULONG					ulOption,
	PVOID					pvArg
);

```

### 描述：

该接口用来设置线程属性的，包括线程的优先级、堆栈信息、线程参数等。

### 参数：

- pthreadattr ：指向属性块的指针。
- stStackByteSize ：堆栈的大小（字节）。
- ucPriority ：线程的优先级（0\~255，数值越小优先级越大）。
- ulOption ：线程选项。取值有：

|属性对象|说明|
|---|---|
|LW_OPTION_THREAD_STK_CHK|运行时对线程堆栈进行检查|
|LW_OPTION_THREAD_STK_CLR|在线程建立时堆栈数据清零|
|LW_OPTION_THREAD_USED_FP|保存浮点运算器|
|LW_OPTION_THREAD_SUSPEND|建立线程后阻塞|
|LW_OPTION_THREAD_INIT|初始化线程|
|LW_OPTION_THREAD_SAFE|建立的线程为安全模式|
|LW_OPTION_THREAD_DETACHED|线程不允许被合并|
|LW_OPTION_THREAD_UNSELECT|此线程不使用select功能|
|LW_OPTION_THREAD_NO_MONITOR|内核跟踪器对此线程不起效|
|LW_OPTION_THREAD_UNSELECT|任务不可抢占（当前不支持）|
|LW_OPTION_THREAD_SCOPE_PROCESS|进程内竞争（当前不支持）|

- pvArg ：线程参数。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_THREAD_ATTR_NULL ：缺少属性块
- ERROR_THREAD_STACKSIZE_LACK ：堆栈大小不正确
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>

int main (int argc, char *argv[])
{
	int 							ret;
	LW_CLASS_THREADATTR		threadattr;

	ret=Lw_ThreadAttr_Build(&threadattr,4*LW_CFG_KB_SIZE, LW_PRIO_NORMAL,
					LW_OPTION_THREAD_STK_CHK, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_ThreadAttr_Build error\n");
		return ret;
	}
	// ……

	return 0;
}

```

## Lw_ThreadAttr_BuildEx：创建线程属性

### 函数原型：

```c
ULONG Lw_ThreadAttr_BuildEx
(
	PLW_CLASS_THREADATTR pthreadattr,
	PLW_STACK			pstkStackTop,
	size_t				stStackByteSize,
	UINT8				ucPriority,
	ULONG				ulOption,
	PVOID				pvArg
	PVOID				pvExt
);

```

### 描述：

该接口用来设置线程属性的，包括线程的优先级、堆栈地址、堆栈大小、线程参数等。
该接口初始化过的属性块只能用来创建一个线程。

### 参数：

- pthreadattr ：指向属性块的指针。
- pstkStackTop ：堆栈低地址（与堆栈方向无关）。
- stStackByteSize ：堆栈的大小（字节）。
- ucPriority ：线程的优先级（0\~255，数值越小优先级越大）。
- ulOption ：线程选项。

|属性对象|说明|
|---|---|
|LW_OPTION_THREAD_STK_CHK|运行时对线程堆栈进行检查|
|LW_OPTION_THREAD_STK_CLR|在线程建立时堆栈数据清零|
|LW_OPTION_THREAD_USED_FP|保存浮点运算器|
|LW_OPTION_THREAD_SUSPEND|建立线程后阻塞|
|LW_OPTION_THREAD_INIT|初始化线程|
|LW_OPTION_THREAD_SAFE|建立的线程为安全模式|
|LW_OPTION_THREAD_DETACHED|线程不允许被合并|
|LW_OPTION_THREAD_UNSELECT|此线程不使用select功能|
|LW_OPTION_THREAD_NO_MONITOR|内核跟踪器对此线程不起效|
|LW_OPTION_THREAD_UNSELECT|任务不可抢占（当前不支持）|
|LW_OPTION_THREAD_SCOPE_PROCESS|进程内竞争（当前不支持）|

- pvArg ：线程参数。
- pvExt ：扩展数据段指针

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_THREAD_ATTR_NULL ：缺少属性块。
- ERROR_THREAD_STACKSIZE_LACK ：堆栈大小不正确。
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误。
- ERROR_THREAD_STACK_NULL ：堆栈地址不正确。
- ERROR_KERNEL_MEMORY ：堆栈地址未对齐。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main (int argc, char *argv[])
{	
	int ret;
	LW_CLASS_THREADATTR		threadattr;
	static LW_STACK  stackTop[LW_CFG_KB_SIZE * 8];

	ret = Lw_ThreadAttr_BuildEx(&threadattr, stackTop, 8 * LW_CFG_KB_SIZE, 
		LW_PRIO_NORMAL,	LW_OPTION_THREAD_STK_CHK, LW_NULL, 	LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_ThreadAttr_BuildEx error\n");
		return ret;
	}
	// ……
	return 0;
}

```

## Lw_ThreadAttr_BuildFP：设置线程属性块的FP堆栈地址

### 函数原型：

```c
ULONG   Lw_ThreadAttr_BuildFP 
(
	PLW_CLASS_THREADATTR  pthreadattr, 
	PVOID  pvFP
);

```

### 描述：

该接口设置建立线程属性块FP堆栈地址，不建议使用此方法。在1.0.0版本后，此函数无效。

### 参数：

- pthreadattr ：指向属性块的指针。
- pvFP ：FP堆栈地址。

### 返回值：

返回0。

### 错误码：

无。

### 样例：

```c
不建议使用，从1.0.0版本后失效。
```

## Lw_ThreadAttr_SetGuardSize：设置线程属性块堆栈警戒区大小

### 函数原型：

```c
ULONG   Lw_ThreadAttr_SetGuardSize 
(
	PLW_CLASS_THREADATTR    pthreadattr,
	size_t                    stGuardSize
);

```

### 描述：

该接口用来设置线程属性堆栈警戒区大小。

### 参数：

- pthreadattr ：指向属性块的指针。
- stGuardSize ：警戒区大小。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_THREAD_ATTR_NULL ：缺少属性块。

- ERROR_THREAD_STACK_NULL ：堆栈地址不正确。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;
    // ……
	ret = Lw_ThreadAttr_SetGuardSize(&threadattr, LW_CFG_KB_SIZE);
	if(ret != 0)
	{
		perror("fun Lw_ThreadAttr_SetGuardSize error\n");
	}
	printf("pthreadattr.THREADATTR_stGuardSize 	is %d\n",threadattr.THREADATTR_stGuardSize);
	
	// ……
	return 0;
}


```

## Lw_ThreadAttr_SetStackSize：设置线程属性块堆栈大小

### 函数原型：

```c
ULONG   Lw_ThreadAttr_SetStackSize 
(
	PLW_CLASS_THREADATTR    pthreadattr,
	size_t                  stStackByteSize
);

```

### 描述：

该接口用来设置线程属性块的堆栈大小。

### 参数：

- pthreadattr ：属性块的指针。
- stStackByteSize ：堆栈大小。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_THREAD_ATTR_NULL ：缺少属性块。

- ERROR_THREAD_STACKSIZE_LACK ：堆栈大小不正确。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;
	// ……
	ret = Lw_ThreadAttr_SetStackSize(&threadattr, 8 * LW_CFG_KB_SIZE);
	if(ret != 0)
	{
		perror("fun Lw_ThreadAttr_SetStackSize error\n");
		return ret;
	}
	printf("pthreadattr.THREADATTR_stStackByteSize 	is %d\n",threadattr.THREADATTR_stStackByteSize);

	// ……

}

```

## Lw_ThreadAttr_SetArg：设置建立线程属性块入口参数


### 函数原型：

```c
ULONG   Lw_ThreadAttr_SetArg 
(
	PLW_CLASS_THREADATTR    pthreadattr,
	PVOID                   pvArg
);

```

### 描述：

给接口用来建立线程属性块设置入口参数。

### 参数：

- pthreadattr ：属性块的指针。
- pvArg ：线程参数。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_THREAD_ATTR_NULL ：缺少属性块。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main(int argc , char *argv[])
{

	int ret;
	LW_CLASS_THREADATTR		threadattr;
	static  int i =100;

	threadattr = Lw_ThreadAttr_GetDefault();
	ret = Lw_ThreadAttr_SetArg(&threadattr, &i);
	if(ret != 0)
	{
		perror("fun Lw_ThreadAttr_SetArg error\n");
		return ret;
	}
    // ……
}

```

## Lw_Thread_Create：创建一个线程

### 函数原型：

```c
LW_OBJECT_HANDLE  Lw_Thread_Create
(
	CPCHAR                   pcName,
	PTHREAD_START_ROUTINE    pfuncThread,
	PLW_CLASS_THREADATTR     pthreadattr,
	LW_OBJECT_ID            *pulId
);

```


### 描述：

该接口用来建立一个线程。且进程进入就绪状态。

### 参数：

- pcName ：线程的名字。
- pfuncThread ：线程函数，即线程代码段起始地址。
- pthreadattr ：线程的属性。
- pulId ：线程ID，内容与返回值相同。

### 返回值：

成功返回线程的ID，失败返回无效的线程句柄LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- EINVAL ：参数无效。
- ERROR_THREAD_STACKSIZE_LACK ：堆栈太小。
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误。
- ERROR_THREAD_STACK_NULL ：缺少堆栈。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长
- ERROR_THREAD_FULL ：系统线程已满
- ERROR_KERNEL_LOW_MEMORY ：缺少内存

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
LW_HANDLE               hThreadId1; 
LW_HANDLE               hThreadId2;
PVOID Thread1 (PVOID arg)
{
	// ……
	// ……
	return NULL;
}
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;

	threadattr = Lw_ThreadAttr_GetDefault();
	hThreadId1 = Lw_Thread_Create("t_test1", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}
	// ……
	return  (ERROR_NONE);
}

```

## Lw_Thread_Init：初始化一个线程

### 函数原型：

```c
LW_HANDLE Lw_Thread_Init
(	
	CPCHAR					 pcName,
	PTHREAD_START_ROUTINE	 pfuncThread,
	PLW_CLASS_THREADATTR	 pthreadattr,
	LW_OBJECT_ID			*pulId
);

```

### 描述：

该接口用来对线程进行初始化。线程进入初始状态。

### 参数：

- pcName ：线程的名字。
- pfuncThread ：线程的入口函数。
- pthreadattr ：线程属性。
- pulId ：ID指针。

### 返回值：

成功返回线程的ID，失败返回无效的线程句柄LW_OBJECT_HANDLE_INVALID。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_THREAD_FULL ：系统线程已满。
- ERROR_THREAD_STACK_NULL ：缺少堆栈。
- ERROR_THREAD_STACKSIZE_LACK ：堆栈太小。
- ERROR_KERNEL_LOW_MEMORY ：缺少内存。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
LW_HANDLE               hThreadId1; 
LW_HANDLE               hThreadId2;
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;
	threadattr = Lw_ThreadAttr_GetDefault();

	hThreadId1 = Lw_Thread_Init ("t_test1", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}
	Lw_Thread_Start(hThreadId1);
	// ……
	return  (ERROR_NONE);
}

```

## Lw_Thread_Self：获得当前线程ID

### 函数原型：

```c
LW_OBJECT_HANDLE  Lw_Thread_Self
(
	VOID
);

```

### 描述：

该接口用来得到当前运行线程的ID。

### 参数：

无。

### 返回值：

成功返回线程的ID。失败返回0，并置错误码：。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>

PVOID Thread (PVOID arg)
{
	LW_OBJECT_HANDLE tid;
	// ……
	tid = Lw_Thread_Self();
	if(tid == 0 && errno ==  ERROR_KERNEL_IN_ISR)
	{
		perror("fun Lw_ Thread_Self error\n");
		Lw_Thread_Exit(LW_NULL);
	}
	// ……
	printf("thread id :%lu\n", tid);
	// ……
}

```


## Lw_Thread_Desc：获取线程基本信息


### 函数原型：

```c
ULONG  Lw_Thread_Desc
(
	LW_OBJECT_HANDLE  ulId,
	PLW_CLASS_TCB_DESC  ptcbdesc
);

```


### 描述：

该接口用来获取线程的基本信息。

### 参数：

- ulId ：线程ID。
- ptcbdesc ：存放线程信息的指针。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>

PVOID Thread (PVOID arg)
{
	ULONG ret;
	LW_CLASS_TCB_DESC tcbdesc;

	ret = Lw_Thread_Desc(Lw_Thread_Self(), &tcbdesc);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Desc error\n");
		Lw_Thread_Exit(LW_NULL);
	}
	// ……
}

```

## Lw_Thread_Exit：线程自行退出


### 函数原型：

```c
ULONG  Lw_Thread_Exit 
(
	PVOID  pvRetVal
);

```


### 描述：

该接口用来自行退出当前线程。

### 参数：

- pvRetVal ：返回值。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread (PVOID arg)
{
	ULONG  ret;
	// ……
	if(ret != 0)
	{
		Lw_Thread_Exit(LW_NULL);
	} 	
	// ……
}

```


## Lw_Thread_Delete：删除线程

### 函数原型：

```c
ULONG  Lw_Thread_Delete 
(
	LW_OBJECT_HANDLE  *pulId, 
	PVOID  pvRetVal
);

```

### 描述：

该接口用来删除线程，可使线程结束，并释放线程资源，由于SylixOS支持进程，所以删除线程只能是同一个进程中的线程，而且主线程只能由其自己来删除。

### 参数：

- pulId ：线程ID。
- pvRetVal ：返回值。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
PVOID Thread1 (PVOID arg)
{
	// ……
}
PVOID Thread2 (PVOID arg)
{ 
	ULONG ret;
	// ……
	ret = Lw_Thread_Delete(&hThreadId2, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Delete error\n");
	}
	// ……
}
int main (int argc, char *argv[]){

	LW_CLASS_THREADATTR		threadattr;
	threadattr = Lw_ThreadAttr_GetDefault();

	hThreadId1 = Lw_Thread_Create("t_test", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) {
		return  (PX_ERROR);
	}

	hThreadId2 = Lw_Thread_Init("t_test", Thread2, &threadattr, LW_NULL);

	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}

	Lw_Thread_Start(hThreadId2);

	return  (ERROR_NONE);
}

```



## Lw_Thread_ForceDelete：强制删除线程


### 函数原型：

```c
ULONG  Lw_Thread_ForceDelete
(
	LW_OBJECT_HANDLE  *pulId, 
	PVOID  pvRetVal
);

```

### 描述：

该接口用来强制删除线程，可使线程结束，并释放线程资源，由于SylixOS支持进程，所以删除线程只能是同一个进程中的线程，而且主线程只能由其自己来删除。

### 参数：

- pulId ：线程ID。
- pvRetVal ：返回值。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
PVOID Thread1 (PVOID arg)
{
	// ……
}
PVOID Thread2 (PVOID arg)
{ 
	ULONG ret;
// ……
	ret = Lw_Thread_ForceDelete(&hThreadId2, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Delete error\n");
	}
    // ……
}
int main (int argc, char *argv[])
{
	LW_CLASS_THREADATTR		threadattr;
	threadattr = Lw_ThreadAttr_GetDefault();
    // ……
	hThreadId1 = Lw_Thread_Create("t_test", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID)
	{
		return  (PX_ERROR);
	}

	hThreadId2 = Lw_Thread_Init("t_test", Thread2, &threadattr, LW_NULL);

	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID)
	{
		return  (PX_ERROR);
	}

	Lw_Thread_Start(hThreadId2);
	// ……
	return  (ERROR_NONE);
}

```



## Lw_Thread_Restart：重启线程


### 函数原型：

```c
ULONG  Lw_Thread_Restart
(
	LW_OBJECT_HANDLE  ulId, 
	PVOID  pvArg
);

```


### 描述：

该接口用来重新启动线程，但不会改变时间片属性。

### 参数：

- pulId ：线程ID。
- pvArg ：参数。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。
- ERROR_THREAD_IN_SAFE ：线程处于安全模式。
- ERROR_THREAD_JOIN ：线程已经和其他线程合并。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
PVOID Thread1 (PVOID arg)
{
    int ret;
    printf("test1 is start\n");
    ret = Lw_Thread_Suspend(Lw_Thread_Self());
	if(ret) 
	{
        perror("fun Lw_Thread_Suspend error");
    }
	printf("test1 is complete\n");
	// ……
	return LW_NULL;
}
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret = Lw_Thread_Restart(hThreadId1, LW_NULL);
	if(ret != 0)
	{
        perror("fun Lw_Thread_Restart error\n");
	}	
	// ……
	return LW_NULL;
}

```


### Lw_Thread_RestartEx：重启线程，并重新指定函数入口


### 函数原型：

```c
ULONG  Lw_Thread_RestartEx 
(
	LW_OBJECT_HANDLE  ulId, 
	PTHREAD_START_ROUTINE  pfuncThread, 
	PVOID  pvArg
);

```


### 描述：

该接口用来重新启动线程，并可以重新指定函数入口，但不会改变时间片属性。

### 参数：

- pulId ：线程ID。
- pfuncThread ：新的函数入口，当为LW_NULL式不改变函数入口。
- pvArg ：参数。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。
- ERROR_THREAD_IN_SAFE ：线程处于安全模式。
- ERROR_THREAD_JOIN ：线程已经和其他线程合并。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
PVOID Thread1 (PVOID arg)
{
	ULONG ret;
    // ……
	ret = Lw_Thread_RestartEx(hThreadId2, LW_NULL, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Restart error\n");
	}
    // ……
	return LW_NULL;
}
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
    // ……
	ret = Lw_Thread_Suspend(Lw_Thread_Self());
	if(ret) 
	{
		perror("fun Lw_Thread_Suspend error");
	}
	return LW_NULL;
}

```


## Lw_Thread_SetCancelState：设置当前线程取消是否使能


### 函数原型：

```c
ULONG   Lw_Thread_SetCancelState 
(
	INT  iNewState, 
	INT  *piOldState
);

```



### 描述：

该接口用来设置当前线程取消状态的使能情况。

### 参数：

- iNewState ：更新的状态。取值有

|更新的状态|说明|
|---|---|
|LW_THREAD_CANCEL_DISABLE|失能|
|LW_THREAD_CANCEL_ENABLE|使能|

- piOldState ：早先的状态。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	ret =Lw_Thread_SetCancelState(LW_THREAD_CANCEL_ENABLE, LW_NULL);
	if(ret) 
	{
		perror("fun Lw_Thread_SetCancelState error\n");
	}
    // ……
}

```

## Lw_Thread_SetCancelType：设置当前线程被动取消时的动作


### 函数原型：

```c
INT  Lw_ThreadSet_CancelType 
(
	INT  iNewType, 
	INT  *piOldType
);

```


### 描述：

该接口用来设置当前线程被动取消时的动作。

### 参数：

- iNewType ：更新的动作。取值有

|更新的动作|说明|
|---|---|
|LW_THREAD_CANCEL_ASYNCHRONOUS|异步|
|LW_THREAD_CANCEL_DEFERRED|默认|

- piOldType ：早先的动作。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
    // ……
	ret = Lw_Thread_SetCancelType(LW_THREAD_CANCEL_ASYNCHRONOUS, 									LW_NULL);
	if(ret) 
	{
		perror("fun Lw_Thread_SetCancelType error\n");
	}    
	// ……
}

```

## Lw_Thread_Cancel：取消指定线程

### 函数原型：

```c
ULONG  Lw_Thread_Cancel 
(
	LW_OBJECT_HANDLE  *pulId
);

```


### 描述：

该接口用来取消一个指定的线程。

### 参数：

- pulId ：线程ID。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效
- ERROR_THREAD_DISCANCEL ：线程设置了DISCANCEL标志。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1 (PVOID arg)
{
	ULONG ret = 0;
    // ……
	ret = Lw_Thread_Cancel(&hThreadId2);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cancel error\n");
	}
    // ……
	return LW_NULL;
}

```


## Lw_Thread_TestCancel：测试取消本线程


### 函数原型：

```c
VOID  Lw_Thread_TestCancel 
(
	VOID
);

```



### 描述：

该接口用来检测线程是否有请求取消标志, 当条件满足时自动取消。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程等待删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_Cancel(&hThreadId2);
	if(ret != 0)
	{
	    perror("fun Lw_Thread_Cancel error\n");
	}
	// …….
}

```



## Lw_Thread_Start：使一个线程进入就绪


### 函数原型：

```c
#include <SylixOS.h>
ULONG  Lw_Thread_Start
(
	LW_OBJECT_HANDLE	 ulId
);

```


### 描述：

该接口使初始化好的线程进入就绪状态。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_NOT_READY ：线程没有就绪。
- ERROR_THREAD_NOT_INIT ：线程没有初始化 。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE		hThreadId2;
int main (int argc, char *argv[])
{
	ULONG ret;
	LW_CLASS_THREADATTR		threadattr;
    // ……
	threadattr = Lw_ThreadAttr_GetDefault();
	hThreadId2 = Lw_Thread_Init("t_test2", Thread2, &threadattr, LW_NULL);
	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}
	ret = Lw_Thread_Start(hThreadId2);
	if(ret != 0) 
	{
		perror("fun Lw_Thread_Start error\n");
		return  (PX_ERROR);
	}
    // ……
	return  (ERROR_NONE);
}

```


## Lw_Thread_StartEx：使一个线程进入就绪


### 函数原型：

```c
ULONG  Lw_Thread_StartEx 
(
	LW_OBJECT_HANDLE  ulId,
	BOOL  bJoin, 
	PVOID  *ppvRetValAddr
);

```



### 描述：

该接口使初始化好的线程进入就绪状态。

### 参数：

- ulId ：线程ID。
- bJoin ：是否合并线程。取值为1时，合并线程。
- ppvRetValAddr ：存放线程返回值的地址。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_NOT_READY ：线程没有就绪。
- ERROR_THREAD_NOT_INIT ：线程没有初始化 。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE		hThreadId2;
int main (int argc, char *argv[])
{
	ULONG ret;
	LW_CLASS_THREADATTR		threadattr;
    // ……
	threadattr = Lw_ThreadAttr_GetDefault();
	hThreadId2 = Lw_Thread_Init("t_test2", Thread2, &threadattr, LW_NULL);
	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID)
	{
		return  (PX_ERROR);
	}
	ret = Lw_Thread_ StartEx (hThreadId2 , LW_FALSE, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Start error\n");
		return  (PX_ERROR);
	}
	// ……
	return  (ERROR_NONE);
}

```


## Lw_Thread_Activate：使一个线程进入就绪


### 函数原型：

```c
ULONG  Lw_Thread_ Activate
(
	LW_OBJECT_HANDLE	 ulId
);

```


### 描述：

该接口使初始化好的线程进入就绪状态。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_NOT_READY ：线程没有就绪。
- ERROR_THREAD_NOT_INIT ：线程没有初始化 。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE		hThreadId2;
int main (int argc, char *argv[])
{
	ULONG ret;
	LW_CLASS_THREADATTR		threadattr;
	.....
	threadattr = Lw_ThreadAttr_GetDefault();
	hThreadId2 = Lw_Thread_Init("t_test2", Thread2, &threadattr, LW_NULL);
	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}
	ret = Lw_Thread_ Activate (hThreadId2);
	if(ret != 0) 
	{
		perror("fun Lw_Thread_Start error\n");
		return  (PX_ERROR);
	}
	// ……
	return  (ERROR_NONE);
}

```



## Lw_Thread_Join：合并线程


### 函数原型：

```c
ULONG  Lw_Thread_Join 
(
	LW_OBJECT_HANDLE  ulId, 
	*ppvRetValAddr
);

```



### 描述：

该接口用来合并线程。(当同时回收多个线程，会出现“线程句柄无效”错误，将每个回收线程间隔一段时间回收即可避免该错误)。

### 参数：

- ulId ：要合并的线程ID。
- ppvRetValAddr ：存放线程返回值的地址。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_JOIN_SELF ：线程合并自己。
- ERROR_THREAD_DETACHED ：线程已经设定为不可合并。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1;
int main (int argc, char *argv[])
{
	ULONG ret;
	LW_CLASS_THREADATTR		threadattr;
	threadattr = Lw_ThreadAttr_GetDefault();
	// ……
	hThreadId1 = Lw_Thread_Create("t_test1", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID)
	{
		return  (PX_ERROR);
	}
	ret = Lw_Thread_Join(hThreadId1, LW_NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Join error\n");
		return  (PX_ERROR);
	}
	// ……
	return  (ERROR_NONE);
}

```

## Lw_Thread_Detach：禁止指定的线程被合并


### 函数原型：

```c
ULONG  Lw_Thread_ Detach
(
	LW_OBJECT_HANDLE	 ulId
);

```


### 描述：

该接口用来禁止其他线程合并指定线程。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- EROR_THREAD_DETACHED ：线程已经设定为不可合并。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1;
int main (int argc, char *argv[])
{
	ULONG ret;
	LW_CLASS_THREADATTR		threadattr;
	threadattr = Lw_ThreadAttr_GetDefault();
	// ……
	hThreadId1 = Lw_Thread_Create("t_test1", Thread1, &threadattr, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) 
	{
		return  (PX_ERROR);
	}
	ret = Lw_Thread_Detach(hThreadId1);
	if(ret != 0)
	{
		perror("fun Lw_Thread_ Detach error\n");
		return  (PX_ERROR);
	}
	// ……
	return  (ERROR_NONE);
}


```


## Lw_Thread_Safe：使当前线程进入安全模式


### 函数原型：

```c
ULONG  Lw_Thread_Safe 
(
	VOID
);

```



### 描述：

该接口使当前线程进入安全模式。

### 参数：

无。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	Lw_Thread_Safe();
    // ……
}

```

## Lw_Thread_Unsafe：使当前线程退出安全模式


### 函数原型：

```c
ULONG  Lw_Thread_Unsafe 
(
	VOID
);

```



### 描述：

该接口使当前线程退出安全模式。

### 参数：

无。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// …….
	Lw_Thread_Safe();
// ……
	Lw_Thread_Unsafe();
// ……
}

```



## Lw_Thread_IsSafe：检测线程是否出于安全模式


### 函数原型：

```c
BOOL    Lw_Thread_IsSafe 
(
	LW_OBJECT_HANDLE    ulId
);

```



### 描述：

该接口用来检测目标线程是否处于安全模式。

### 参数：

- ulId ：线程ID。

### 返回值：

出于安全模式返回1，不处于返回0；失败返回0，并置错误码：。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1 (PVOID arg)
{
	// ……
    Lw_Thread_Unsafe();
    ret = Lw_Thread_IsSafe(hThreadId2);
    if(ret)
    {
        printf("thread hThreadId2 is Safe\n");
    }
    else
    {
        printf("thread hThreadId2 is not Safe\n");
}	
// ……
}

```



## Lw_Thread_Suspend：使线程挂起进入阻塞


### 函数原型：

```c
ULONG  Lw_Thread_ Suspend
(
	LW_OBJECT_HANDLE	 ulId
);

```



### 描述：

该接口时指定线程进入阻塞，挂起线程。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1 (PVOID arg)
{
	// ……
	ret = Lw_Thread_Suspend(Lw_Thread_Self());
	if(ret) 
	{
		perror("fun Lw_Thread_Suspend error");
	}
	// ……
}

```



## Lw_Thread_Resume：使线程从阻塞进入就绪


### 函数原型：

```c
#include <SylixOS.h>
ULONG  Lw_Thread_Resume
(
	LW_OBJECT_HANDLE	 ulId
);

```



### 描述：

该接口使指定的线程从阻塞状态进入就绪状态。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程在等待删除

### 样例： 

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_Resume(hThreadId1);
	if(ret != 0) 
	{
		perror("fun Lw_Thread_ Resume error");
		// ……
	}
    // ……
}

```



## Lw_Thread_ForceResume：强制线程进入就绪


### 函数原型：

```c
ULONG  Lw_Thread_ ForceResume
(
	LW_OBJECT_HANDLE	 ulId
);

```



### 描述：

该接口使指定的线程进入就绪。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_OTHER_DELETE ：已经有其他线程在等待删除

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret = Lw_Thread_ForceResume (hThreadId1);
	if(ret != 0)
	{
		printf("fun Lw_Thread_ ForceResume is error\n");
	}
    // ……
}

```


## Lw_Thread_IsSuspend：检测线程是否挂起


### 函数原型：

```c
ULONG  Lw_Thread_IsSuspend
(
	LW_OBJECT_HANDLE	 ulId
);

```



### 描述：

该接口用来检测指定的线程是否挂起。

### 参数：

- ulId ：线程ID。

### 返回值：

挂起返回挂起的嵌套层数，没挂起返回0；失败返回0，并置错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret =Lw_Thread_IsSuspend(hThreadId1);
	if(ret > 0)
	{
		ret = Lw_Thread_Resume(hThreadId1);
		if(ret != 0) 
		{
			printf("fun Lw_Thread_Resume error");
		}
	}    
	// ……
}

```


## Lw_Thread_IsReady：检测线程是否就绪


### 函数原型：

```c
BOOL  Lw_Thread_ IsReady
(
	LW_OBJECT_HANDLE	 ulId
);

```



### 描述：

该接口用来检测指定的线程是否就绪。

### 参数：

- ulId ：线程ID。

### 返回值：

就绪返回1，没就绪返回0；失败返回0，并置错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret =Lw_Thread_IsReady (hThreadId1);
	if(ret > 0) 
	{
        // ……
	}
    // ……
}

```



## Lw_Thread_IsRunning：检测线程是否正在运行


### 函数原型：

```c
ULONG  Lw_Thread_IsRunning 
(
	LW_OBJECT_HANDLE   ulId, 
	BOOL  *pbIsRunning
);

```


### 描述：

该接口用来检测指定的线程是否在运行。如果该线程不在运行中会报错！

### 参数：

- ulId ：线程ID。
- pbIsRunning ：是否正在执行，执行值为1，否则为0。

### 返回值：

成功返回0；失败返回错误码：。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	BOOL run;
	ret = Lw_Thread_IsRunning(hThreadId2, &run);
	if(ret == 0) 
	{
		if(run == LW_TRUE) 
		{
			printf("thread hThreadId2 run \n");
            // ……
		} 
		else 
		{
			printf("thread hThreadId2  no run \n");
            // ……
		}
	}
    // ……
}

```


## Lw_Thread_SetName：设置线程名


### 函数原型：

```c
ULONG  Lw_Thread_SetName 
(
	LW_OBJECT_HANDLE  ulId, 
	CPCHAR  pcName
);

```


### 描述：

该接口用来设置指定线程的名字，名字长度应小于32个字节。

### 参数：

- ulId ：线程ID。
- pcName ：线程名。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	ret = Lw_Thread_SetName(hThreadId2, "Sylixos_thread1");
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetName error\n");
		// ……
	}
    // ……
}

```



## Lw_Thread_GetName：获取指定线程名字


### 函数原型：

```c
ULONG  Lw_Thread_GetName
(
	LW_OBJECT_HANDLE  ulId,
	PCHAR  pcName
);

```



### 描述：

该接口用来获得指定线程的名字。

### 参数：

- ulId ：线程ID。
- pcName ：存放线程名字的指针。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	ret = Lw_Thread_GetName(hThreadId2, name);
	if(ret != 0)
	{
		perror("fun Lw_Thread_GetName error\n");
	}
	else
	{
		printf("thread hThreadId2 name: %s\n", name);
        // ……
	}
    // ……
}

```



## Lw_Thread_Lock：锁定CPU调度器


### 函数原型：

```c
VOID  Lw_Thread_Lock
(
	VOID
);

```



### 描述：

该接口用来锁定当前CPU调度器。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	Lw_Thread_Lock();
	// ……
	Lw_Thread_Unlock();
    // ……
}

```



## Lw_Thread_Unlock：打开CPU调度器


### 函数原型：

```c
INT  Lw_Thread_Unlock 
(
	VOID
);

```
|


### 描述：

该接口用来打开当前CPU调度器。

### 参数：

无。

### 返回值：

返回0。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	Lw_Thread_Lock();
	// ……
	Lw_Thread_Unlock();
    // ……
}

```


## Lw_Thread_SetPriority：设置指定线程优先级


### 函数原型：

```c
ULONG  Lw_Thread_SetPriority 
(
	LW_OBJECT_HANDLE    ulId, 
	UINT8    ucPriority
);

```



### 描述：

该接口用来设置指定线程的优先级。

### 参数：

- ulId ：线程ID。
- ucPriority ：优先级。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
 	ret = Lw_Thread_SetPriority(hThreadId1, 150);
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetPriority error\n");
		return (PVOID)-1;
	}
   // ……
}

```


## Lw_Thread_GetPriority：获取指定线程的优先级


### 函数原型：

```c
ULONG  Lw_Thread_GetPriority 
(
	LW_OBJECT_HANDLE    ulId, 
	UINT8  *pucPriority
);

```



### 描述：

该接口用来获得指定线程的优先级。

### 参数：

- ulId ：线程ID。
- pucPriority ：存放线程的优先级。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1(PVOID arg)
{
	UINT8 priority;
	// ……
	ret = Lw_Thread_GetPriority(hThreadId1, &priority);
	if(ret == 0)
	{
		printf("thread hThreadId1 priority :%d\n", priority);
	}
    // ……
}

```



## Lw_Thread_SetSlice：设置线程的时间片


### 函数原型：

```c
ULONG  Lw_Thread_SetSlice 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT16  usSlice
);

```



### 描述：

该接口用来设置线程的时间片。

### 参数：

- ulId ：线程ID。
- usSlice ：线程新的时间片。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_SetSlice(hThreadId1, 20);
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetSlice error\n");
		return (PVOID)-1;
	}
    // ……
}

```



## Lw_Thread_GetSlice：获取指定线程的时间片


### 函数原型：

```c
ULONG  Lw_Thread_GetSlice 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT16  *pusSliceTemp
);

```



### 描述：

该接口用来获得指定线程时间片。

### 参数：

- ulId ：线程ID。
- pusSliceTemp ：存放线程时间片的指针。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	UINT16 Slice;
// ……
	ret = Lw_Thread_ GetSlice (hThreadId1, &Slice);
	if(ret == 0)
	{
		printf("thread hThreadId1 Slice:%d\n", Slice);
	}
    // ……
}

```



## Lw_Thread_GetSliceEx：获取指定线程时间片和剩余的时间片


### 函数原型：

```c
ULONG  Lw_Thread_GetSliceEx 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT16  *pusSliceTemp, 
	UINT16  *pusCounter
);

```



### 描述：

该接口用来获得指定线程时间片和当前剩余的时间片。

### 参数：

- ulId ：线程ID。
- pusSliceTemp ：存放线程时间片的指针。
- pusCounter ：存放线程剩余时间片的指针。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	UINT16 Slice; 
	UINT16 counter;
// ……
	ret = Lw_Thread_GetSlice (hThreadId1, &Slice);              
	if(ret != 0)
    {
        printf("Lw_Thread_GetSlice is error");
     }
     printf("thread hThreadId1 Slice:%d\n", Slice);   
    // ……
}

```



## Lw_Thread_SetSchedParam：设置线程调度参数


### 函数原型：

```c
ULONG  Lw_Thread_SetSchedParam 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT8             ucPolicy, 
	UINT8             ucActivatedMode
);

```



### 描述：

该接口用来设置线程调度参数。

### 参数：

- ulId ：线程ID。
- ucPolicy ：线程调度策略

|线程调度策略|说明|
|---|---|
|LW_OPTION_SCHED_FIFO|先进先出|
|LW_OPTION_SCHED_RR|轮转|

- ucActivatedMode ：响应模式

|响应模式|说明|
|---|---|
|LW_OPTION_RESPOND_IMMIEDIA|高速响应线程|
|LW_OPTION_RESPOND_STANDARD|普通响应|
|LW_OPTION_RESPOND_AUTO|自动|

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_SetSchedParam(hThreadId1, LW_OPTION_SCHED_RR,
	LW_OPTION_RESPOND_IMMIEDIA);
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetSchedParam error\n");
		return (PVOID)-1;
	}
	// ……
}

```

## Lw_Thread_GetSchedParam：获取指定线程的调度参数


### 函数原型：

```c
ULONG  Lw_Thread_SetSchedParam 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT8             ucPolicy, 
	UINT8             ucActivatedMode
);

```



### 描述：

该接口用来设置线程调度参数。

### 参数：

- ulId ：线程ID。
- ucPolicy ：线程调度策略
- ucActivatedMode ：就绪到运行的速度

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID  Thread1 (PVOID  arg)
{
	UINT8 policy;
	UINT8 activatedmode;
// ……
	ret = Lw_Thread_GetSchedParam(hThreadId1, &policy, &activatedmode);
	if(ret == 0)
	{
		printf("thread hThreadId1 policy :%d  activatedmode: %d \n", policy, 					activatedmode);
	}
    // ……
}

```


## Lw_Thread_SetNotePad：设置指定线程记事本


### 函数原型：

```c
ULONG  Lw_Thread_SetNotePad 
(
	LW_OBJECT_HANDLE  ulId,
	UINT8             ucNoteIndex,
	ULONG             ulVal
);

```



### 描述：

该接口用来设置线程记事本。每个线程使用4个笔记本数量。

### 参数：

- ulId ：线程ID。
- ucNoteIndex ：线程记事本索引。
- ucActivatedMode ：线程记事本的值。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_THREAD_NOTEPAD_INDEX ：记事本索引出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_SetNotePad(hThreadId1, 0, 32);
	if(ret != 0)
	{
		perror("fun Lw_Thread_SetNotePad error\n");
		return (PVOID)-1;
	}
    // ……
}

```


## Lw_Thread_GetNotePad：获取指定线程的记事本


### 函数原型：

```c
ULONG  Lw_Thread_GetNotePad 
(
	LW_OBJECT_HANDLE  ulId,
	UINT8             ucNoteIndex
);

```


### 描述：

该接口用来获取线程指定记事本的值。

### 参数：

- ulId ：线程ID。
- ucNoteIndex ：线程记事本索引。

### 返回值：

成功返回索引到的值，失败返回0并设置相应的错误号。

### 错误码：

- ERROR_THREAD_NOTEPAD_INDEX ：记事本索引出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1 (PVOID arg)
{
	UINT8 Val;
// ……
	Val = Lw_Thread_GetNotePad(hThreadId1, 0);
	if((Val != 0) || (errno != ERROR_THREAD_NOTEPAD_INDEX))
	{
		printf("thread hThreadId1 NotePad INDEX 0 val: %d \n", Val);
	}
    // ……
}

```


## Lw_Thread_FeedWatchDog：设置当前线程的看门狗定时器


### 函数原型：

```c
ULONG  Lw_Thread_FeedWatchDog 
(
	ULONG  ulWatchDogTicks
);

```


### 描述：

该接口用来设置当前线程的看门狗定时器。

### 参数：

- ulWatchDogTicks ：看门狗定时器定时长短值。但值为0时，停止看门狗。

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
// ……
	ret = Lw_Thread_FeedWatchDog(100);
	if(ret != 0)
	{
		perror("fun Lw_Thread_FeedWatchDog error\n");
		// ……
	}
    // ……
}

```


## Lw_Thread_CancelWatchDog：取消当前线程的看门狗


### 函数原型：

```c
VOID  Lw_Thread_CancelWatchDog
(
	VOID
);

```


### 描述：

该接口用来取消当前线程的看门狗。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	int ret;
	// ……
	ret = Lw_Thread_FeedWatchDog(100);
	if(ret != 0)
	{
		perror("fun Lw_Thread_FeedWatchDog error\n");
	}
	// ……
	Lw_Thread_CancelWatchDog();
// ……
}

```


## Lw_Thread_StackCheck：检查指定线程主堆栈使用量


### 函数原型：

```c
ULONG  Lw_Thread_StackCheck 
(
	LW_OBJECT_HANDLE  ulId, 
	size_t           *pstFreeByteSize,
	size_t           *pstUsedByteSize, 
	size_t           *pstTcbByteSize
);

```



### 描述：

该接口用来检查线程主堆栈使用量

### 参数：

- ulId ：线程ID。
- pstFreeByteSize ：空闲堆栈大小(可为 LW_NULL)
- pstUsedByteSize ：使用堆栈大小(可为 LW_NULL)
- pstTcbByteSize ：线程控制块大小(可为 LW_NULL)

### 返回值：

成功返回0，失败返回相应的错误号。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_THREAD_OPTION ：线程选项与执行操作不符。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样 例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	size_t FreeBtye, UsedByte, TcbByte;
	// ……
	ret = Lw_Thread_StackCheck(hThreadId1, &FreeBtye, &UsedByte, &TcbByte);
	if(ret == 0)
	{
		printf("thread hThreadId1 FreeBtye :%lu, UsedByte :%lu, TcbByte :%lu\n",
			FreeBtye, UsedByte, TcbByte);
	}
	// ……
}

```

## Lw_Thread_GetStackMini：获取线程主堆栈的最小大小


### 函数原型：

```c
ULONG  Lw_Thread_GetStackMini 
(
	VOID
);

```



### 描述：

该接口用来获取线程主堆栈的最小大小。

### 参数：

无。

### 返回值：

返回线程主堆栈的最小大小。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG statckMini = 0;
	// ……
	statckMini = Lw_Thread_GetStackMini();
	printf("pthread statckMini :%lu\n", statckMini);
	// ……
}

```



## Lw_Thread_CPUUsageOn：启动cpu利用率测算


### 函数原型：

```c
VOID  Lw_Thread_CPUUsageOn 
(
	VOID
);

```


### 描述：

该接口用来启动CPU利用率测算。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
	ret = Lw_Thread_CPUUsageOn();
    if(ret != 0)
    {
        perror("Lw_Thread_CPUUsageOn");
        return (PVOID)-1;
     }
	// ……
}

```



## Lw_Thread_CPUUsageOff：关闭cpu利用率测算


### 函数原型：

```c
VOID  Lw_Thread_CPUUsageOff
(
	VOID
);

```



### 描述：

该接口用来关闭CPU利用率测算。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	// ……
    ret = Lw_Thread_CPUUsageOn(); 
    if(ret != 0)
    {
        perror("Lw_Thread_CPUUsageOn");
        return (PVOID)-1;
     }
	// ……
     ret = Lw_Thread_CPUUsageOff();
     if(ret != 0)
     {
        perror("Lw_Thread_CPUUsageOff");
        return (PVOID)-1;
     }
	// ……
}

```



## Lw_Thread_CPUUsageIsOn：测试cpu利用率测算是否打开


### 函数原型：

```c
BOOL  Lw_Thread_CPUUsageIsOn 
(
	VOID
);

```


### 描述：

该接口用来测试CPU利用率测算是否打开。

### 参数：

无。

### 返回值：

返回cpu利用率测试的打开情况。打开为1，否则为0。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	BOOL on;
	// ……
	on = Lw_Thread_CPUUsageIsOn();
	if(on)
	{
		printf("CPU Usage Is On\n");
	}
	else
	{
		printf("CPU Usage Is Off\n");
	}
	// ……
}

```



## Lw_Thread_GetCPUUsage：获取指定线程cpu利用率


### 函数原型：

```c
ULONG  Lw_Thread_GetCPUUsage 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT             *puiThreadUsage,
	UINT             *puiCPUUsage,
	UINT             * puiKernelUsage
);

```



### 描述：

该接口用来获取指定线程CPU利用率（千分率）。

### 参数：

- ulId ：线程ID。
- puiThreadUsage ：返回的指定线程的CPU利用率。
- puiCPUUsage ：CPU总利用率。
- puiKernelUsage ：内核利用的CPU利用率。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
    BOOL on;
	// ……
	on = Lw_Thread_CPUUsageIsOn();
	if(on)
	{
		UINT threadUsage, CPUUsage, KernelUsage;
		ret = Lw_Thread_GetCPUUsage(hThreadId1, &threadUsage, 
				&CPUUsage, &KernelUsage);
		if(ret != 0)
		{
			perror("fun Lw_Thread_GetCPUUsage error\n");
			return (PVOID)-1;
		}
		// ……		
	}
	// ……	
}

```



## Lw_Thread_GetCPUUsageAll：获取所有线程cpu利用率


### 函数原型：

```c
INT  Lw_Thread_GetCPUUsageAll 
(
	LW_OBJECT_HANDLE  ulId[], 
	UINT              uiThreadUsage[],
	UINT              uiKernelUsage[],
	INT               iSize
);

```



### 描述：

该接口用来获取所有线程CPU利用率（千分率）。不可在中断中调用，返回的利用率是经过四舍五入的值。

### 参数：

- ulId ：要检测的线程ID数组。
- uiThreadUsage ：返回指定线程的CPU利用率数组。
- uiKernelUsage ：内核利用的CPU利用率数组。
- iSize ：表格大小。

### 返回值：

获得利用率线程的个数。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
    BOOL on;
	// ……
	on = Lw_Thread_CPUUsageIsOn();
	if(on)
	{
         LW_OBJECT_HANDLE ulid[20]={hThreadId1,hThreadId2};
         UINT threadUsage[20], KernelUsage[20];
         ret = Lw_Thread_GetCPUUsageAll(ulid, threadUsage,
                                       KernelUsage, 20);
         if(ret == 0)
         {
              return (PVOID)-1;
         }
         printf("ulid1 is %d\n",threadUsage[0]);		
	    // ……		
	}
	// ……	
}

```



## Lw_Thread_CPUUsageRefresh：刷新cpu利用率


### 函数原型：

```c
ULONG  Lw_Thread_CPUUsageRefresh 
(
	VOID
);

```



### 描述：

该接口用来刷新线程CPU利用率。

### 参数：

无。

### 返回值：

成功返回0，失败返回相应的错误码：。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
    BOOL on;
	// ……
	on = Lw_Thread_CPUUsageIsOn();
	if(on)
	{
		ret = Lw_Thread_CPUUsageRefresh();
		if(ret != 0)
		{
			perror("fun  Lw_Thread_CPUUsageRefresh error\n");
		}
		// ……		
	}
	// ……	
}

```


## Lw_Thread_Yield：线程主动放弃CPU


### 函数原型：

```c
ULONG  Lw_Thread_Yield 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口将指定线程控制块移动到相同优先级就绪队列的最后。让线程主动放弃CPU。

### 参数：

- ulId ： 线程ID。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_NOT\_ READY ：线程并没有就绪。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret = Lw_Thread_Yield(hThreadId2);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Yield error\n");
	}
	// ……	
}

```
|


## Lw_Thread_Wakeup：使线程从睡眠唤醒进入就绪


### 函数原型：

```c
ULONG  Lw_Thread_Wakeup 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来将指定线程从睡眠模式唤醒。

### 参数：

- ulId ：线程ID。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_NOT_SLEEP ：线程并没有睡眠。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread1 (PVOID arg)
{
	ULONG ret = 0;
	// ……
	ret = Lw_Thread_Wakeup(hThreadId2);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Wakeup error\n");
	}
	// ……	
}

```



## Lw_Thread_VarAdd：给指定线程增加私有变量


### 函数原型：

```c
ULONG  Lw_Thread_VarAdd 
(
	LW_OBJECT_HANDLE  ulId,
	ULONG  *pulAddr
);

```



### 描述：

该接口用于给指定线程加私有变量。多处理器模式下无效，需要手动设置base下的mp_cfg.c下的LW_CFG_SMP_EN宏为0

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量的地址。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_VAR_FULL ：没有变量控制块可用。

### 样例：

```c
static LW_HANDLE			hThreadId1, hThreadId2;
ULONG  var = 0;

static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	ret = Lw_Thread_VarAdd(Lw_Thread_Self(), &var);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarAdd error");
	}
	// ……
	return LW_NULL;
}

```



## Lw_Thread_VarDelete：删除指向线程私有变量


### 函数原型：

```c
ULONG  Lw_Thread_VarDelete 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  *pulAddr
);

```



### 描述：

该接口删除指定线程的私有变量。（多处理器无效）

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量的地址。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_VAR_NOT_EXIST ：没有找到合适的控制块。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
ULONG  var = 0;
static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	ret = Lw_Thread_VarAdd(Lw_Thread_Self(), &var);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarAdd error");
	}
	// ……
	Lw_Thread_VarDelete(Lw_Thread_Self(), &var);
	// ……
	return LW_NULL;
}

```



## Lw_Thread_VarSet：设置指定线程私有变量的值


### 函数原型：

```c
ULONG  Lw_Thread_VarSet 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  *pulAddr, 
	ULONG  ulValue
);

```



### 描述：

该接口将设置指定线程的私有变量的值。（多处理器无效）

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量的地址。
- ulValue ：设置的值。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_VAR_NOT_EXIST ：没有找到合适的控制块。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
ULONG  var = 0;
static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	// ……
	ret = Lw_Thread_VarAdd(Lw_Thread_Self(), &var);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarAdd error");
	}
	ret = Lw_Thread_VarSet(Lw_Thread_Self(), &var, 20);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarSet error");
	}
	// ……
	return LW_NULL;
}

```



## Lw_Thread_VarGet：获取指定线程私有变量的值


### 函数原型：

```c
ULONG  Lw_Thread_VarGet 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  *pulAddr
);

```



### 描述：

该接口用来获取指定线程私有变量的值。（多处理器无效）

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量的地址。

### 返回值：

成功返回指定线程私有变量的值；失败返回0，并设置相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。
- ERROR_THREAD_VAR_NOT_EXIST ：没有找到合适的控制块。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_HANDLE			hThreadId1, hThreadId2;
ULONG  var = 0;
static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	ULONG value;
	// ……
	ret = Lw_Thread_VarAdd(Lw_Thread_Self(), &var);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarAdd error");
	}
	ret = Lw_Thread_VarSet(Lw_Thread_Self(), &var, 20);
	if(ret != 0)
	{
		perror("fun Lw_Thread_VarSet error");
	}
	// ……
	value = Lw_Thread_VarGet(Lw_Thread_Self(), &var);
	if(value == 0 && errno != ERROR_NONE)
	{
		perror("fun Lw_Thread_VarGet error");
	}
	// ……
	printf("test 1 value : %lu\n", value);
    // ……
	return LW_NULL;
}

```

## Lw_Thread_VarStatus：获取线程私有变量的状态


### 函数原型：

```c
ULONG  Lw_Thread_VarStatus 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  *pulAddr[],
	INT  iMaxCounter
);

```



### 描述：

该接口用于获取线程私有变量的状态。（多处理器无效且只能查看本线程私有变量状态。）

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量地址列表。
- iMaxCounter ：地址表的大小。

### 返回值：

成功返回私有变量的个数；失败返回0，并设置相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
ULONG  var = 0;
static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	int i;
	ULONG *addr[5];
    // ……
	ret = Lw_Thread_VarStatus(Lw_Thread_Self(), addr, 5);
	if(ret == 0 )
	{
		perror("fun Lw_Thread_VarStatus error");
	}
	for(i = 0; i < ret; i++)
	{
		printf("val %d : %lu\n", i, *addr[i]);
	}
    // ……
	return LW_NULL;
}

```

## Lw_Thread_VarInfo：获取线程私有变量的信息 


### 函数原型：

```c
ULONG  Lw_Thread_VarInfo 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  *pulAddr[], 
	INT  iMaxCounter
);

```



### 描述：

该接口用于获取线程私有变量的状态。（多处理器无效且只能查看本线程私有变量状态。）

### 参数：

- ulId ：线程ID。
- pulAddr ：私有变量地址列表。
- iMaxCounter ：地址表的大小。

### 返回值：

成功返回私有变量的个数；失败返回0，并设置相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：线程处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
ULONG  var = 0;
static PVOID Thread1(PVOID arg)
{
	ULONG ret;
	int i;
	ULONG *addr[5];
    // ……
	ret = Lw_Thread_VarInfo(Lw_Thread_Self(), addr, 5);
	if(ret == 0 )
	{
		perror("fun Lw_Thread_VarStatus error");
	}
	for(i = 0; i < ret; i++)
	{
		printf("val %d : %lu\n", i, *addr[i]);
	}
    // ……
	return LW_NULL;
}

```


## Lw_Thread_Verify：检测线程ID是否正确


### 函数原型：

```c
BOOL  Lw_Thread_Verify 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来检测一个线程的ID是否正确。

### 参数：

- ulId ：线程ID。

### 返回值：

正确返回1，错误返回0。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
	BOOL verify
	// ……
	verify = Lw_Thread_Verify(hThreadId2);
	if(verify)
	{
		printf("thread hThreadId2 valid\n");
	    // ……	
	}
	// ……	
}

```



## Lw_Thread_Once：安全执行一次指定函数


### 函数原型：

```c
INT  Lw_Thread_Once
(
	BOOL  *pbOnce,
	VOIDFUNCPTR  pfuncRoutine
);

```



### 描述：

该接口用来使当前线程安全的仅执行一遍指定函数。

### 参数：

- pbOnce ：必须初始化为LW_FLASE
- pfuncRoutine ：需要执行的函数。

### 返回值：

函数返回0。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static void fun(void)
{
	// ……
}
static PVOID Thread2(PVOID arg)
{
	BOOL on = LW_FALSE;
	// ……
	Lw_Thread_Once(&on, fun);
	// ……
	return LW_NULL;
}

```



## Lw_Thread_Once2：安全指向一次指定函数


### 函数原型：

```c
INT  Lw_Thread_Once2 
(
	BOOL  *pbOnce, 
	VOIDFUNCPTR  pfuncRoutine, 
	PVOID  pvArg
);

```


### 描述：

该接口用来使当前线程安全的仅执行一遍指定函数。

### 参数：

- pbOnce ：必须初始化为LW_FLASE
- pfuncRoutine ：需要执行的函数。
- pvArg ：指向函数传人的参数。

### 返回值：

函数返回0。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static void fun(PVOID a)
{
	char * str = (char *)a;
    // ……
	printf("fun run :%s\n", str);
}

static PVOID Thread1(PVOID arg)
{
	BOOL on = LW_FALSE;
    // ……
	Lw_Thread_Once2(&on, fun, "SylixOS thread test");
    // ……
	return LW_NULL;
}

```
## Lw_Thread_Cleanup_Push：将清除函数压人栈


### 函数原型：

```c
ULONG  Lw_Thread_Cleanup_Push 
(
	VOIDFUNCPTR  pfuncRoutine,
	PVOID  pvArg
);

```



### 描述：

该接口将一个清除函数压人堆栈。

### 参数：

- pfuncRoutine ：需要压栈的函数。
- pvArg ：压栈函数参数。

### 返回值：

正确返回0，错误返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HOOK_NULL ：内核钩子出错。
- ERROR_KERNEL_LOW_MEMORY ：缺少内存。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static void fun(PVOID a)
{
    // ……
}
static PVOID Thread2(PVOID arg)
{
	ULONG ret = 0;
	ret = Lw_Thread_Cleanup_Push(fun, NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cleanup_Push error\n");
	}
    // ……
}

```


## Lw_Thread_Cleanup_PushEx：将指定线程清除函数压人栈


### 函数原型：

```c
ULONG  Lw_Thread_Cleanup_PushEx 
(
	LW_OBJECT_HANDLE  ulId, 
	VOIDFUNCPTR  pfuncRoutine, 
	PVOID  pvArg
);

```



### 描述：

该接口将指定线程的清除函数压人栈，只有该线程才可以将此清除函数出栈。或者该线程结束时清除函数自动出栈。

### 参数：

- ulId ：线程ID。
- pfuncRoutine ：需要压栈的函数。
- pvArg ：压栈函数参数。

### 返回值：

正确返回0，错误返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HOOK_NULL ：内核钩子出错。
- ERROR_KERNEL_LOW_MEMORY ：缺少内存。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_THREAD_NULL ：线程句柄无效。

### 样例：


```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static void fun(PVOID a)
{
    // ……
}
static PVOID Thread1(PVOID arg)
{
	ULONG ret = 0;
	ret = Lw_Thread_Cleanup_PushEx(hThreadId2, fun, NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cleanup_Push error\n");
	}
    // ……
}
static PVOID Thread2(PVOID arg)
{
    // ……
	Lw_Thread_Cleanup_Pop(1);
	return LW_NULL;
}

```


## Lw_Thread_Cleanup_Pop：将函数出栈


### 函数原型：

```c
VOID  Lw_Thread_Cleanup_Pop 
(
	BOOL  bRun
);

```



### 描述：

该接口将一个压栈函数释放，并指定是否需要执行

### 参数：

- bRun ：指定出栈函数是否执行。1指向，0不执行。

### 返回值：

无。

### 错误码：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static void fun(PVOID a)
{
    // ……
}
static PVOID Thread2(PVOID arg)
{
	ULONG ret = 0;
	ret = Lw_Thread_Cleanup_PushEx(hThreadId1, fun, NULL);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cleanup_Push error\n");
	}
    // ……
}
static PVOID Thread1(PVOID arg)
{
    // ……
	Lw_Thread_Cleanup_Pop(1);
	return LW_NULL;
}

```


## Lw_Thread_Condattr_Init：初始化条件变量属性控制块


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_Init 
(
	ULONG  *pulAttr
);

```



### 描述：

该接口用来初始化一个条件变量属性控制块。

### 参数：

- pulAttr ：属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main(int argc , char *argv[])
{
	int    ret;
    ULONG                   ulCondAttr; 
    // ……
	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}
	// ……
	return 0;
}

```


## Lw_Thread_Condattr_Destroy：销毁条件变量属性控制块


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_Destroy 
(
	ULONG  *pulAttr
);

```


### 描述：

该接口用来销毁一个条件变量属性控制块。

### 参数：

- pulAttr ：属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main(int argc , char *argv[])
{
	int ret;
    ULONG                   ulCondAttr; 
    // ……
	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}
	// ……
	Lw_Thread_Condattr_Destroy(&ulCondAttr);
	// ……
	return 0;
}

```



## Lw_Thread_Condattr_Getpshared：获取属性块的共享属性


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_GetPshared 
(
	const ULONG  *pulAttr, 
	INT  *piShared
);

```



### 描述：

该接口用来获取一个条件变量属性控制块的共享属性。

### 参数：

- pulAttr ：属性。
- piShared ：存放共享属性的指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main(int argc , char *argv[])
{
	int ret;
    ULONG                   ulCondAttr; 
	int shared;
	// ……
	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}
	ret = Lw_Thread_Condattr_Getpshared(&ulCondAttr, &shared);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Getpshared error\n");
		return PX_ERROR;
	}
	if(shared)
	{
		printf("Thread Condattr pshared\n");
	}
	else {
		printf("Thread Condattr not pshared\n");
	}
	// ……
	return 0;
}

```



## Lw_Thread_Condattr_Setpshared：设置属性块的共享属性


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_SetPshared
(
	ULONG  *pulAttr,
	INT  iShared
);

```


### 描述：

该接口用来设置一个条件变量属性控制块的共享属性。

### 参数：

- pulAttr ：属性。
- iShared ：共享属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
int main(int argc , char *argv[])
{
	int ret;
    ULONG                   ulCondAttr; 
	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

	ret = Lw_Thread_Condattr_Setpshared(&ulCondAttr, 1);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Setpshared error\n");
		return PX_ERROR;
	}
	// ……
	return 0;
}

```


## Lw_Thread_Cond_Init：初始化条件变量控制块


### 函数原型：

```c
ULONG  Lw_Thread_Cond_Init 
(
	PLW_THREAD_COND  ptcd,
	ULONG  ulAttr
);

```



### 描述：

该接口用来初始化一个条件变量控制块。

### 参数：

- ptcd ：条件变量控制块。
- ulAttr ：控制属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EAGAIN ：系统资源不足。

- EINVAL ：参数无效。

### 样例：

```c
#include <SylixOS.h>
static LW_HANDLE			hThreadId1, hThreadId2;
static LW_HANDLE         _G_hLock;
static LW_THREAD_COND   _G_threadCond;
static PVOID Thread1(PVOID arg)
{
	// ……
	return LW_NULL;
}
static PVOID Thread2(PVOID arg)
{
	// ……
	return LW_NULL;
}
int main(int argc , char *argv[])
{
	int ret;
    ULONG                   ulCondAttr;

	hThreadId1 = Lw_Thread_Create("t_test1", Thread1, LW_NULL, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) {
		perror("Lw_Thread_Create t_test1 error\n");
		return  (PX_ERROR);
	}
	hThreadId2 = Lw_Thread_Create("t_test2", Thread2, LW_NULL, LW_NULL);
	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID) {
		perror("Lw_Thread_Create t_test2 error\n");
		return  (PX_ERROR);
	}

	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

	ret = Lw_Thread_Condattr_Setpshared(&ulCondAttr, 1);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Setpshared error\n");
		return PX_ERROR;
	}
	
	ret = Lw_Thread_Cond_Init(&_G_threadCond, ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cond_Init error\n");
		return PX_ERROR;
	}

	_G_hLock = Lw_SemaphoreM_Create("semaphorem", 100, LW_OPTION_NORMAL|
			LW_OPTION_PRIORITY_CEILING|LW_OPTION_ERRORCHECK, 	LW_NULL);

	if(_G_hLock == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_SemaphoreM_Create error\n");
		return PX_ERROR;
	}
	Lw_Thread_Join(hThreadId1, LW_NULL);
	Lw_Thread_Join(hThreadId2, LW_NULL);

	return 0;
}

```



## Lw_Thread_Cond_Destroy：销毁条件变量控制块


### 函数原型：

```c
ULONG  Lw_Thread_Cond_Destroy 
(
	PLW_THREAD_COND  ptcd
);

```



### 描述：

该接口用来销毁一个条件变量控制块。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static LW_THREAD_COND   _G_threadCond;
int main(int argc , char *argv[])
{
	// ……
	Lw_Thread_Cond_Destroy(&_G_threadCond);
}

```



## Lw_Thread_Cond_Signal：向等待条件变量的线程发送信号


### 函数原型：

```c
ULONG  Lw_Thread_Cond_Signal
(
	PLW_THREAD_COND  ptcd
);

```



### 描述：

该接口用来向等待条件变量的线程发送信号。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static INT                _G_iCount = 0;
static PVOID Thread2(PVOID arg)
{
	INT     iError;
	while (1) 
	{
		// ……
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE) 
		{
			break;
		}
		_G_iCount++;
		Lw_Thread_Cond_Signal(&_G_threadCond);
		Lw_SemaphoreM_Post(_G_hLock);
		Lw_Time_SSleep(1);
	}
	// ……
	return LW_NULL;
}

```



## Lw_Thread_Cond_Broadcast：释放等待条件变量的线程


### 函数原型：

```c
ULONG  Lw_Thread_Cond_Broadcast 
(
	PLW_THREAD_COND  ptcd
);

```



### 描述：

该接口用来向所有等待��件变量的���程发送信号。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- EAGAIN ：系统资源不足
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static INT                _G_iCount = 0;
static PVOID Thread2(PVOID arg)
{
	INT     iError;
	// ……
	while (1)
	{
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE) 
		{
			break;
		}
		_G_iCount++;
		Lw_Thread_Cond_Broadcast(&_G_threadCond);
		Lw_SemaphoreM_Post(_G_hLock);
		Lw_Time_SSleep(1);
	}
	// ……
	return LW_NULL;
}

```

## Lw_Thread_Cond_Wait：等待条件变量


### 函数原型：

```c
ULONG  Lw_Thread_Cond_Wait 
(
	PLW_THREAD_COND  ptcd,
	LW_OBJECT_HANDLE  ulMutex, 
	ULONG  ulTimeout
);

```


### 描述：

该接口用来使当前线程等待指定条件变量。

### 参数：

- ptcd ：条件变量控制块。
- ulMutex ：互斥信号量。
- ulTimeout ：超时时间。单位为时钟嘀嗒Tick。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINTR ：中断系统调用。
- EINVAL ：参数无效。
- EAGAIN ：系统资源不足。
- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static INT                _G_iCount = 0;
static PVOID Thread1(PVOID arg)
{
	INT     iError;
	while (1)
	{
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE)
		{
			break;
		}
		iError = Lw_Thread_Cond_Wait(&_G_threadCond,
			_G_hLock,LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE)
		{
			Lw_SemaphoreM_Post(_G_hLock);
			break;
		}
		printf("ThreadA(): count = %d\n", _G_iCount);
		Lw_SemaphoreM_Post(_G_hLock);
	}
	// ……
	return LW_NULL;
}

```


## Lw_Thread_Show：显示所有线程的信息


### 函数原型：

```c
VOID    Lw_Thread_Show
(
	VOID
);

```



### 描述：

该接口用来显示所有的线程的信息，不可在中断中使用。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <SylixOS.h>
static PVOID Thread2(PVOID arg)
{
	// ……
	Lw_Thread_Show();
	// ……
}

```



## Lw_Thread_ShowEx：显示指定进程中线程的信息


### 函数原型：

```c
VOID    Lw_Thread_ShowEx
(
	pid_t  pid
);

```



### 描述：

该接口用来显示指定进程中线程的信息，不可在中断中使用。

### 参数：

- pid ：需要显示对应进程中的线程的进程ID（-1表示所有线程）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
    while(1)
    {
        …...
        Lw_Thread_ShowEx(getpid());
        …...
    }
    return NULL;
}

```


## Lw_Thread_PendShow：显示所有阻塞线程的信息


### 函数原型：

```c
VOID   	Lw_Thread_PendShow
(
	VOID
);

```


### 描述：

该接口用来显示正在阻塞线程的信息，不可在中断中使用。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static PVOID Thread2(PVOID arg)
{
	// ……
	Lw_Thread_PendShow();
    // ……
}

```



## Lw_Thread_PendShowEx：显示指定进程阻塞线程的信息


### 函数原型：

```c
VOID    Lw_Thread_ShowEx
(
	pid_t  pid
);

```



### 描述：

该接口用来显示指定进程中阻塞线程的信息，不可在中断中使用。

### 参数：

- pid ：需要显示对应进程中的线程的进程ID（-1表示所有线程）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```c
#include <SylixOS.h>
#include <unistd.h>
int main()
{
	// ……
	Lw_Thread_PendShowEx(getpid());
	// ……
	return 0;
}

```



# 对象


## Lw_Object_GetClass：获得对象类型


### 函数原型：

```c
#include <SylixOS.h>
UINT8  Lw_Object_GetClass 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来获得对象的类型。

### 参数：

- ulId ：对象句柄。

### 返回值：

成功返回对象的类型号，失败返回0，并置相应的错误码。

### 错误码：

- ERROR_KERNEL_OBJECT_NULL：OBJECT为空。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	UINT8  type;
	// ……

	type = Lw_Object_GetClass(Lw_Thread_Self());                   /*  获得对象类型  */
	if(type == 0 && errno == ERROR_KERNEL_OBJECT_NULL)
	{
		perror("fun Lw_Object_GetClass error\n");
		return -1;
	}

	printf("type:%c\n",type);
    // ……
}
// ……

```



## Lw_Object_GetNode：获得对象所在的处理器号


### 函数原型：

```c
ULONG  Lw_Object_GetNode
(
	LW_OBJECT_HANDLE  ulId
);

```


### 描述：

该接口用来获得对象的处理器号。

### 参数：

- ulId ：对象句柄。

### 返回值：

成功返回对象的处理器号，失败返回((unsigned)(-1))，并置相应的错误码。

### 错误码：

- ERROR_KERNEL_OBJECT_NULL ：OBJECT 为空。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	ULONG  node;
	// ……

	node = Lw_Object_GetNode(Lw_Thread_Self());      /*  获得对象所在的处理器号 */     
	if(node == (unsigned) -1)
	{
		perror("fun Lw_Object_GetNode error\n");
		return -1 ;
	}

	printf("node :%lu\n",node);
    // ……
}
// ……

```



## Lw_Object_GetIndex：获得对象缓冲区地址


### 函数原型：

```c
ULONG  Lw_Object_ GetIndex
(
	LW_OBJECT_HANDLE  ulId
);

```


### 描述：

该接口用来获得对象的缓冲区地址。

### 参数：

- ulId ：对象句柄。

### 返回值：

成功返回对象的缓冲区地址，失败返回((unsigned)(-1))，并置相应的错误码。

### 错误码：

- ERROR_KERNEL_OBJECT_NULL ：OBJECT为空。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{	
	ULONG  index;
	// ……

	index = Lw_Object_GetIndex(Lw_Thread_Self());          /* 获得对象缓冲区地址  */
	if(index == (unsigned) -1)
	{
		perror("fun Lw_Object_GetIndex error\n");
		return -1 ;
	}

	printf("index :%lu\n",index);
    // ……
}
// ……

```


## Lw_Object_IsGlobal：查看对象是否为全局对象


### 函数原型：

```c
BOOL  Lw_Object_IsGlobal 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来查看对象是否为全局对象。

### 参数：

- ulId ：对象句柄。

### 返回值：

是全局对象返回１，不是返回0。

### 错误码：

- ERROR_KERNEL_OBJECT_NULL ：OBJECT 为空。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	BOOL  global;
	// ……

	global = Lw_Object_IsGlobal(Lw_Thread_Self());     /*  查看对象是否为全局对象  */

	printf("global : %u\n", global);
    // ……
}
// ……

```



## Lw_Object_ShareAdd：将一个内核对象注册到共享池中


### 函数原型：

```c
ULONG  Lw_Object_ShareAdd 
(
	LW_OBJECT_HANDLE  ulId, 
	UINT64  u64Key
);

```


### 描述：

该接口用来将一个内核对象注册到共享池中。

### 参数：

- ulId ：对象句柄。
- u64Key ：key

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- >   ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- >   ERROR_KERNEL_LOW_MEMORY ：缺少内存。
- >   ERROR_KERNEL_KEY_CONFLICT ：key冲突。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	ULONG  ret;
	// ……

	ret = Lw_Object_ShareAdd(Lw_Thread_Self(), 65) /* 将一个内核对象注册到共享池中 */
	if(ret != 0)
	{
		perror("fun Lw_Object_ShareAdd error\n");
		return -1 ;
	}	
    // ……
}
// ……

```


## Lw_Object_ShareDelete：将一个内核对象从共享池中删除


### 函数原型：

```c
ULONG  Lw_Object_ShareDelete 
(
	UINT64  u64Key
);

```



### 描述：

该接口用来将一个内核对象从共享池中删除。

### 参数：

- u64Key ：key

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- >   ERROR_KERNEL_HANDLE_NULL ：句柄出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	ULONG  ret;
    // ……
	
	ret = Lw_Object_ShareDelete(65);            /*  将一个内核对象从共享池中删除  */
	if(ret != 0)
	{
		perror("fun Lw_Object_ShareDelete error\n");
		return -1;
	}  
    // ……
}
// ……

```



## Lw_Object_ShareFind：获得内核对象


### 函数原型：

```c
LW_OBJECT_HANDLE  Lw_Object_ShareFind 
(
	UINT64  u64Key
);

```



### 描述：

该接口用来查询相应u64Key的内核对象。

### 参数：

- u64Key ：key

### 返回值：

成功返回对象类型，失败LW_OBJECT_HANDLE_INVALID并置相应的错误码。

### 错误码：

- >   ERROR_KERNEL_HANDLE_NULL ：句柄出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	LW_OBJECT_HANDLE  handle;
	// ……

	handle = Lw_Object_ShareFind(65);                          /*  获得内核对象  */
	if(handle == LW_OBJECT_HANDLE_INVALID)
	{
     	perror("fun Lw_Object_ShareFind error\n");
		return -1;
	}	
	// ……
}
// ……

```


# 协程


## Lw_Coroutine_Create：给当前线程创建一个协程


### 函数原型：

```c
PVOID   Lw_Coroutine_Create 
(
	PCOROUTINE_START_ROUTINE  pCoroutineStartAddr,
	size_t                  	stStackByteSize,
	PVOID                    pvArg
);

```



### 描述：

该接口用来在当前线程中创建一个协程。

### 参数：

- pCoroutineStartAddr ：协程启动地址。
- stStackByteSize ：堆栈大小。
- pvArg ：入口参数。

### 返回值：

成功返回协程控制块指针，失败返回LW_NULL并置相应的错误码。

### 错误码：

- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_IN_ISR ：系统出于中断中。
- EINVAL ：参数无效。
- ERROR_THREAD_STACKSIZE_LACK ：堆栈太小。
- ERROR_KERNEL_LOW_MEMORY ：缺少内存。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
    INT  i;
    for (i = 0; i < 5; i++)
    {
        fprintf(stdout, "coroutine0 running...\n");
        Lw_Time_SSleep(1);
    }
}
PVOID  Thread (PVOID  pvArg)
{

    PVOID  pcCrcb0, pcCrcb1;
    pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																	/*	给当前线程创建一个协程1	*/
    if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
    }	// ……
}


```
|

## Lw_Coroutine_Delete：删除指定协程


### 函数原型：

```c
ULONG   Lw_Coroutine_Delete 
(
	PVOID  pvCrcb
);

```



### 描述：

该接口用来在删除一个指定的协程。

### 参数：

- pvCrcb ：协程句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_IN_ISR ：系统出于中断中。
- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
    INT  i;
    for (i = 0; i < 5; i++)
    {
        fprintf(stdout, "coroutine0 running...\n");
        Lw_Time_SSleep(1);
    }
}
PVOID  Thread (PVOID  pvArg)
{

    PVOID  pcCrcb0, pcCrcb1;
    pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																	/*	给当前线程创建一个协程1	*/
    if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
    }	ret=Lw_Coroutine_Delete(pcCrcb0)				/*	删除指定协程	*/
    if(ret != 0)
    {
        perror("fun Lw_Coroutine_Delete error\n");
        return  (-1);
    }
// ……
}

```



## Lw_Coroutine_Exit：删除当前协程


### 函数原型：

```c
ULONG   Lw_Coroutine_Exit 
(
	VOID
);

```



### 描述：

该接口用来删除正在执行的协程。

### 参数：

无。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_NOT_RUNNING ：系统没有运行。
- ERROR_KERNEL_IN_ISR ：系统出于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
    INT  i;
    for (i = 0; i < 5; i++)
    {
        fprintf(stdout, "coroutine0 running...\n");
        Lw_Time_SSleep(1);
    }
}
PVOID  Thread (PVOID  pvArg)
{

    PVOID  pcCrcb0, pcCrcb1;
    pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																/*	给当前线程创建一个协程1	*/
    if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
}	
ret=Lw_Coroutine_Exit();							/*	  删除协程	*/
	if(ret != 0)
    {
        perror("fun Lw_Coroutine_Exit error\n");
        return  (-1);
    }
	// ……
}	

```



## Lw_Coroutine_Yield：让当前协程主动让出CPU


### 函数原型：

```c
VOID  Lw_Coroutine_Yield 
(
	VOID
);

```



### 描述：

该接口用来让当前协程主动让出CPU，用于协程调度。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
   // ……
}
VOID  coroutine1 (PVOID  pvArg)
{
	// ……
}
PVOID  Thread (PVOID  pvArg)
{

    PVOID  pcCrcb0, pcCrcb1;
    pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																	/*	给当前线程创建一个协程1	*/
    if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
}	
    pcCrcb1 = Lw_Coroutine_Create(coroutine1, 2 * 1024, LW_NULL);																	/*	给当前线程创建一个协程2	*/
    if (pcCrcb1 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create1 error\n");
        return  (-1);
}	
    Lw_Coroutine_Yield();      					/*	让当前协程主动让出CPU	*/
    return  ((PVOID)0);
}

```



## Lw_Coroutine_Resume：让当前协程让出CPU 


### 函数原型：

```c
ULONG  Lw_Coroutine_Resume 
(
	PVOID  pvCrcb
);

```



### 描述：

该接口用来让当前协程让出CPU，并调度指定的协程。

### 参数：

- pvCrcb ：需要调度的协程句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断中。

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
   // ……
}
VOID  coroutine1 (PVOID  pvArg)
{
	// ……
}
PVOID  Thread (PVOID  pvArg)
{
    PVOID  pcCrcb0, pcCrcb1;
    pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																/*	给当前线程创建一个协程1	*/
    if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
}	
    pcCrcb1 = Lw_Coroutine_Create(coroutine1, 2 * 1024, LW_NULL);																/*	给当前线程创建一个协程2	*/
    if (pcCrcb1 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create1 error\n");
        return  (-1);
}	
    ret = Lw_Coroutine_Resume(pcCrcb0);	/*	让当前协程主动让出CPU	*/
	if(ret != 0)
    {
        perror("fun Lw_Coroutine_Resume error\n");
        return  (-1);
	}
	return  ((PVOID)0);
}	

```



## Lw_Coroutine_StackCheck：查询指定协程堆栈使用量


### 函数原型：

```c
ULONG   Lw_Coroutine_StackCheck
(
	PVOID      pvCrcb, 
	size_t    *pstFreeByteSize,
	size_t    *pstUsedByteSize,
	size_t    *pstCrcbByteSize
);

```



### 描述：

该接口用来检测一个协程的堆栈使用量。该协程的父系线程建立时必须使用 STK_CHK
选项。

### 参数：

- PvCrcb ：协程句柄
- PstFreeByteSize ：空闲堆栈大小，(可为LW_NULL)
- PstUsedByteSize ：使用堆栈大小，(可为LW_NULL)
- PstCrcbByteSize ：协程控制块大小，(可为LW_NULL)

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
VOID  coroutine0 (PVOID  pvArg)
{
   // ……
}
PVOID  Thread (PVOID  pvArg)
{
	INT    ret;
	PVOID  pcCrcb0, pcCrcb1;
	size_t   FreeByteSize, UsedByteSize, CrcbByteSize;
	pcCrcb0 = Lw_Coroutine_Create(coroutine0, 2 * 1024, LW_NULL);																	/*	给当前线程创建一个协程1	*/
	if (pcCrcb0 == LW_NULL)
    {
        perror("fun Lw_Coroutine_Create0 error\n");
        return  (-1);
}	
	ret = Lw_Coroutine_StackCheck(pcCrcb0, &FreeByteSize,											&UsedByteSize, &CrcbByteSize);   /*	查询指定协程堆栈使用量	*/
	if(ret == 0)
	{
	    printf("pcCrcb0  FreeByteSize :%zd\n", FreeByteSize);
	    printf("pcCrcb0  UsedByteSize :%zd\n", UsedByteSize);
	    printf("pcCrcb0  CrcbByteSize :%zd\n", CrcbByteSize);
	}
	// ……
	return  ((PVOID)0);
}

```



# 信号量


## Lw_Semaphore_Wait：等待信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Wait
(
	LW_OBJECT_HANDLE  ulId,
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待信号量，其中包括二值信号量、计数信号量、互斥量。

### 参数：

- ulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- EINTR ：中断系统调用。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Wait (Semaphore,100);                    /*  等待信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Wait error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```

## Lw_Semaphore_Get：等待信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Get
(
	LW_OBJECT_HANDLE  ulId,
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待信号量，其中包括二值信号量、计数信号量、互斥量。

### 参数：

- ulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- EINTR ：中断系统调用。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Get (Semaphore,100);                     /*  等待信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Get error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```



## Lw_Semaphore_Take：等待信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Take
(
	LW_OBJECT_HANDLE  ulId,
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待信号量，其中包括二值信号量、计数信号量、互斥量。

### 参数：

- ulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- EINTR ：中断系统调用。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Take (Semaphore,100);                    /*  等待信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Take error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```


Lw_Semaphore_Post：释放信号量
---

### 函数原型：

```c
ULONG Lw_Semaphore_Post
(
	LW_OBJECT_HANDLE  ulId,
);

```


### 描述：

该接口用来释放量，其中包括二值信号量、计数信号量、互斥量、读写锁。

### 参数：

- ulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。
- ERROR_KERNEL_IN_ISR ：系统处于中断中(读写锁、互斥量)。
- ERROR_EVENT_NOT_OWN ：没有事件所有权(读写锁、互斥量)。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Post (Semaphore);                        /*  释放信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Post error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```



## Lw_Semaphore_Give：释放信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Give
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放量，其中包括二值信号量、计数信号量、互斥量、读写锁。

### 参数：

- ulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。
- ERROR_KERNEL_IN_ISR ：系统处于中断中(读写锁、互斥量)。
- ERROR_EVENT_NOT_OWN ：没有事件所有权(读写锁、互斥量)。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Give(Semaphore);                        /*  释放信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Give error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```


## Lw_Semaphore_Send：释放信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Send
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放量，其中包括二值信号量、计数信号量、互斥量、读写锁。

### 参数：

- ulId：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。
- ERROR_KERNEL_IN_ISR ：系统处于中断中(读写锁、互斥量)。
- ERROR_EVENT_NOT_OWN ：没有事件所有权(读写锁、互斥量)。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_Semaphore_Send (Semaphore);                       /*  释放信号量  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Send error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```



## Lw_Semaphore_Flush：释放等待信号量的所有线程


### 函数原型：

```c
ULONG Lw_Semaphore_Flush
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               *pulThreadUnblockNum
)

```



### 描述：

该接口用来释放等待信号量的所有线程，其中包括二值信号量、计数信号量。

### 参数：

- ulId ：事件句柄。
- pulThreadUnblockNum ：存放被解锁的线程数量的指针（可为NULL）。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret =Lw_Semaphore_Flush(Semaphore, NULL);   /*  释放等待信号量的所有线程  */
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_Flush error\n");
		 return LW_NULL;
	 }
     // ……
     return ((PVOID)1);
}
// ……

```


## Lw_Semaphore_Delete：删除信号量


### 函数原型：

```c
ULONG Lw_Semaphore_Delete
(
	LW_OBJECT_HANDLE ulId, 
);

```


### 描述：

该接口用来删除信号量，其中包括二值信号量、计数信号量、互斥量、读写锁。

### 参数：

- ulId：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE Semaphore;
// ……
int main (int argc, char **argv)
{
	LW_HANDLE hId1, hId2;
	int       ret;

	/* 
	 *  创建一个计数信号量 
	 */
	Semaphore = Lw_SemaphoreC_Create("SemaphoreC1", 2, 5,                     LW_OPTION_WAIT_PRIORITY|LW_OPTION_OBJECT_LOCAL, LW_NULL); 
	if(Semaphore == LW_HANDLE_INVALID)
	{
		return (PX_ERROR);
	}
	// ……

	ret = Lw_Semaphore_Delete(&Semaphore);                      /* 删除信号量   */
	if(ret != 0)
	{
		perror("fun Lw_Semaphore_Delete error\n");
		return (PX_ERROR);
	}

    return (ERROR_NONE);
}

```



## Lw_Semaphore_PostBPend：释放等待一个二值信号量


### 函数原型：

```c
ULONG Lw_Semaphore_PostBPend
(
	LW_OBJECT_HANDLE ulIdPost,
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来释放一个信号量后立即开始等待另外一个信号量(中间无任务切换发生)，其中释放的信号量可以是二值信号量、计数信号量、互斥量。等待的信号量只能是二值信号量。

### 参数：

- ulIdPost ：需要释放的信号量。
- ulId ：需要等待的信号量。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

>   成功返回0，失败返回相应的错误码。

### 错误码：

- >   ERROR_KERNEL_IN_IS ：系统处于中断。
- ERROR_KERNEL_HANDLE_NUL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

- EINTR ：中断系统调用。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE Semaphore;
static LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
	/*   
	 *  释放等待一个二值信号量   
	 */
	 ret = Lw_Semaphore_PostBPend (Semaphore, SemaphoreB, 100);    
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_PostBPend error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_Semaphore_PostCPend：释放等待一个计数信号量


### 函数原型：

```c
ULONG Lw_Semaphore_PostCPend
(
	LW_OBJECT_HANDLE ulIdPost,
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来释放一个信号量后立即开始等待另外一个信号量(中间无任务切换发生)，其中释放的信号量可以是二值信号量、计数信号量、互斥量。等待的信号量只能是计数信号量。

### 参数：

- ulIdPos ：需要释放的信号量。
- ulId ：需要等待的信号量。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。
- EINTR ：中断系统调用。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE Semaphore;
static LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	/*   
	 *  释放等待一个计数信号量   
	 */
	 ret = Lw_Semaphore_PostCPend (Semaphore, SemaphoreC, 100);    
	 if(ret != 0)
	 {
		 perror("fun Lw_Semaphore_PostCPend error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```


## Lw_SemaphoreC_Create：创建一个计数型信号量


### 函数原型：

```c
LW_OBJECT_HANDLE Lw_SemaphoreC_Create
(
	CPCHAR      pcName,
	ULONG       ulInitCounter,
	ULONG       ulMaxCounter,
	ULONG       ulOption,
	LW_OBJECT_ID *pulId
);

```



### 描述：

该接口用来创建一个计数型信号量。

### 参数：

- pcName ：事件名缓冲区
- ulInitCounte ：初始化计数值
- ulMaxCounter ：最大计数值
- ulOption ：事件选项，取值有：

|lOption|说明|
|---|---|
|LW_OPTION_WAIT_PRIORITY|按优先级顺序等待|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）|
|LW_OPTION_OBJECT_LOCAL|本地对象|
|LW_OPTION_SIGNAL_INTER|可被信号打断(EINTR)|
|LW_OPTION_SIGNAL_UNINTER|不可被信号打断|

- pulId ：事件ID指针

### 返回值：

成功返回创建的信号量的句柄，失败返回 LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_EVENT_MAX_COUNTER_NULL ：最大值错误。
- ERROR_EVENT_INIT_COUNTER ：初始值错误。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
int main (int argc, char **argv)
{
	LW_HANDLE hId1, hId2;
	int       ret;

	/* 
	 *  创建一个计数信号量 
	 */
	SemaphoreC = Lw_SemaphoreC_Create("SemaphoreC1", 2, 5,                 
	LW_OPTION_WAIT_PRIORITY|LW_OPTION_OBJECT_LOCAL, LW_NULL);
	if(SemaphoreC == LW_HANDLE_INVALID)
	{
		return (PX_ERROR);
	}
	// ……

	return (ERROR_NONE);
}

```



## Lw_SemaphoreC_Delete：删除指定的计数型信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Delete
(
	LW_OBJECT_HANDLE *pulId
);

```



### 描述：

该接口用来删除指定计数型信号量。

### 参数：

- pulId：事件ID指针

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
int main (int argc, char **argv)
{
	LW_HANDLE hId1, hId2;
	int       ret;

	/* 
	 *  创建一个计数信号量 
	 */
	SemaphoreC = Lw_SemaphoreC_Create("SemaphoreC1", 2, 5,                 
	LW_OPTION_WAIT_PRIORITY|LW_OPTION_OBJECT_LOCAL, LW_NULL);
	if(SemaphoreC == LW_HANDLE_INVALID)
	{
		return (PX_ERROR);
	}
    // ……
	ret = Lw_SemaphoreC_Delete(&SemaphoreC);                 /* 删除计数信号量 */
	if(ret != 0)
	{
		perror("fun Lw_Semaphore_Delete error\n");
		return (PX_ERROR);
	}
	// ……

	return (ERROR_NONE);
}

```



## Lw_SemaphoreC_TryWait：尝试等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_TryWait
(
	LW_OBJECT_HANDLE ulId
);

```



### 描述：

该接口用来无阻塞的等待计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_TryWait(SemaphoreC);            /* 尝试等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_TryWait error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_TryGet：尝试等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_TryGet
(
	LW_OBJECT_HANDLE ulId
);

```



### 描述：

该接口用来无阻塞的等待计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回 0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_TryGet(SemaphoreC);             /* 尝试等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_TryGet error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_TryTake ：尝试等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_TryTake
(
	LW_OBJECT_HANDLE ulId
);

```



### 描述：

该接口用来无阻塞的等待计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_TryTake(SemaphoreC);            /* 尝试等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_TryTake error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Wait：限时等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Wait
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待计数型信号量。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数）。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_Wait(SemaphoreC,100);            /* 限时等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Wait error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Get：限时等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Get
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待计数型信号量。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NUL ：句柄出错。
- ERROR_EVENT_TYP ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_Get(SemaphoreC,100);             /* 限时等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Get error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```

## Lw_SemaphoreC_Take：限时等待计数信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Take
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待计数型信号量。当等待时间为__ARCH_ULONG_MAX
时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreC_Take(SemaphoreC,100);            /* 限时等待计数信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Take error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```


## Lw_SemaphoreC_Release：释放指定次数的信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Release
(
	LW_OBJECT_HANDLE ulId,
	ULONG             ulReleaseCounter,
	ULONG             *pulPreviousCounter
);

```



### 描述：

该接口用来释放计数型信号量。

### 参数：

- pulId ：事件句柄。
- ulReleaseCounter ：释放的信号量的个数。
- pulPreviousCounter ：保存原先的信号量个数。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_EVENT_NULL ：事件控制块错误。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret = Lw_SemaphoreC_Release(SemaphoreC, 5, NULL);  /* 释放指定次数的信号量 */
	 if(ret == 0)
	 {
		 perror("fun Lw_SemaphoreC_Release error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```

## Lw_SemaphoreC_Post：释放信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Post
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret = Lw_SemaphoreC_Post(SemaphoreC);                        /* 释放信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Post error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Give：释放信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Give
(
	LW_OBJECT_HANDLE  ulId,
);


```


### 描述：

该接口用来释放计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret = Lw_SemaphoreC_Give(SemaphoreC);                       /* 释放信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Give error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Send：释放信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Send
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放计数型信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FUL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret = Lw_SemaphoreC_Send(SemaphoreC);                       /* 释放信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Send error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Flush：释放等待信号量的所有线程 


### 函数原型：

```c
ULONG Lw_SemaphoreC_Flush
(
	LW_OBJECT_HANDLE  ulId,
	ULONG               *pulThreadUnblockNum
)

```



### 描述：

该接口用来释放等待计数型信号量的所有线程。

### 参数：

- pulId ：事件句柄。
- pulThreadUnblockNum ：存放被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret =Lw_SemaphoreC_Flush(SemaphoreC, NULL); /*  释放等待信号量的所有线程  */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Flush error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```


## Lw_SemaphoreC_Clear：清除计数型信号量


### 函数原型：

```c
ULONG Lw_SemaphoreC_Clear
(
	LW_OBJECT_HANDLE ulId,
);

```



### 描述：

该接口用来清除计数型信号量。

### 参数：

- ulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
     // ……

	 ret = Lw_SemaphoreC_Clear(SemaphoreC);                 /* 清除计数型信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreC_Clear error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Status：查询计数型信号量的状态


### 函数原型：

```c
ULONG Lw_SemaphoreC_Status
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```



### 描述：

该接口用来查询计数型信号量的状态。

### 参数：

- ulId ：事件句柄
- pulCounter ：事件计数值 可以为NULL
- pulOption ：事件选项指针 可以为NULL
- pulThreadBlockNum ：被解锁的线程数量可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
	 ULONG counter = 0 , option = 0, blocknum = 0;
     // ……

	 /* 
	  *  查询计数型信号量的状态 
	  */
	 ret = Lw_SemaphoreC_Status(SemaphoreC, &counter, &option, &blocknum); 
	 if(ret == 0)
	 {
		 printf("SemaphoreC counter value :%lu\n", counter);
		 printf("SemaphoreC option value :%lu\n", option);
		 printf("SemaphoreC blocknum value :%lu\n", blocknum);
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_Info：查询计数型信号量的状态


### 函数原型：

```c
ULONG Lw_SemaphoreC_Info
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```



### 描述：

该接口用来查询计数型信号量的状态。

### 参数：

- ulI ：事件句柄
- pulCounter ：事件计数值可以为NULL
- pulOption ：事件选项指针可以为NULL
- pulThreadBlockNum ：被解锁的线程数量可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
	 ULONG counter = 0 , option = 0, blocknum = 0;
    // ……

	/* 
	 *  查询计数型信号量的状态 
	 */
	 ret = Lw_SemaphoreC_Info(SemaphoreC, &counter, &option, &blocknum); 
	 if(ret == 0)
	 {
		 printf("SemaphoreC counter value :%lu\n", counter);
		 printf("SemaphoreC option value :%lu\n", option);
		 printf("SemaphoreC blocknum value :%lu\n", blocknum);
	 }
     // ……

     return ((PVOID)1);
}
// ……

```


## Lw_SemaphoreC_StatusEx：查询计数型信号量的状态


### 函数原型：

```c
ULONG Lw_SemaphoreC_StatusEx
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum,
	ULONG             *pulMaxCounter
);

```



### 描述：

该接口用来查询计数型信号量的状态。

### 参数：

- pulId ：事件句柄
- pulCounter ：事件计数值，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulThreadBlockNum ：被锁定的线程数量，可以为NULL
- pulMaxCounte ：最大计数值，可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYP ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
	 ULONG counter = 0 , option = 0, blocknum = 0; maxCounter = 0;
     // ……
	
	 ret = Lw_SemaphoreC_StatusEx(SemaphoreC, &counter, &option, &blocknum,
       &maxCounter);                               /* 查询计数型信号量的状态 */
	 if(ret == 0)
	 {
		 printf("SemaphoreC counter value :%lu\n", counter);
		 printf("SemaphoreC option value :%lu\n", option);
		 printf("SemaphoreC blocknum value :%lu\n", blocknum);
		 printf("SemaphoreC maxCounter value :%lu\n", maxCounter);
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_InfoEx：查询计数型信号量的状态 


### 函数原型：

```c
ULONG Lw_SemaphoreC_InfoEx
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum,
	ULONG             *pulMaxCounter
);

```


### 描述：

接口用来查询计数型信号量的状态。

### 参数：

- pulId ：事件句柄
- pulCounter ：事件计数值，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulThreadBlockNum ：被锁定的线程数量，可以为NULL
- pulMaxCounter ：最大计数值，可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	ULONG counter = 0 , option = 0, blocknum = 0; maxCounter = 0;
   	// ……

	ret = Lw_SemaphoreC_InfoEx(SemaphoreC, &counter, &option, &blocknum, 	&maxCounter);                                 /* 查询计数型信号量的状态 */
	if(ret == 0)
	{
		printf("SemaphoreC counter value :%lu\n", counter);
		printf("SemaphoreC option value :%lu\n", option);
		printf("SemaphoreC blocknum value :%lu\n", blocknum);
		printf("SemaphoreC maxCounter value :%lu\n", maxCounter);
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreC_GetName：获取计数信号量的名字


### 函数原型：

```c
ULONG Lw_SemaphoreC_GetName
(
	LW_OBJECT_HANDLE ulId,
	PCHAR pcName
);

```



### 描述：

该接口用来获取计数信号量的名字。

### 参数：

- pulId ：事件句柄。
- pcName ：存放信号量名字的指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreC;
// ……
PVOID Thread2 (PVOID pvArg)
{
  	 ULONG ret = 0;
	 char name[32] = {0};
     // ……

     ret = Lw_SemaphoreC_GetName(SemaphoreC, name);   /* 获取计数信号量的名字  */
     if(ret == 0)
     {
        printf("SemaphpreC name is %s\n", name);
     }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Create：创建一个二值信号量


### 函数原型：

```c
LW_OBJECT_HANDLE Lw_SemaphoreB_Create
(
	CPCHAR pcName,
	BOOL bInitValue,
	ULONG ulOption,
	LW_OBJECT_ID *pulId
);

```



### 描述：

该接口用来创建一个二值信号量。创建二值信号量时它的初始值赋值为0。

### 参数：

- pcName ：事件名缓冲区
- bInitValue ：初始化计数值
- ulOption ：事件选项，取值有：

|ulOption|说明|
|---|---|
|LW_OPTION_WAIT_PRIORITY|按优先级顺序等待|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）|
|LW_OPTION_OBJECT_LOCAL|本地对象|
|LW_OPTION_SIGNAL_INTER|可被信号打断 (EINTR)|
|LW_OPTION_SIGNAL_UNINTER|不可被信号打断|

- pulId ：事件ID指针

### 返回值：

成功返回创建的信号量的句柄，失败返回LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
   // ……

   return ((PVOID)1);
}
PVOID Thread2 (PVOID pvArg)
{
   	// ……

	return ((PVOID)1);
}
int main (int argc, char **argv)
{
	LW_HANDLE hId1, hId2;
	int       ret;

	/*  
	 *  创建二值信号量            
	 */
	SemaphoreB = Lw_SemaphoreB_Create("SemaphoreB1", 0, 	LW_OPTION_WAIT_PRIORITY | LW_OPTION_OBJECT_LOCAL, LW_NULL); 
	if(SemaphoreB == LW_OBJECT_HANDLE_INVALID)
	{
	    return (PX_ERROR);
	}

	/*  
	 *  创建第 1 个线程             
	 */
	hId1 = Lw_Thread_Create("t_test1", Thread1, LW_NULL, LW_NULL);  
	if (hId1 == LW_HANDLE_INVALID)
	{
	    return (PX_ERROR);
	}

	/*  
	 *  创建第 2 个线程            
	 */
	hId2 = Lw_Thread_Create("t_test2", Thread2, LW_NULL, LW_NULL); 
	if (hId2 == LW_HANDLE_INVALID)
	{
	    return (PX_ERROR);
	}
	// ……

    return (ERROR_NONE);
}

```



## Lw_SemaphoreB_Delete：删除指定的二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Delete
(
	LW_OBJECT_HANDLE *pulId
);

```


### 描述：

该接口用来删除指定二值信号量。

### 参数：

- pulId ：事件ID指针

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
   // ……

   return ((PVOID)1);
}
PVOID Thread2 (PVOID pvArg)
{
   // ……

   return ((PVOID)1);
}
int main (int argc, char **argv)
{
	LW_HANDLE hId1, hId2;
	int       ret;

	/*  
	 *  创建二值信号量        
	 */
	SemaphoreB = Lw_SemaphoreB_Create("SemaphoreB1", 0, 	LW_OPTION_WAIT_PRIORITY | LW_OPTION_OBJECT_LOCAL, LW_NULL);
	if(SemaphoreB == LW_OBJECT_HANDLE_INVALID)
	{
	    return (PX_ERROR);
	}
	// ……
	ret = Lw_SemaphoreB_Delete(&SemaphoreB);                 /* 删除二值信号量 */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_Delete error\n");
		return (PX_ERROR);
	}

    return (ERROR_NONE);
}

```



## Lw_SemaphoreB_TryWait：尝试等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_TryWait
(
	LW_OBJECT_HANDLE ulId
);

```



### 描述：

该接口用来无阻塞的等待二值信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreB_TryWait(SemaphoreB);            /* 尝试等待二值信号量 */      
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_TryWait error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_TryGet：尝试等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_TryGet
(
	LW_OBJECT_HANDLE ulId
);

```



### 描述：

该接口用来无阻塞的等待二值信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreB_TryGet(SemaphoreB);             /* 尝试等待二值信号量 */    
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_TryGet error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_TryTake：尝试等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_TryTake
(
	LW_OBJECT_HANDLE ulId
);

```
|


### 描述：

该接口用来无阻塞的等待二值信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreB_TryTake(SemaphoreB);            /* 尝试等待二值信号量 */               
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_Take error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Wait：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Wait
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待二值信号量。

### 参数：

- pulI ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

 	 ret = Lw_SemaphoreB_Wait(SemaphoreB，100);          /* 限时等待二值信号量 */       
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_Wait error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Get：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Get
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待二值信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

	 ret = Lw_SemaphoreB_Get(SemaphoreB，100);           /* 限时等待二值信号量 */     
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_Get error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Take：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Take
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout
);

```



### 描述：

该接口用来等待二值信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;

 	 ret = Lw_SemaphoreB_Take(SemaphoreB，100);          /* 限时等待二值信号量 */
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_Take error\n");
		 return LW_NULL;
	 }
     // ……

     return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_WaitEx：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_ WaitEx
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout,
	PVOID               *ppvMsgPtr
);

```



### 描述：

该接口用来等待二值信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- ppvMsgPtr ：传送的消息。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	PVOID msg;
	// ……

	/* 
	 *  限时获取二值信号量,并接受传送消息  
	 */
	ret = Lw_SemaphoreB_WaitEx(SemaphoreB, 150, &msg);
	if(ret != 0)                                            
	{
		perror("fun Lw_SemaphoreB_WaitEx error\n");
		return LW_NULL;
	}
	else
	{
	    printf("Lw_SemaphoreB_WaitEx : %p\n", msg);
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_GetEx：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_ GetEx
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout,
	PVOID               *ppvMsgPtr
);

```


### 描述：

该接口用来等待二值信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- ppvMsgPtr ：传送的消息。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	PVOID msg;
	// ……

	/*  
	 *  限时获取二值信号量,并接受传送消息  
	 */
	ret = Lw_SemaphoreB_GetEx(SemaphoreB, 150, &msg);
	if(ret != 0)                                            
	{
		perror("fun Lw_SemaphoreB_GetEx error\n");
		return LW_NULL;
	}
	else
	{
	    printf("Lw_SemaphoreB_GetEx : %p\n", msg);
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_TakeEx：限时等待二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_ TakeEx
(
	LW_OBJECT_HANDLE ulId,
	ULONG              ulTimeout,
	PVOID               *ppvMsgPtr
);

```



### 描述：

该接口用来等待二值信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- ppvMsgPtr ：传送的消息。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	PVOID msg;
	// ……

	/* 
	 *  限时获取二值信号量,并接受传送消息  
	 */
	ret = Lw_SemaphoreB_TakeEx(SemaphoreB, 150, &msg);
	if(ret != 0)                                            
	{
		perror("fun Lw_SemaphoreB_TakeEx error\n");
		return LW_NULL;
	}
	else
	{
	    printf("Lw_SemaphoreB_TakeEx : %p\n", (char*)msg);
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Release：释放指定次数的二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Release
(
	LW_OBJECT_HANDLE ulId,
	ULONG ulReleaseCounter,
	ULONG *pulPreviousCounter
);

```



### 描述：

该接口用来释放二值信号量。

### 参数：

- pulId ：事件句柄。
- ulReleaseCounter ：释放的信号量的个数。
- pulPreviousCounter ：保存原先的信号量个数。

### 返回值：

成功返回 0，失败返回相应的错误码。

### 错误码：

- ERROR_EVENT_NULL ：事件控制块错误。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
	BOOL PreviousCounter = 0;
	// ……

	/* 
	 *  释放指定次数的信号量 
	 */
	ret = Lw_SemaphoreB_Release(SemaphoreB, 3, &PreviousCounter);
	if(ret != 0 )
	{
		perror("fun Lw_SemaphoreB_Release error\n");
		if(errno != ERROR_EVENT_FULL)
		{
		    return LW_NULL;
		}
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Post：释放一次二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Post
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放一次二值信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
	// ……

	ret = Lw_SemaphoreB_Post (SemaphoreB);               /* 发送一次二值信号量 */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_Post error\n");
	}
	// ……

    return ((PVOID)1);
}
// ……

```


## Lw_SemaphoreB_Give：释放一次二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Give
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放一次二值信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
// ……

	ret = Lw_SemaphoreB_Give (SemaphoreB);               /* 发送一次二值信号量 */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_Give error\n");
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Send：释放一次二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Send
(
	LW_OBJECT_HANDLE  ulId,
);

```



### 描述：

该接口用来释放一次二值信号量。

### 参数：

- pulId：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
	// ……

	ret = Lw_SemaphoreB_Send (SemaphoreB);               /* 发送一次二值信号量 */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_Send error\n");
	}
	// ……

    return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_PostEx：释放一次二值信号量 


### 函数原型：

```c
ULONG Lw_SemaphoreB_ PostEx
(
	LW_OBJECT_HANDLE ulId,
	PVOID pvMsgPtr
);

```



### 描述：

该接口用来释放一次二值信号量。并带有简单传递功能。

### 参数：

- pulId ：事件句柄。
- pvMsgPtr ：传递的消息指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
	char *msg = "SylixOS system";
	/* 
	 *  发送一次二值信号量，并传送消息 
	 */
	ret = Lw_SemaphoreB_PostEx (SemaphoreB,msg);                      
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_PostEx error\n");
	}
	// ……

	return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_GiveEx：释放一次二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_ GiveEx
(
	LW_OBJECT_HANDLE ulId,
	PVOID pvMsgPtr
);

```


### 描述：

该接口用来释放一次二值信号量。并带有简单传递功能。

### 参数：

- pulId ：事件句柄。
- pvMsgPtr ：传递的消息指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	ULONG ret = 0;
	char *msg = "SylixOS system";
	/* 
	 *  发送一次二值信号量，并传送消息
	 */
	ret = Lw_SemaphoreB_GiveEx (SemaphoreB,msg);                      
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_GiveEx error\n");
	}
	// ……

	return ((PVOID)1);
}
// ……

```
## Lw_SemaphoreB_SendEx：释放一次二值信号量，并传送消息


### 函数原型：

```c
ULONG Lw_SemaphoreB_ SendEx
(
	LW_OBJECT_HANDLE ulId,
	PVOID pvMsgPtr
);

```



### 描述：

该接口用来释放一次二值信号量。并带有简单传递功能。

### 参数：

- pulId ：事件句柄。
- pvMsgPtr ：传递的消息指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
#include <malloc.h>
static  LW_OBJECT_HANDLE SemaphoreB;
PVOID Thread1 (PVOID pvArg)
{
	 ULONG ret = 0;
	 char *msg = "SylixOS system";
	 /* 
	  *  发送一次二值信号量，并传送消息
	  */
	 ret = Lw_SemaphoreB_SendEx (SemaphoreB,msg);                      
	 if(ret != 0)
	 {
		 perror("fun Lw_SemaphoreB_SendEx error\n");
	 }
	 // ……
	 return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Flush：释放等待信号量的所有线程


### 函数原型：

```c
ULONG Lw_SemaphoreB_Flush
(
	LW_OBJECT_HANDLE  ulId,
	ULONG               *pulThreadUnblockNum
)

```



### 描述：

该接口用来释放等待二值信号量的所有线程。

### 参数：

- pulId ：事件句柄。
- pulThreadUnblockNum ：存放被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	// ……

	/*    
	 *  释放等待二值信号量的所有线程
	 */
	ret =Lw_SemaphoreB_Flush(SemaphoreB, LW_NULL);                   
	if(ret != 0)
	{
	    perror("fun Lw_SemaphoreB_Flush error\n");
		return LW_NULL;
	}
	// ……

	return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Clear：清除二值信号量


### 函数原型：

```c
ULONG Lw_SemaphoreB_Clear
(
	LW_OBJECT_HANDLE ulId,
);

```



### 描述：

该接口用来清除二值信号量。

### 参数：

1. ulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	ULONG ret = 0;
	// ……

	ret = Lw_SemaphoreB_Clear(SemaphoreB);                   /* 清除二值信号量 */
 	if(ret != 0)
	{
		perror("fun Lw_SemaphoreB_Clear error\n");
 		return LW_NULL;
	}
	// ……

	return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Status：查询二值信号量的状态


### 函数原型：

```c
ULONG Lw_SemaphoreB_Status
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```
|


### 描述：

该接口用来查询二值信号量的状态。

### 参数：

- ulId ：事件句柄
- pulCounter ：事件计数值，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulThreadBlockNum ：被解锁的线程数量，可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{  
     ULONG ret = 0;
	 BOOL Value;
	 ULONG Option, BlockNum;
     // ……

	 /* 
	  *  查询二值信号量的状态 
	  */
	 ret = Lw_SemaphoreB_Status(SemaphoreB, &Value, &Option, &BlockNum);  
	 if(ret == 0)
	 {
		 printf("SemaphoreB Value :%u \n", Value);
		 printf("SemaphoreB Option:%lu \n", Option);
		 printf("SemaphoreB BlockNum :%lu \n", BlockNum);
	 }
     // ……

	 return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_Info：查询二值信号量的状态


### 函数原型：

```c
ULONG Lw_SemaphoreB_Info
(
	LW_OBJECT_HANDLE ulId,
	ULONG             *pulCounter,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```



### 描述：

该接口用来查询二值信号量的状态。

### 参数：

- ulId ：事件句柄
- pulCounter ：事件计数值，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulThreadBlockNum ：被解锁的线程数量，可以为NULL

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{  
     ULONG ret = 0;
	 BOOL Value;
	 ULONG Option, BlockNum;
     // ……

	 /* 
	  *  查询二值信号量的状态 
	  */
	 ret = Lw_SemaphoreB_Info(SemaphoreB, &Value, &Option, &BlockNum);  
	 if(ret == 0)
	 {
		 printf("SemaphoreB Value :%u \n", Value);
		 printf("SemaphoreB Option:%lu \n", Option);
		 printf("SemaphoreB BlockNum :%lu \n", BlockNum);
	 }
     // ……
	 return ((PVOID)1);
}
// ……

```



## Lw_SemaphoreB_GetName：获取二值信号量的名字


### 函数原型：

```c
ULONG Lw_SemaphoreB_GetName
(
	LW_OBJECT_HANDLE ulId,
	PCHAR              pcName
);

```



### 描述：

该接口用来获取计数信号量的名字。

### 参数：

- pulId ：事件句柄。
- pcName ：存放信号量名字的指针。

### 返回值：

成功返回 0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreB;
// ……
PVOID Thread2 (PVOID pvArg)
{
	 ULONG ret = 0;
	 char name[32] = {0};
     // ……

 	 ret = Lw_SemaphoreB_GetName(SemaphoreB, name);   /* 获取二值信号量的名字  */    
     if(ret == 0)
     {
        printf("SemaphpreB name is %s\n", name);
     }
     // ……

	 return ((PVOID)1);
}
// ……

```



# 互斥量


## Lw_SemaphoreM_Create：创建一个互斥量


### 函数原型：

```c
LW_OBJECT_HANDLE  Lw_SemaphoreM_Create 
(
	CPCHAR             pcName,
	UINT8              ucCeilingPriority,
	ULONG              ulOption,
	LW_OBJECT_ID      *pulId
);

```



### 描述：

该接口用来创建一个互斥信号量。

### 参数：

- pcName ：事件名缓冲区。
- pulId ：事件ID指针。
- bInitValue ：如果使用天花板优先级，此参数为天花板优先级。
- ulOption ：事件选项，取值有：

|互斥量事件选项|意义|
|---|---|
|LW_OPTION_NORMAL|按优先级顺序等待|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）|
|LW_OPTION_OBJECT_LOCAL|本地对象|
|LW_OPTION_NORMAL|递归时不检查 (不推荐)|
|LW_OPTION_ERRORCHECK|Mutex or RW 递归时报错|
|LW_OPTION_RECURSIVE|Mutex or RW 支持写递归调用|
|LW_OPTION_SIGNAL_INTER|可被信号打断 (EINTR)|
|LW_OPTION_SIGNAL_UNINTER|不可被信号打断|
|LW_OPTION_INHERIT_PRIORITY|优先级继承算法|
|LW_OPTION_PRIORITY_CEILING|优先级天花板算法|

### 返回值：

成功返回创建的信号量的句柄，失败返回LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_THREAD_PRIORITY_WRONG ：优先级错误。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE            _G_hLock;
static INT          		_G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
int main (int argc, char *argv[])
{	
	int					       	   ret=0;
   	LW_CLASS_THREADATTR   	   threadattr;
   	LW_HANDLE               hThreadAId;
   	LW_HANDLE               hThreadBId;
	_G_hLock=Lw_SemaphoreM_Create("hello",LW_PRIO_HIGH,LW_OPTION_WAIT_FIFO|LW_OPTION_OBJECT_LOCAL|LW_OPTION_INHERIT_PRIORITY|LW_OPTION_ERRORCHECK,LW_NULL);                                  		/*   创建一个互斥量	*/
	if (_G_hLock == LW_OBJECT_HANDLE_INVALID)
	{
		printf("mutex create failed.\n");
        return  (-1);
    }
	// ……
	return  (0);
}

```



## Lw_SemaphoreM_Delete：删除指定的互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_Delete
(
	LW_OBJECT_HANDLE  *pulId
);

```



### 描述：

该接口用来删除指定互斥信号量。

### 参数：

- pulId ：事件ID指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE         _G_hLock;
static INT          		_G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
int main (int argc, char *argv[])
{	
	int					       	   ret=0;
   	LW_CLASS_THREADATTR   	   threadattr;
   	LW_HANDLE               hThreadAId;
   	LW_HANDLE               hThreadBId;
	_G_hLock=Lw_SemaphoreM_Create("hello",LW_PRIO_HIGH,LW_OPTION_WAIT_FIFO|LW_OPTION_OBJECT_LOCAL|LW_OPTION_INHERIT_PRIORITY|LW_OPTION_ERRORCHECK,LW_NULL);                                    	/*   创建一个互斥量	*/
	if (_G_hLock == LW_OBJECT_HANDLE_INVALID)
   	{
       	printf("mutex create failed.\n");
       	return  (-1);
    }
	// ……
	ret=Lw_SemaphoreM_Delete(&_G_hLock);                    /*	删除互斥量	*/
   	if(ret != 0)
   	{
       	perror("fun Lw_SemaphoreM_Delete error\n");
       	return  (-1);
   	}
	return  (0);
}

```



## Lw_SemaphoreM_Wait：限时等待互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_Wait 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来等待互斥信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|等待类型|意义|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EDEADLK ：死锁。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Wait  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Post(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Post  error \n");
        	exit(1);
        }
    }
    return  (LW_NULL);
}

```



## Lw_SemaphoreM_Get：限时等待互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_ Get
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来等待互斥信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|等待类型|意义|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EDEADLK ：死锁。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)	
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Get(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Get  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Post(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Post  error \n");
        	exit(1);
        }
    }
}   	return  (LW_NULL);
}

```



## Lw_SemaphoreM_Take：限时等待互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_ Take
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来等待互斥信号量。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|等待类型|意义|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EDEADLK ：死锁。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Take(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Take  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Post(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Post  error \n");
        	exit(1);
        }
    }
    return  (LW_NULL);
}

```



## Lw_SemaphoreM_Give ：释放互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_Give
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来释放互斥信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE             _G_hLock;
static INT                 _G_iCount = 0;
LW_OBJECT_HANDLE        SemaphoreM;
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Wait  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Give(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Give  error \n");
        	exit(1);
        }
    }
    return  (LW_NULL);
}

```


## Lw_SemaphoreM_Post ：释放互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_ Post
(
	LW_OBJECT_HANDLE  ulId
);

```


### 描述：

该接口用来释放互斥信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE            _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Wait  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Post(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Post  error \n");
        	exit(1);
        }
    }
    return  (LW_NULL);
}

```



## Lw_SemaphoreM_Send：释放互斥量


### 函数原型：

```c
ULONG  Lw_SemaphoreM_ Send
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来释放互斥信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE            _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE    	      _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE  	   SemaphoreM;
static PVOID  Thread1 (PVOID  pvArg)
{
    while (1)
    {
    	int     ret=0;
        ret = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);	        		if(ret != 0)						/*	限时等待互斥量	             */
        {
        	perror("fun  Lw_SemaphoreM_Wait  error\n");
        	return (PVOID)-1;
        }
        _G_iCount++;
        printf("Thread1(): count = %d\n", _G_iCount);
        sleep(3);
        ret=Lw_SemaphoreM_Send(_G_hLock);	/*	释放互斥量	                 */
        if(ret != 0 )
        {
        	perror("fun Lw_SemaphoreM_Send  error \n");
        	exit(1);
        }
    }
    return  (LW_NULL);
}

```



## Lw_SemaphoreM_Status：查询互斥量的状态


### 函数原型：

```c
ULONG  Lw_SemaphoreM_Status 
(
	LW_OBJECT_HANDLE   ulId, 
	BOOL              *pbValue,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```


### 描述：

该接口用来查询互斥信号量的状态。

### 参数：

- ulId ：事件句柄。
- pbValue ：事件计数值，可以为NULL。
- pulOption ：事件选项指针，可以为NULL。
- pulThreadBlockNum ：被解锁的线程数量，可以为NULL。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE             _G_hLock;
static INT                 _G_iCount = 0;
LW_OBJECT_HANDLE        SemaphoreM;
static PVOID  Thread1(PVOID  pvArg)
{
   	while (1)
   	{
    	int ret = 0;
    	BOOL value;
    	ULONG option, blockNum;
    	ret = Lw_SemaphoreM_Status(_G_hLock, &value, &option, &blockNum);																/*	获取互斥量信息 */
    	if(ret == 0)
    	{
    		printf("SemaphoreM  value :%d \n", value);
    		printf("SemaphoreM  option :%#lx\n", option);
    		printf("SemaphoreM  blockNum :%lu\n", blockNum);
    	}
		// ……
	}
   	return  (LW_NULL);
}

```



## Lw_SemaphoreM_Info：查询互斥量的状态


### 函数原型：

```c
ULONG  Lw_SemaphoreM_ Info
(
	LW_OBJECT_HANDLE   ulId, 
	BOOL              *pbValue,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```


### 描述：

该接口用来查询互斥信号量的状态。

### 参数：

- ulId ：事件句柄。
- pbValue ：事件计数值，可以为NULL。
- pulOption ：事件选项指针，可以为NULL。
- pulThreadBlockNum ：被解锁的线程数量，可以为NULL。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE            _G_hLock;
static INT                _G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
static PVOID  Thread1(PVOID  pvArg)
{
   	while (1)
   	{
    	int ret = 0;
    	BOOL value;
    	ULONG option, blockNum;
    	ret = Lw_SemaphoreM_Info(_G_hLock, &value, &option, &blockNum);																	/*	获取互斥量信息 */
    	if(ret == 0)
    	{
    		printf("SemaphoreM  value :%d \n", value);
    		printf("SemaphoreM  option :%#lx\n", option);
    		printf("SemaphoreM  blockNum :%lu\n", blockNum);
    	}
	// ……
	}
   	return  (LW_NULL);
}

```



## Lw_SemaphoreM_StatusEx：查询互斥量的状态


### 函数原型：

```c
ULONG  Lw_SemaphoreC_StatusEx 
(
	LW_OBJECT_HANDLE   ulId, 
	BOOL              *pbValue,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum, 
	LW_OBJECT_HANDLE  *pulOwnerId
);

```



### 描述：

该接口用来查询计数型信号量状态。

### 参数：

- pulId ：事件句柄。
- pbValue ：事件计数值，可以为NULL。
- pulOption ：事件选项指针，可以为NULL。
- pulThreadBlockNum ：被锁定的线程数量，可以为NULL。
- pulMaxCounter ：信号量的拥有者，可以为NULL。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE           _G_hLock;
static INT          	  _G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
static PVOID  Thread1(PVOID  pvArg)
{
   	while (1)
  	{
    	int ret = 0;
    	BOOL value;
    	ULONG option, blockNum;
    	LW_OBJECT_HANDLE ownerId;
    	ret = Lw_SemaphoreM_StatusEx(_G_hLock, &value, &option, &blockNum, &ownerId);										 		/*	获取互斥量信息 */ 
    	if(ret == 0)
    	{
    		printf("SemaphoreM  value :%d \n", value);
    		printf("SemaphoreM  option :%#lx\n", option);
    		printf("SemaphoreM  blockNum :%lu\n", blockNum);
    		printf("SemaphoreM  ownerId :%lx\n", ownerId);
    	}
		…..
	}
   	return  (LW_NULL);
}

```



## Lw_SemaphoreM_InfoEx：查询互斥量的状态


### 函数原型：

```c
ULONG  Lw_SemaphoreC_ InfoEx
(
	LW_OBJECT_HANDLE   ulId, 
	BOOL              *pbValue,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum, 
	LW_OBJECT_HANDLE  *pulOwnerId
);

```



### 描述：

该接口用来查询计数型信号量状态。

### 参数：

- pulId ：事件句柄。
- pbValue ：事件计数值，可以为NULL。
- pulOption ：事件选项指针，可以为NULL。
- pulThreadBlockNum ：被锁定的线程数量，可以为NULL。
- pulMaxCounter ：信号量的拥有者，可以为NULL。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE            _G_hLock;
static INT          	   _G_iCount = 0;
LW_OBJECT_HANDLE       SemaphoreM;
static PVOID  Thread1(PVOID  pvArg)
{
   	while (1)
   	{
    	int ret = 0;
    	BOOL value;
    	ULONG option, blockNum;
    	LW_OBJECT_HANDLE ownerId;
    	ret = Lw_SemaphoreM_ InfoEx (_G_hLock, &value, &option, &blockNum, &ownerId);										 		/*	获取互斥量信息 */ 
    	if(ret == 0)
    	{
    		printf("SemaphoreM  value :%d \n", value);
    		printf("SemaphoreM  option :%#lx\n", option);
    		printf("SemaphoreM  blockNum :%lu\n", blockNum);
    		printf("SemaphoreM  ownerId :%lx\n", ownerId);
    	}
		// ……
	}
    	return  (LW_NULL);
}

```



## Lw_SemaphoreM_GetName：获取互斥量的名字


### 函数原型：

```c
ULONG  Lw_SemaphoreM_GetName
(
	LW_OBJECT_HANDLE  ulId, 
	PCHAR  pcName
);

```



### 描述：

该接口用来获取互斥信号量的名字。

### 参数：

- pulId ：事件句柄。
- pcName ：存放互斥量名字的指针。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE             _G_hLock;
static INT                 _G_iCount = 0;
LW_OBJECT_HANDLE        SemaphoreM;
int main (int argc, char *argv[])
{	
	int		ret=0;
   	LW_CLASS_THREADATTR   	   threadattr;
   	LW_HANDLE               hThreadAId;
   	LW_HANDLE               hThreadBId;
	_G_hLock=Lw_SemaphoreM_Create("hello",LW_PRIO_HIGH,LW_OPTION_WAIT_FIFO|LW_OPTION_OBJECT_LOCAL|LW_OPTION_INHERIT_PRIORITY|LW_OPTION_ERRORCHECK,LW_NULL);                                    	/*   创建一个互斥量	*/
   	if (_G_hLock == LW_OBJECT_HANDLE_INVALID)
   	{
       	printf("mutex create failed.\n");
       	return  (-1);
   	}
static PVOID  Thread1(PVOID  pvArg)
{
   	while (1)
   	{
    	int     ret=0;
    	char name[32] = {0};
    	ret = Lw_SemaphoreM_GetName(_G_hLock, name);   	 /*	获取互斥量的名字 */
    	if(ret == 0)
    	{
    		printf("SemaphoreM name :%s\n", name);
    	}
		// ……
	}
   	return  (LW_NULL);
}

```



# 条件变量


## Lw_Thread_Condattr_Init：初始化条件变量属性控制块


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_Init 
(
	ULONG  *pulAttr
);

```



### 描述：

该接口用来初始化一个条件变量属性控制块。

### 参数：

- pulAttr ：属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
int main(int argc , char *argv[])
{
	int    ret;
    ULONG                   ulCondAttr; 

	ret = Lw_Thread_Condattr_Init(&ulCondAttr); /*  初始化条件变量属性          */
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

// ……

	return 0;
}

```



## Lw_Thread_Condattr_Destroy：销毁条件变量属性控制块


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_Destroy 
(
	ULONG  *pulAttr
);

```


### 描述：

该接口用来销毁一个条件变量属性控制块。

### 参数：

- pulAttr ：属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
int main(int argc , char *argv[])
{

	int ret;
    ULONG                   ulCondAttr; 

	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

	// ……

	Lw_Thread_Condattr_Destroy(&ulCondAttr);   /*  销毁条件变量属性          */

// ……

	return 0;
}

```



## Lw_Thread_Condattr_Getpshared：获取控制块的共享属性


### 函数原型：

```c
ULONG  Lw_Thread_CondAttr_GetPshared 
(
	const ULONG  *pulAttr, 
	INT  *piShared
);

```


### 描述：

该接口用来获取一个条件变量属性控制块的共享属性。

### 参数：

- pulAttr ：属性。
- piShared ：存放共享属性的指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h>
int main(int argc , char *argv[])
{

	int ret;
    ULONG                   ulCondAttr; 
	int shared;

	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}
	ret = Lw_Thread_Condattr_Getpshared(&ulCondAttr, &shared); /*  获取条件变量属性          */
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Getpshared error\n");
		return PX_ERROR;
	}
	if(shared)
	{
		printf("Thread Condattr pshared\n");
	}
	else {
		printf("Thread Condattr not pshared\n");
	}

// ……

	return 0;
}

```



## Lw_Thread_Condattr_Setpshared：设置控制块的共享属性


### 函数原型：

```C
ULONG  Lw_Thread_CondAttr_SetPshared
(
	ULONG  *pulAttr,
	INT  iShared
);

```



### 描述：

该接口用来设置一个条件变量属性控制块的共享属性。

### 参数：

- pulAttr ：属性。
- iShared ：共享属性，0不共享，非0则共享。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main(int argc , char *argv[])
{
	int ret;
    ULONG                   ulCondAttr; 
	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

	ret = Lw_Thread_Condattr_Setpshared(&ulCondAttr, 1);  /*  设置条件变量属性 */
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Setpshared error\n");
		return PX_ERROR;
	}

// ……

	return 0;
}

```



## Lw_Thread_Cond_Init：初始化条件变量控制块


### 函数原型：

```C
ULONG  Lw_Thread_Cond_Init 
(
	PLW_THREAD_COND  ptcd,
	ULONG  ulAttr
);

```



### 描述：

该接口用来初始化一个条件变量控制块。

### 参数：

- ptcd ：条件变量控制块。
- ulAttr ：控制属性。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EAGAIN ：系统资源不足。
- EINVAL ：参数无效。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <SylixOS.h>
static LW_HANDLE			hThreadId1, hThreadId2;
static LW_HANDLE         _G_hLock;
static LW_THREAD_COND   _G_threadCond;

static PVOID tTest1(PVOID arg)
{
	// ……
	return LW_NULL;
}
static PVOID tTest2(PVOID arg)
{
	// ……
	return LW_NULL;
}
int main(int argc , char *argv[])
{

	int ret;
    ULONG                   ulCondAttr;

	hThreadId1 = Lw_Thread_Create("t_test1", tTest1, LW_NULL, LW_NULL);
	if (hThreadId1 == LW_OBJECT_HANDLE_INVALID) {
		perror("Lw_Thread_Create t_test1 error\n");
		return  (PX_ERROR);
	}
	hThreadId2 = Lw_Thread_Create("t_test2", tTest2, LW_NULL, LW_NULL);
	if (hThreadId2 == LW_OBJECT_HANDLE_INVALID) {
		perror("Lw_Thread_Create t_test2 error\n");
		return  (PX_ERROR);
	}

	ret = Lw_Thread_Condattr_Init(&ulCondAttr);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Init error\n");
		return PX_ERROR;
	}

	ret = Lw_Thread_Condattr_Setpshared(&ulCondAttr, 1);
	if(ret != 0)
	{
		perror("fun Lw_Thread_Condattr_Setpshared error\n");
		return PX_ERROR;
	}

	
	ret = Lw_Thread_Cond_Init(&_G_threadCond, ulCondAttr); /*  初始化条件变量 */
	if(ret != 0)
	{
		perror("fun Lw_Thread_Cond_Init error\n");
		return PX_ERROR;
	}

	_G_hLock = Lw_SemaphoreM_Create("semaphorem", 100, LW_OPTION_NORMAL |
			LW_OPTION_PRIORITY_CEILING | LW_OPTION_ERRORCHECK, LW_NULL);

	if(_G_hLock == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_SemaphoreM_Create error\n");
		return PX_ERROR;
	}
	Lw_Thread_Join(hThreadId1, LW_NULL);
	Lw_Thread_Join(hThreadId2, LW_NULL);

	return 0;
}

```



## Lw_Thread_Cond_Destroy：销毁条件变量控制块


### 函数原型：

```C
ULONG  Lw_Thread_Cond_Destroy 
(
	PLW_THREAD_COND  ptcd
);

```


### 描述：

该接口用来销毁一个条件变量控制块.。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static LW_THREAD_COND   _G_threadCond;
int main(int argc , char *argv[])
{
	// ……
	Lw_Thread_Cond_Destroy(&_G_threadCond); /*  销毁条件变量控制块*/
}

```



## Lw_Thread_Cond_Signal：向等待条件变量的线程发送信号


### 函数原型：

```C
ULONG  Lw_Thread_Cond_Signal
(
	PLW_THREAD_COND  ptcd
);

```



### 描述：

该接口用来向等待条件变量的线程发送信号。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static INT                _G_iCount = 0;
static PVOID tTest2(PVOID arg)
{
	INT     iError;

	while (1) 
	{
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE) 
		{
			break;
		}

		_G_iCount++;
		Lw_Thread_Cond_Signal(&_G_threadCond); /*  向等待条件变量的线程发送信号 */

		Lw_SemaphoreM_Post(_G_hLock);

		Lw_Time_SSleep(1);
	}

	return LW_NULL;
}

```



## Lw_Thread_Cond_Broadcast：向等待条件变量的线程发送信号


### 函数原型：

```C
ULONG  Lw_Thread_Cond_Broadcast 
(
	PLW_THREAD_COND  ptcd
);

```


### 描述：

该接口用来向所有等待条件变量的线程发送信号。

### 参数：

- ptcd ：条件变量控制块。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：参数无效。
- EAGAIN ：系统资源不足
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static INT                _G_iCount = 0;
static PVOID tTest2(PVOID arg)
{
	INT     iError;
	while (1) 
	{
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE) {
			break;
		}

		_G_iCount++;
		Lw_Thread_Cond_Broadcast(&_G_threadCond); /*  向所有等待条件变量的线程发送信号 */

		Lw_SemaphoreM_Post(_G_hLock);

		Lw_Time_SSleep(1);
	}

	return LW_NULL;
}

```



## Lw_Thread_Cond_Wait ：等待条件变量


### 函数原型：

```C
ULONG  Lw_Thread_Cond_Wait 
(
	PLW_THREAD_COND  ptcd,
	LW_OBJECT_HANDLE  ulMutex, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来使当前线程等待指定条件变量。

### 参数：

- ptcd ：条件变量控制块。
- ulMutex ：互斥信号量。
- ulTimeout ：超时时间。单位为时钟嘀嗒Tick。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINTR ：中断系统调用。
- EINVAL ：参数无效。
- EAGAIN ：系统资源不足。
- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENT_WAS_DELETED ：事件已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static INT                _G_iCount = 0;
static PVOID tTest1(PVOID arg)
{
	INT     iError;
	while (1) 
	{
		iError = Lw_SemaphoreM_Wait(_G_hLock, LW_OPTION_WAIT_INFINITE);
		if (iError != ERROR_NONE)
		{
			break;
		}
	   iError = Lw_Thread_Cond_Wait(&_G_threadCond, /*  等待条件变量    */
										  _G_hLock,
										  LW_OPTION_WAIT_INFINITE);
	   if (iError != ERROR_NONE) {
		   Lw_SemaphoreM_Post(_G_hLock);
		   break;
	   }
		printf("tTestA(): count = %d\n", _G_iCount);

		Lw_SemaphoreM_Post(_G_hLock);
	}

	return LW_NULL;
}

```



# 读写锁


## Lw_SemaphoreRW_Create：创建一个读写信号量


### 函数原型：

```C
LW_OBJECT_HANDLE  Lw_SemaphoreRW_Create 
(
	CPCHAR             pcName,
	ULONG              ulOption,
	LW_OBJECT_ID      *pulId
);

```



### 描述：

该接口用来创建一个读写锁信号量。

### 参数：

- pcName ：事件名缓冲区。
- ulOption ：事件选项，取值有：

|ulOption|说明|
|---|---|
|LW_OPTION_NORMAL|按优先级顺序等待|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）|
|LW_OPTION_OBJECT_LOCAL|本地对象|
|LW_OPTION_RW_PREFER_READER|读访问优先|
|LW_OPTION_RW_PREFER_WRITER|写访问优先|
|LW_OPTION_NORMAL|递归时不检查(不推荐)|
|LW_OPTION_ERRORCHECK|MutexorRW递归时报错|
|LW_OPTION_RECURSIVE|MutexorRW支持写递归调用|
|LW_OPTION_SIGNAL_INTER|可被信号打断(EINTR)|
|LW_OPTION_SIGNAL_UNINTER|不可被信号打断|

- pulId ：事件ID指针。

### 返回值：

成功返回创建的信号量的句柄，失败返回LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_EVENT_FULL ：事件控制块已用完。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread1(PVOID pvArg)
{
	// ……

	return LW_NULL;
}
PVOID Thread2(PVOID pvArg)
{
	// ……

	return LW_NULL;
}
int main (int argc, char **argv)
{   
    int       ret;
	LW_HANDLE hId1, hId2;
   
	SemaphoreRW = Lw_SemaphoreRW_Create("Semaphorerw1", 
	LW_OPTION_RW_PREFER_WRITER, LW_NULL);  /*  创建一个读写信号量  */
	if(SemaphoreRW == LW_OBJECT_HANDLE_INVALID)
	{
		return (PX_ERROR);
	}
	/*  
	 *  创建第 1 个线程     
	 */
	hId1 = Lw_Thread_Create("t_test", Thread1, LW_NULL, LW_NULL);
	if (hId1 == LW_HANDLE_INVALID) 
	{
		perror("fun Lw_Thread_Create error");
		return (PX_ERROR);
	}
	/*  
	*  创建第 2 个线程   
	*/
	hId2 = Lw_Thread_Create("t_test", Thread2, LW_NULL, LW_NULL);
	if (hId2 == LW_HANDLE_INVALID) 
	{
		perror("fun Lw_Thread_Create error");
		return (PX_ERROR);
	}
	// ……
    return  (0);
}

```



## Lw_SemaphoreRW_Delete：删除指定的读写锁信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_Delete
(
	LW_OBJECT_HANDLE  *pulId
);

```


### 描述：

该接口用来删除指定读写锁。

### 参数：

- pulId ：事件ID指针

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
int main (int argc, char **argv)
{
    int       ret;
	SemaphoreRW=Lw_SemaphoreRW_Create("Semaphorerw1", 	LW_OPTION_WAIT_INFINITE, LW_NULL);      /*  创建一个读写信号量  */
	if(SemaphoreRW == LW_OBJECT_HANDLE_INVALID)
	{
		return (PX_ERROR);
	}
	// ……
	ret = Lw_SemaphoreRW_Delete(&SemaphoreRW);       /* 删除指定的读写锁信号 */
	if(ret != 0)
	{
	    perror("fun Lw_SemaphoreRW_RGet error\n");
		return -1;
	}
	// ……
    return (ERROR_NONE);
}

```



## Lw_SemaphoreRW_RWait：限时等待读信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_RWait 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待读写信号量读锁。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。


```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread1(PVOID pvArg)
{
	ULONG ret;
 	// ……
  	/* 
	 *  限时等待读信号量   
	 */
	ret = Lw_SemaphoreRW_RWait(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_RWait error\n");
		return (PVOID)-1;
	}
  	// ……

	return LW_NULL;
}

```


## Lw_SemaphoreRW_RGet：限时等待读信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_RWait 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待读写信号量读锁。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread1(PVOID pvArg)
{
	ULONG ret;
  	// ……
	/* 
	 *  限时等待读信号量   
	 */
	ret = Lw_SemaphoreRW_RGet(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_RGet error\n");
		return (PVOID)-1;
	}
    // ……
	return LW_NULL;
}

```



## Lw_SemaphoreRW_RTake：限时等待读信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_RWait 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG                ulTimeout
);

```



### 描述：

该接口用来等待读写信号量读锁。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread1(PVOID pvArg)
{
	ULONG ret;
  	// ……
	/* 
	 *  限时等待读信号量   
	 */
	ret = Lw_SemaphoreRW_RTake(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_RTake error\n");
		return (PVOID)-1;
	}
  	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_WWait：限时等待写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_WWait 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               ulTimeout
);

```



### 描述：

该接口用来等待读写信号量写锁。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
  	// ……
  	/*
     *  限时等待写信号量   
	 */
	ret = Lw_SemaphoreRW_WWait(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_WWait error\n");
		return (PVOID)-1;
	}
	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_WGet：限时等待写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_ WGet
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来等待读写信号量写锁。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
  	// ……
	/* 
	 *  限时等待写信号量   
	 */
	ret = Lw_SemaphoreRW_WGet(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_WGet error\n");
		return (PVOID)-1;
	}
	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_WTake：限时等待写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_ WTake
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG  ulTimeout
);

```



### 描述：

该接口用来等待读写信号量写锁。当等待时间为__ARCH_ULONG_MAX时，一直等待。时间为0时，不等待。

### 参数：

- pulId ：事件句柄。
- ulTimeout ：等待时间（时钟滴答数），取值有：

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_EVENT_WAS_DELETED ：时间已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
	// ……
	/* 
	 *  限时等待写信号量   
	 */
	ret = Lw_SemaphoreRW_WTake(SemaphoreRW, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_WTake error\n");
		return (PVOID)-1;
	}
	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_Give：释放读写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_ Give
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来释放读写信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
	// ……
	ret = Lw_SemaphoreRW_Give(SemaphoreRW);               /* 释放读写信号量  */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_Give error\n");
		exit(1);
	}
	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_Post：释放读写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_Post
(
	LW_OBJECT_HANDLE  ulId
);

```


### 描述：

该接口用来释放读写信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
	// ……                                                
	ret = Lw_SemaphoreRW_Post (SemaphoreRW);               /* 释放读写信号量  */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_Post error\n");
		exit(1);
	}
	// ……
	return LW_NULL;
}

```



## Lw_SemaphoreRW_Send：释放读写信号量


### 函数原型：

```C
ULONG  Lw_SemaphoreRW_Send
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来释放读写信号量。

### 参数：

- pulId ：事件句柄。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。
- ERROR_EVENT_NOT_OWN ：没有事件所有权。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
	// ……                                                                                
	ret = Lw_SemaphoreRW_Send (SemaphoreRW);               /* 释放读写信号量  */
	if(ret != 0)
	{
		perror("fun Lw_SemaphoreRW_Send error\n");
		exit(1);
	}
	// ……
	return LW_NULL;
}

```



## Lw_SemaphoreRW_Status：查询读写锁信号量的状态


### 函数原型：

```C
ULONG  Lw_SemaphoreB_Status 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               *pulRWCount,
	ULONG               *pulRPend,
	ULONG               *pulWPend,
	ULONG               *pulOption,
	LW_OBJECT_HANDLE  *pulOwnerId
);

```



### 描述：

该接口用来查询计读写锁信号量的状态。

### 参数：

- ulId ：事件句柄
- pulRWCount ：有多少任务正在并发操作读写锁，可以为NULL
- pulRPend ：当前阻塞读操作的数量，可以为NULL
- pulWPend ：当前阻塞写操作的数量，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulOwnerId ：读写锁中写锁的拥有者，可以为NULL

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG       ret;
	ULONG       RWCount, RPend, WPend, Option;
	LW_OBJECT_HANDLE  OwnerId;
  	// ……
                                           
	ret = Lw_SemaphoreRW_Status(SemaphoreRW, &RWCount, &RPend, &WPend, &Option, 	&OwnerId);                                 /* 查询读写锁信号量的状态      */
	if(ret == 0)
	{
		printf("SemaphoreRW RWCount : %lu\n", RWCount);
		printf("SemaphoreRW RPend : %lu\n", RPend);
		printf("SemaphoreRW WPend : %lu\n", WPend);
		printf("SemaphoreRW Option : %lu\n", Option);
		printf("SemaphoreRW OwnerId : %lx\n", OwnerId);
	}
  	// ……

	return LW_NULL;
}

```



## Lw_SemaphoreRW_Info：查询读写锁信号量的状态


### 函数原型：

```C
ULONG  Lw_SemaphoreB_Status 
(
	LW_OBJECT_HANDLE  ulId, 
	ULONG               *pulRWCount,
	ULONG               *pulRPend,
	ULONG               *pulWPend,
	ULONG               *pulOption,
	LW_OBJECT_HANDLE  *pulOwnerId
);

```



### 描述：

该接口用来查询计读写锁信号量的状态。

### 参数：

- ulId ：事件句柄
- pulRWCount ：有多少任务正在并发操作读写锁，可以为NULL
- pulRPend ：当前阻塞读操作的数量，可以为NULL
- pulWPend ：当前阻塞写操作的数量，可以为NULL
- pulOption ：事件选项指针，可以为NULL
- pulOwnerId ：读写锁中写锁的拥有者，可以为NULL

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static  LW_OBJECT_HANDLE SemaphoreRW;
PVOID Thread2(PVOID pvArg)
{
	ULONG ret;
	ULONG       RWCount, RPend, WPend, Option;
	LW_OBJECT_HANDLE  OwnerId;
	// ……                                      

	ret = Lw_SemaphoreRW_Info(SemaphoreRW, &RWCount, &RPend, &WPend, &Option, 	&OwnerId);                                 /* 查询读写锁信号量的状态      */
	if(ret == 0)
	{
		printf("SemaphoreRW RWCount : %lu\n", RWCount);
		printf("SemaphoreRW RPend : %lu\n", RPend);
		printf("SemaphoreRW WPend : %lu\n", WPend);
		printf("SemaphoreRW Option : %lu\n", Option);
		printf("SemaphoreRW OwnerId : %lx\n", OwnerId);
	}	
	// ……

	return LW_NULL;
}

```



# 事件集


## Lw_Event_Create ：创建一个事件集


### 函数原型：

```C
LW_OBJECT_HANDLE	Lw_ Event_Create 
(
	CPCHAR			pcName, 
	ULONG				ulInitEvent,
	ULONG				ulOption,
	LW_OBJECT_ID	*pulId
);

```



### 描述：

该接口用来创建一个事件集。

### 参数：

- pcName ：事件名缓冲区。
- ulInitEvent ：初始化事件。
- ulOption ：事件选项。

|属性对象|说明|
|---|---|
|LW_OPTION_WAIT_PRIORITY|按优先级顺序等待。|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待。|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）。|

- pulId ：事件ID指针。

### 返回值：

成功返回创建的信号量的句柄，失败返回LW_OBJECT_HANDLE_INVALID。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_EVENTSET_FULL ：事件集已满

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

int main (int argc, char **argv)
{
	// ……
	eventSet = Lw_Event_Create("event1", 0, LW_OPTION_WAIT_PRIORITY, LW_NULL);
	if(eventSet == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_Event_Create error\n");
		return (PX_ERROR);
	}

	// ……

	return  (0);
}

```



## Lw_Event_Delete ：删除指定的事件集


### 函数原型：

```C
ULONG  Lw_ Event_Delete
(
	LW_OBJECT_HANDLE	*pulId
);

```



### 描述：

该接口用来删除指定的事件集。

### 参数：

- pulId ：事件ID指针

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR\_ KERNEL_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

static LW_OBJECT_HANDLE eventSet;
int main (int argc, char **argv)
{
	eventSet = Lw_Event_Create("event1", 0, LW_OPTION_WAIT_PRIORITY, LW_NULL);
	if(eventSet == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_Event_Create error\n");
		return (PX_ERROR);
	}

	// ……

	Lw_Event_Delete(&eventSet);
	return  (0);
}

```



## Lw_Event_TryWait ：尝试等待事件集中的相关事件


### 函数原型：

```C
ULONG  Lw_ Event_TryWait 
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```



### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_AL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_A|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_AL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_A|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG	ret = 0;

	// ……

	ret = Lw_Event_TryWait(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,LW_OPTION_EVENTSET_WAIT_CLR_ALL | LW_OPTION_EVENTSET_RESET);
	if(ret != 0)
	{
		perror("fun Lw_Event_TryWait error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 0\n");

	// ……

	return LW_NULL;
}

```



## Lw_Event_TryGet ：尝试等待事件集中的相关事件


### 函数原型：

```C
ULONG  Lw_ Event_ TryGet
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```


### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_AL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_A|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_AL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_AL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_A|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_AL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_AL|指定事件都为0时激活|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;

	// ……

	ret = Lw_Event_TryGet(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,LW_OPTION_EVENTSET_WAIT_CLR_ALL | LW_OPTION_EVENTSET_RESET);
	if(ret != 0)
	{
		perror("fun Lw_Event_TryGet error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 0\n");

	// ……

	return LW_NULL;
}

```



## Lw_Event_TryTake ：尝试等待事件集中的相关事件


### 函数原型：

```C
ULONG  Lw_ Event_ TryTake
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```



### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_AL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_A|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_AL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_A|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- ERROR_EVENTSET_WAIT_TIMEOUT ：事件等待超时。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;

	// ……

	ret = Lw_Event_TryTake(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,LW_OPTION_EVENTSET_WAIT_CLR_ALL | LW_OPTION_EVENTSET_RESET);
	if(ret != 0)
	{
		perror("fun Lw_Event_TryTake error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 0\n");

	// ……

	return LW_NULL;
}

```



## Lw_Event_TryWaitEx：尝试等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_ TryWaitEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption,
	ULONG					*pulEvent
);

```



### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件。
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- pulEvent ：接受的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;
	// ……

	ret = Lw_Event_TryWaitEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_CLR_ALL| LW_OPTION_EVENTSET_RESET,&ulevent );
	if(ret != 0)
	{
		perror("fun Lw_Event_TryWaitEx error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_TryGetEx ：尝试等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_ TryGetEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption,
	ULONG					*pulEvent
);

```



### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件。
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- pulEvent ：接受的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;
	// ……

	ret = Lw_Event_TryGetEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_CLR_ALL | LW_OPTION_EVENTSET_RESET,&ulevent );
	if(ret != 0)
	{
		perror("fun Lw_Event_TryGetEx error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_TryTakeEx ：尝试等待事件集中的相关事件


### 函数原型：

```C
ULONG  Lw_ Event_ TryTakeEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption ,
	ULONG					*pulEvent
);

```



### 描述：

该接口用来无阻塞的等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- pulEvent ：接受的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;
	// ……

	ret = Lw_Event_TryTakeEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_CLR_ALL | LW_OPTION_EVENTSET_RESET, &ulevent );
	if(ret != 0)
	{
		perror("fun Lw_Event_TryTakeEx error\n");
		return (PVOID)-1;
	}
	for (i = 0; i < 32; i++) 
	{
		if (ulevent & (1 << i)) {
			printf("get event %d\n", i);
		}
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_Wait ：限时等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_Wait
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECO|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread1(PVOID arg)
{
	ULONG  ret = 0;
	// ……

ret = Lw_Event_Wait(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,
			LW_OPTION_EVENTSET_WAIT_SET_ALL | LW_OPTION_EVENTSET_RESET,
			LW_OPTION_WAIT_INFINITE);
	if(ret != 0)
	{
		perror("fun Lw_Event_Wait error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 1\n");

	// ……

	return LW_NULL;
}

```



## Lw_Event_Get ：限时等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_Get
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;

	ret = Lw_Event_Get(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,
			LW_OPTION_EVENTSET_WAIT_SET_ALL | LW_OPTION_EVENTSET_RESET,LW_OPTION_WAIT_INFINITE);
	if(ret != 0)
	{
		perror("fun Lw_Event_Get error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 1\n");

	return LW_NULL;
}


```


## Lw_Event_Take ：限时等待事件集中的相关事件


### 函数原型：

```C
ULONG  Lw_ Event_Take
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;
// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	// ……

ret = Lw_Event_Take(eventSet, LW_OPTION_EVENT_0 | LW_OPTION_EVENT_1,
			LW_OPTION_EVENTSET_WAIT_SET_ALL | LW_OPTION_EVENTSET_RESET,
			LW_OPTION_WAIT_INFINITE);
	if(ret != 0)
	{
		perror("fun Lw_Event_Take error\n");
		return (PVOID)-1;
	}
	printf("LW_OPTION_EVENT_0 and LW_OPTION_EVENT_1 all 1\n");

	// ……

	return LW_NULL;
}

```



## Lw_Event_WaitEx ：限时等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_WaitEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
	ULONG					*pulEvent
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件。
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- pulEvent ：接收到的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;

	ret = Lw_Event_WaitEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_SET_ANY | LW_OPTION_EVENTSET_RESET, LW_OPTION_WAIT_INFINITE, &ulevent);
	if(ret != 0)
	{
		perror("fun Lw_Event_WaitEx error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_GetEx ：限时等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_GetEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
	ULONG					*pulEvent
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件。
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- pulEvent ：接收到的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;

	ret = Lw_Event_GetEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_SET_ANY | LW_OPTION_EVENTSET_RESET, 
			LW_OPTION_WAIT_INFINITE, &ulevent);
	if(ret != 0)
	{
		perror("fun Lw_Event_GetEx error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_TakeEx ：限时等待事件集中的相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_TakeEx
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption, 
	ULONG					ulTimeout
	ULONG					*pulEvent
);

```



### 描述：

该接口用来限时等待事件集中相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：等待事件。
- ulOption ：等待方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_WAIT_CLR_ALL|指定事件都为0时激活|
|LW_OPTION_EVENTSET_WAIT_CLR_ANY|指定事件中任何一位为0时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ALL|指定事件都为1时激活|
|LW_OPTION_EVENTSET_WAIT_SET_ANY|指定事件中任何一位为1时激活|
|LW_OPTION_EVENTSET_RETURN_ALL|获得事件后返回所有有效的事件|
|LW_OPTION_EVENTSET_RESET|获得事件后自动清除事件|
|LW_OPTION_EVENTSET_RESET_ALL|获得事件后清除所有事件|

- ulTimeout ：等待时间。

|属性对象|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- pulEvent ：接收到的事件。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_WAIT_TYPE ：事件等待方法错误。
- EINTR ：中断系统调用。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- ERROR_EVENTSET_WAS_DELETED ：事件集已经被删除。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent;

	ret = Lw_Event_TakeEx(eventSet, LW_OPTION_EVENT_ALL,
			LW_OPTION_EVENTSET_WAIT_SET_ANY | LW_OPTION_EVENTSET_RESET, 
			LW_OPTION_WAIT_INFINITE, &ulevent);
	if(ret != 0)
	{
		perror("fun Lw_Event_TakeEx error\n");
	}

	// ……
	return LW_NULL;
}

```



## Lw_Event_Send ：释放事件集中相关事件


### 函数原型：

```C
ULONG  Lw_ Event_Send
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```



### 描述：

该接口用来释放事件集相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：释放事件。
- ulOption ：释放方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_SET|将指定事件设为 1|
|LW_OPTION_EVENTSET_CLR|将指定事件设为 0|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_OPTION ：事件选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

// ……

PVOID Thread2(PVOID arg)
{
	int i = 0;
	ULONG ret = 0 ;
	while(i<32)
	{
		i++;
		ret = Lw_Event_Send(eventSet, 1 << i, LW_OPTION_EVENTSET_SET);
		if(ret != 0)
		{
			perror("fun Lw_Event_Send error\n");
			return (PVOID)-1;
		}
		sleep(1);		
	}
	// ……

	return LW_NULL;
}

```



## Lw_Event_Post ：释放事件集中相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_Post
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```



### 描述：

该接口用来释放事件集相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：释放事件。
- ulOption ：释放方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_SET|将指定事件设为 1|
|LW_OPTION_EVENTSET_CLR|将指定事件设为 0|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_OPTION ：事件选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

// ……

PVOID Thread2(PVOID arg)
{
	int i = 0;
	ULONG ret = 0 ;
	while(i<32)
	{
		i++;
		ret = Lw_Event_Post(eventSet, 1 << i, LW_OPTION_EVENTSET_SET);
		if(ret != 0)
		{
			perror("fun Lw_Event_Post error\n");
			return (PVOID)-1;
		}
		sleep(1);	
	}
	// ……

	return LW_NULL;
}

```



## Lw_Event_Give ：释放事件集中相关事件 


### 函数原型：

```C
ULONG  Lw_ Event_Give
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					ulEvent,
	ULONG					ulOption
);

```



### 描述：

该接口用来释放事件集相关事件。

### 参数：

- pulId ：事件句柄。
- ulEvent ：释放事件。
- ulOption ：释放方法选项。

|属性对象|说明|
|---|---|
|LW_OPTION_EVENTSET_SET|将指定事件设为1|
|LW_OPTION_EVENTSET_CLR|将指定事件设为0|

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。
- ERROR_EVENTSET_OPTION ：事件选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>

// ……

PVOID Thread2(PVOID arg)
{
	int i = 0;
	ULONG ret = 0 ;
	while(i<32)
	{
		i++;
		ret = Lw_Event_Give(eventSet, 1 << i, LW_OPTION_EVENTSET_SET);
		if(ret != 0)
		{
			perror("fun Lw_Event_Give error\n");
			return (PVOID)-1;
		}
		sleep(1);		
	}
	// …….

	return LW_NULL;
}

```



## Lw_Event_Status ：查询指定事件集信息


### 函数原型：

```C
ULONG  Lw_ Event_Status
{
	LW_OBJECT_HANDLE	ulId,
	ULONG				* ulEvent,
	ULONG				*ulOption
);

```



### 描述：

该接口用来获取事件集状态。

### 参数：

- pulId ：事件句柄。
- ulEvent ：事件集当前事件。
- ulOption ：选项。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

// ……

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent, option;

	ret = Lw_Event_Status(eventSet, &ulevent, &option);
	if(ret == 0)
	{
		printf("eventSet ulevent :%lu\n", ulevent);
		printf("eventSet option	:%lu\n", option);
	}

	// ……

return LW_NULL;
}

```



## Lw_Event_Info ： 查询指定事件集的信息 


### 函数原型：

```C
ULONG  Lw_ Event_Status
{
	LW_OBJECT_HANDLE	ulId,
	ULONG					* ulEvent,
	ULONG					*ulOption
);

```



### 描述：

该接口用来获取事件集状态。

### 参数：

- pulId ：事件句柄。
- ulEvent ：事件集当前事件。
- ulOption ：选项。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR \_EVENTSET_TYPE ：事件集类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread2(PVOID arg)
{
	ULONG  ret = 0;
	ULONG  ulevent, option;

	ret = Lw_Event_Info(eventSet, &ulevent, &option);
	if(ret == 0)
	{
		printf("eventSet ulevent :%lu\n", ulevent);
		printf("eventSet option	:%lu\n", option);
	}

	// ……

	return LW_NULL;
}

```



## Lw_Event_GetName ：获取事件集的名字


### 函数原型：

```C
ULONG  Lw_Event_GetName
(
	LW_OBJECT_HANDLE	ulId, 
	PCHAR					pcName
);

```



### 描述：

该接口用来获取事件集的名字。

### 参数：

- pulId ：事件句柄。
- pcName ：存放事件集名字的指针。

### 返回值：

成功返回0，失败返回相应到的错误码。

### 错误码： 

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件类型出错。

### 样例： 

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread1(PVOID arg)
{
	ULONG ret = 0;
	char name[32];

	memset(name, 0 , sizeof(name));
	ret = Lw_Event_GetName(eventSet, name);
	if(ret == 0)
	{
		printf("eventSet name :%s\n", name);
	}
	
	return LW_NULL;
}

```



## Lw_EventSet_Show ：显示指定事件集信息


### 函数原型：

```C
VOID	Lw_EventSet_Show
(
	LW_OBJECT_HANDLE	ulId
);

```



### 描述：

该接口用来显示指定事件集的相关信息，不可在中断中使用。

### 参数： 

- ulId ：事件集句柄。

### 返回值：

无。

### 错误码： 

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE eventSet;

PVOID Thread1(PVOID arg)
{
	Lw_EventSet_Show(eventSet);

	// ……
}

```



# 消息队列


## LW_MsgQueue_Create：建立一个消息队列


### 函数原型：

```C
LW_OBJECT_HANDLE  Lw_ MsgQueue_Create 
(
	CPCHAR              pcName, 
	ULONG               ulMaxMsgCounter,
	size_t             	stMaxMsgByteSize,
	ULONG               ulOption,
	LW_OBJECT_ID        *pulId
);

```



### 描述：

该接口用来建立一个消息队列。

### 参数：

- pcName ：事件名缓冲区。
- ulMaxMsgCounter ：最大消息数量
- stMaxMsgByteSize ：每条消息最大长度
- ulOption ：事件选项，取值有：

|ulOption|说明|
|---|---|
|LW_OPTION_WAIT_PRIORITY|按优先级顺序等待|
|LW_OPTION_WAIT_FIFO|按先入先出顺序等待|
|LW_OPTION_OBJECT_GLOBAL|全局对象（内核模块中使用）|
|LW_OPTION_OBJECT_LOCAL|本地对象|

- pulId ：事件ID指针。

### 返回值：

成功返回创建的信号量的句柄，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_MSGQUEUE_MAX_COUNTER_NULL ：消息数量错误。
- ERROR_MSGQUEUE_MAX_LEN_NULL ：最长长度空。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_MSGQUEUE_FULL ：消息队列满。
- ERROR_KERNEL_LOW_MEMORY ：缺少内存。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>

LW_OBJECT_HANDLE queue;

int main (int argc, char **argv)
{	
	// ……

	/*
	*创建一个消息队列
    */
	queue= Lw_MsgQueue_Create("msgqueue1", 20, 1024, 
					 LW_OPTION_WAIT_PRIORITY, LW_NULL);
	if(queue == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_MsgQueue_Create error\n");
		return PX_ERROR;
	}

	// ……

    return  (0);
}


```

## LW_MsgQueue_Delete：删除指定的消息队列


### 函数原型：

```C
ULONG  Lw_ MsgQueue_Delete
(
	LW_OBJECT_HANDLE  *pulId
);

```


### 描述：

该接口用来删除指定消息队列。

### 参数：

- pulId ：事件ID指针

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>

LW_OBJECT_HANDLE queue;

int main (int argc, char **argv)
{	
	// ……

	/*
	* 创建一个消息队列
    */
	queue= Lw_MsgQueue_Create("msgqueue1", 20, 1024, 
					 LW_OPTION_WAIT_PRIORITY, LW_NULL);
	if(queue == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_MsgQueue_Create error\n");
		return PX_ERROR;
	}

	// ……

	Lw_MsgQueue_Delete(&queue);            /*  删除消息队列        */
    return  (0);
}

```



## LW_MsgQueue_Receive：限时接收消息


### 函数原型：

```C
ULONG  Lw_MsgQueue_Receive 
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t                stMaxByteSize,
	size_t               * pstMsgLen,
	ULONG               ulTimeout
);

```



### 描述：

该接口用来限时从消息队列接受消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMaxByteSize ：消息缓冲区大小。
- pstMsgLen ：消息长度。
- ulTimeout ：等待时间。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;
	char MsgBuffer[1024];
	size_t msglen = 0;

    // ……
	memset(MsgBuffer, 0, sizeof(MsgBuffer));
	/*
	* 限时接收消息
	*/
	ret = Lw_MsgQueue_Receive(queue, MsgBuffer,
			sizeof(MsgBuffer), &msglen, LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_Receive error\n");
		return (PVOID)-1;
	}
	MsgBuffer[msglen] = '\0';
	printf("receive data :%s\n", MsgBuffer);

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_ReceiveEx：带选项的限时接收消息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ReceiveEx
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t                stMaxByteSize,
	size_t               *pstMsgLen,
	ULONG               ulTimeout,
	ULONG               ulOption
);

```



### 描述：

该接口用来限时等待消息队列获取消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMaxByteSize ：消息缓冲区大小。
- pstMsgLen ：消息长度。
- ulTimeout ：等待时间。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- ulOption：接收选项：LW_OPTION_NOERROR大于缓冲区的消息自动截断（默认为此选项）。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- E2BIG ：参数列表过长
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;
	char MsgBuffer[1024];
	size_t msglen = 0;

	// ……

	memset(MsgBuffer, 0, sizeof(MsgBuffer));
	/*
	* 带选项的限时接收
	*/
	ret = Lw_MsgQueue_ReceiveEx(queue, Buffer, sizeof(Buffer),
			&msglen, LW_OPTION_WAIT_A_SECOND, LW_OPTION_NOERROR);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_ReceiveEx error\n");
		return (PVOID)-1;
	}
	MsgBuffer[msglen] = '\0';
	printf("receive data :%s\n", MsgBuffer);

	// ……

	return LW_NULL;
}

```
## LW_MsgQueue_TryReceive：尝试获得消息队列消息

### 函数原型：

```C
ULONG  Lw_MsgQueue_ TryReceive
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t                stMaxByteSize,
	size_t               * pstMsgLen
);

```



### 描述：

该接口用来无等待获取消息队列消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMaxByteSize ：消息缓冲区大小。
- pstMsgLen ：消息长度。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;
	char MsgBuffer[1024];
	size_t msglen = 0;

    // ……
	memset(MsgBuffer, 0, sizeof(MsgBuffer));
	/*
	* 尝试接受消息队列消息
	*/
	ret = Lw_MsgQueue_TryReceive(queue, Buffer, sizeof(Buffer), &msglen);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_TryReceive error\n");
		return (PVOID)-1;
	}
	MsgBuffer[msglen] = '\0';
	printf("receive data :%s\n", MsgBuffer);

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Send：向消息队列发送消息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Send
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t             	stMsgLen
);

```



### 描述：

该接口用来向消息队列无等待发送消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMsgLen ：消息长度。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_MSGQUEUE_MSG_LEN ：消息长度出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_MSGQUEUE_FULL ：消息队列满。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;
	char *str = "SylixOS ease of use system!";

	// ……

	ret = Lw_MsgQueue_Send(queue, str, strlen(str));        /*  发送消息  */
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_Send error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Send2：限时发送消息给指定的消息队列


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Send2
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t             	stMsgLen,
	ULONG               ulTimeout
);

```


### 描述：

该接口用来向消息队列限时发送消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMsgLen ：消息长度。
- ulTimeout ：超时时间。

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_MSGQUEUE_MSG_LEN ：消息长度出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_MSGQUEUE_FULL ：消息队列满。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread 2(PVOID arg)
{
	ULONG ret;
	char *str = "SylixOS ease of use system!";

	// ……
	/*
	*  限时发送消息
	*/
	ret=Lw_MsgQueue_Send2(queue,str,strlen(str), LW_OPTION_WAIT_A_SECOND);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_Send2 error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```


## LW_MsgQueue_SendEx：带选项的发送消息


### 函数原型：

```c
ULONG Lw_MsgQueue_ SendEx 
( 
	LW_OBJECT_HANDLE ulId, 
	PVOID pvMsgBuffer, 
	size_t stMsgLen, 
	ULONG ulOption 
);
```

### 描述：

该接口用来向消息队列无等待发送消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMsgLen ：消息长度。
- ulOption ：消息选项。取值：

|ulOption|说明|
|---|---|
|LW_OPTION_DEFAULT|默认选项|
|LW_OPTION_URGENT|消息队列紧急消息发送。|
|LW_OPTION_BROADCAST|消息队列广播发送|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_MSGQUEUE_MSG_LEN ：消息长度出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_MSGQUEUE_FULL ：消息队列满。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。
- ERROR_MSGQUEUE_OPTION ：OPTION 选项错。

### 样例：

```C
ULONG  Lw_MsgQueue_ SendEx
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t             	stMsgLen,
	ULONG               ulOption
);

```


## LW_MsgQueue_SendEx2：带选项的限时发送消息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ SendEx
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t             	stMsgLen,
	ULONG               ulOption
);

```



### 描述：

该接口用来向消息队列限时发送消息。

### 参数：

- ulId ：消息队列句柄。
- pvMsgBuffer ：消息缓冲区。
- stMsgLen ：消息长度。
- ulTimeout ：超时时间

|ulTimeout|说明|
|---|---|
|LW_OPTION_NOT_WAIT|不进行等待|
|LW_OPTION_WAIT_A_TICK|等待一个系统时钟|
|LW_OPTION_WAIT_A_SECOND|等待一秒|
|LW_OPTION_WAIT_INFINITE|永远等待，直到发生为止|

- ulOption ：消息选项

|ulOption|说明|
|---|---|
|LW_OPTION_DEFAULT|默认选项|
|LW_OPTION_URGENT|消息队列紧急消息发送。|
|LW_OPTION_BROADCAST|消息队列广播发送|

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_MSGQUEUE_MSG_NULL ：消息出错。
- ERROR_MSGQUEUE_MSG_LEN ：消息长度出错。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。
- ERROR_MSGQUEUE_FULL ：消息队列满。
- ERROR_THREAD_WAIT_TIMEOUT ：等待超时。
- EINTR ：中断系统调用。
- ERROR_MSGQUEUE_WAS_DELETED ：队列被删除了。
- ERROR_MSGQUEUE_OPTION ：OPTION 选项错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;
	char *str = "SylixOS ease of use system!";

	// ……
	/*
	*  带选项的发送消息
	*/
	ret = Lw_MsgQueue_SendEx(queue, str, strlen(str), LW_OPTION_URGENT);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_SendEx error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Flush：释放所有等待消息队列的线程


### 函数原型：

```C
ULONG  Lw_MsgQueue_ SendEx2
(
	LW_OBJECT_HANDLE    ulId,
	PVOID                pvMsgBuffer,
	size_t             	stMsgLen,
	ULONG               ulTimeout,
	ULONG               ulOption
);

```



### 描述：

该接口用来将所有等待消息队列的线程就绪。

### 参数：

- ulId ：消息队列句柄。
- pulThreadUnblockNum ：被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;
	char *str = "SylixOS ease of use system!";

	// ……
	/*
	*  带选项的限时发送消息
	*/
	ret = Lw_MsgQueue_SendEx2(queue, str, strlen(str),
			LW_OPTION_WAIT_A_SECOND, LW_OPTION_URGENT);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_SendEx2 error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_FlushReceive：释放等待消息队列接收的线程


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Flush
(
	LW_OBJECT_HANDLE    ulId,
	ULONG  *            pulThreadUnblockNum
);

```



### 描述：

该接口用来将所有等待消息队列接收的线程就绪。

### 参数：

- ulId ：消息队列句柄。
- pulThreadUnblockNum ：被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- RROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;

	// ……

	ret = Lw_MsgQueue_Flush(queue, NULL); /* 释放所有等待消息队列的线程 */
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_Flush error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_FlushSend：释放等待消息队列发送的线程


### 函数原型：

```C
ULONG  Lw_MsgQueue_FlushReceive
(
	LW_OBJECT_HANDLE    ulId,
	ULONG  *             pulThreadUnblockNum
);

```



### 描述：

该接口用来将所有等待消息队列发送的线程就绪。

### 参数：

- ulId ：消息队列句柄。
- pulThreadUnblockNum ：被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;

	// ……
	/*
	*  释放所有等待消息队列接收的线程
	*/
	ret = Lw_MsgQueue_FlushReceive (queue, NULL);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_FlushReceive error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Clear：清除消息队列中的消息


### 函数原型：

```C
ULONG  Lw_MsgQueue_FlushSend
(
	LW_OBJECT_HANDLE    ulId,
	ULONG  *            pulThreadUnblockNum
);

```



### 描述：

该接口用来清除消息队列中的消息。

### 参数：

- ulId ：消息队列句柄。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;

	// ……
	/*
	*  释放所有等待消息队列发送的线程
	*/
	ret = Lw_MsgQueue_FlushSend(queue, NULL);
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_FlushSend error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Status：查询消息队列的信息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Clear
(
	LW_OBJECT_HANDLE    ulId,
);

```



### 描述：

该接口用来查询消息队列的信息。

### 参数：

- ulId ：消息队列句柄。
- pulMaxMsgNum ：消息队列消息总数量。
- pulCounter ：消息队列消息数量。
- pstMsgLen ：消息队列最近一条消息大小。
- pulOption ：消息队列选项指针。
- pulThreadBlockNum ：被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	ULONG ret;

	// ……

	ret = Lw_MsgQueue_Clear (queue);       /*  清除消息队列中的消息   */
	if(ret != 0)
	{
		perror("fun Lw_MsgQueue_Clear error\n");
		return (PVOID)-1;
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Info：查询消息队列的信息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Status
(	
	LW_OBJECT_HANDLE   ulId, 
	ULONG             *pulMaxMsgNum,
	ULONG             *pulCounter,
	size_t              *pstMsgLen,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
);

```



### 描述：

该接口用来查询消息队列的信息。

### 参数：

- ulId ：消息队列句柄。
- pulMaxMsgNum ：消息队列消息总数量。
- pulCounter ：消息队列消息数量。
- pstMsgLen ：消息队列最近一条消息大小。
- pulOption ：消息队列选项指针。
- pulThreadBlockNum ：被解锁的线程数量。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;
	size_t            msgLen;
	ULONG     maxMsgNum, counter, option, blockNum;

	// ……

	ret = Lw_MsgQueue_Status(queue, &maxMsgNum,&counter,
&msgLen, &option, &blockNum);    /* 查询消息队列的信息  */
	if(ret == 0)
	{
		printf("queue maxMsgNum :%lu\n", maxMsgNum);
		printf("queue counter :%lu\n", counter);
		printf("queue msgLen :%u\n", msgLen);
		printf("queue option :%lu\n", option);
		printf("queue blockNum :%lu\n", blockNum);
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_StatusEx：查询消息队列的信息


### 函数原型：

```C
ULONG  Lw_MsgQueue_ Info                                                                                                                                                                                                                                                                                                                                                                                       
(	
	LW_OBJECT_HANDLE   ulId, 
	ULONG             *pulMaxMsgNum,
	ULONG             *pulCounter,
	size_t              *pstMsgLen,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum
)

```



### 描述：

该接口用来查询消息队列的信息。

### 参数：

- ulId ：消息队列句柄。
- pulMaxMsgNum ：消息队列消息总数量。
- pulCounter ：消息队列消息数量。
- pstMsgLen ：消息队列最近一条消息大小。
- pulOption ：消息队列选项指针。
- pulThreadBlockNum ：被解锁的线程数量。
- pstMaxMsgLen ：消息队列消息的最大长度。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;

PVOID Thread2(PVOID arg)
{
	ULONG ret;
	size_t            msgLen;
	ULONG     maxMsgNum, counter, option, blockNum;

	// ……

	ret = Lw_MsgQueue_Info(queue, &maxMsgNum,&counter, 
&msgLen, &option, &blockNum);    /*  查询消息队列的信息 */
	if(ret == 0)
	{
		printf("queue maxMsgNum :%lu\n", maxMsgNum);
		printf("queue counter :%lu\n", counter);
		printf("queue msgLen :%u\n", msgLen);
		printf("queue option :%lu\n", option);
		printf("queue blockNum :%lu\n", blockNum);
	}

	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_InfoEx：查询消息队列的信息


### 函数原型：

```C
ULONG  Lw_MsgQueue_StatusEx
(	
	LW_OBJECT_HANDLE   ulId, 
	ULONG             *pulMaxMsgNum,
	ULONG             *pulCounter,
	size_t              *pstMsgLen,
	ULONG             *pulOption,
	ULONG             *pulThreadBlockNum,
	size_t              *pstMaxMsgLen
);

```



### 描述：

该接口用来查询消息队列的信息。

### 参数：

- ulId ：消息队列句柄。
- pulMaxMsgNum ：消息队列消息总数量。
- pulCounter ：消息队列消息数量。
- pstMsgLen ：消息队列最近一条消息大小。
- pulOption ：消息队列选项指针。
- pulThreadBlockNum ：被解锁的线程数量。
- pstMaxMsgLen ：消息队列消息的最大长度。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret;
	size_t      msgLen, maxMsgLen;
	ULONG     maxMsgNum, counter, option, blockNum;

	// ……

	ret = Lw_MsgQueue_StatusEx(queue, &maxMsgNum, &counter, &msgLen, 
&option, &blockNum, &maxMsgLen);    /* 查询消息队列的信息 */
	if(ret == 0)
	{
		printf("queue maxMsgNum :%lu\n", maxMsgNum);
		printf("queue counter :%lu\n", counter);
		printf("queue msgLen :%u\n", msgLen);
		printf("queue option :%lu\n", option);
		printf("queue blockNum :%lu\n", blockNum);
		printf("queue maxMsgLen :%u\n", maxMsgLen);
	}
	// ……

	return LW_NULL;
}

```


LW_MsgQueue_GetName：获取消息队列的名字


### 函数原型：

```C
ULONG  Lw_ MsgQueue_GetName
(
	LW_OBJECT_HANDLE  ulId, 
	PCHAR  pcName
);

```



### 描述：

该接口用来获取消息队列的名字。

### 参数：

- pulId ：消息队列句柄
- pcName ：名字缓冲区

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR\_ MSGQUEUE_TYPE ：消息类型出错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread2(PVOID arg)
{
	ULONG ret; 
	char name[32];

	// ……

	memset(name, 0, strlen(name));
	ret = Lw_MsgQueue_GetName(queue, name);   /* 获取消息队列的名字  */
	if(ret == 0)
	{
		printf("queue name: %s\n", name);
	}
	
	// ……

	return LW_NULL;
}

```



## LW_MsgQueue_Show：显示指定消息队列的信息


### 函数原型：

```C
VOID    Lw_MsgQueue_Show
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示指定消息队列的信息，不可在中断中使用。

### 参数：

- pulId ：消息队列句柄。

### 返回值：

无

### 错误码：

无

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h>
static LW_OBJECT_HANDLE queue;
PVOID Thread1(PVOID arg)
{
	// ……

	Lw_MsgQueue_Show(queue);            /* 显示消息队列的信息     */

	// ……

	return LW_NULL;
}

```



# 时间


## Lw_Time\_ Sleep：使当前线程睡眠


### 函数原型：

```C
VOID  Lw_Time_Sleep
(
	ULONG    ulTick
);

```



### 描述：

该接口用来使当前线程睡眠，且不会被信号唤醒。

### 参数：

- ulTick ：睡眠的时间。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_Sleep(100);
	// ……
	return (0);
}

```



## Lw_Time\_ SleepEx：使当前线程睡眠


### 函数原型：

```C
ULONG  Lw_Time_SleepEx
(
	ULONG 	ulTick , 
	BOOL 	bSigRet
);

```


### 描述：

该接口用来使当前线程睡眠，且可以指定是否可以被信号唤醒。

### 参数：

- ulTick ：睡眠的时间。
- bSigRet ：是否允许信号唤醒。1允许被信号唤醒，0不允许。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- EINTR ：被信号激活。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_SleepEx(100, 1);
	// ……
	return (0);
}

```



## Lw_Time\_ SleepUntil：使当前线程睡眠指定时间


### 函数原型：

```C
ULONG  Lw_Time_ SleepUntil
(
	clockid_t  clockid, 
	const struct timespec  *tv, 
	BOOL  bSigRet
);

```



### 描述：

该接口用来使当前线程睡眠直到一个指定的时间(与当前时钟差值不得超过ULONG_MAX个tick)，且可以指定是否可以被信号唤醒。

### 参数：

- clockid ：时钟类型。取值有：

|宏定义|解释|
|---|---|
|CLOCK_REALTIME|实时时钟源（设置时间会影响）|
|CLOCK_MONOTONIC|单调时钟源（设置时间不会影响）|

- tv ：指定的时间。
- bSigRet ：是否允许信号唤醒。1允许被信号唤醒，0不允许。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- EINVAL ：无效参数。
- EINTR ：被信号激活。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	int ret ;
	struct timespec tv;
	// ……
	tv.tv_sec = 1;
	tv.tv_nsec = 10;
	ret = Lw_Time_SleepUntil(CLOCK_REALTIME, &tv, 1);
	if(ret != 0)
	{
	perror("fun Lw_Time_SleepUntil error");
	}
	// ……
	return (0);
}

```



## Lw_Time\_ SSleep：使线程睡眠指定秒数


### 函数原型：

```C
VOID  Lw_Time_SSleep
(
	ULONG    ulTick
);

```



### 描述：

该接口用来使当前线程睡眠指定的秒数(精度为TICK HZ)，且不会被信号唤醒。

### 参数：

- ulTick ：睡眠的时间（秒）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_SSleep(1);
	// ……
	return (0);
}

```



## Lw_Time\_ SDelay：使线程睡眠指定秒数


### 函数原型：

```C
VOID  Lw_Time_ SDelay
(
	ULONG    ulTick
);

```



### 描述：

该接口用来使当前线程睡眠指定的秒数(精度为TICK HZ)，且不会被信号唤醒。

### 参数：

- ulTick ：睡眠的时间（秒）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_SDelay(1);
	// ……
	return (0);
}

```



## Lw_Time_MSleep：使线程睡眠指定的毫秒数


### 函数原型：

```C
VOID  Lw_Time_ MSleep
(
	ULONG    ulTick
)

```



### 描述：

该接口用来使当前线程睡眠指定的毫秒数(精度为 TICK HZ)，且不会被信号唤醒。

### 参数：

- ulMSeconds ：睡眠的时间（毫秒）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_MSleep(1000);
	// ……
	return (0);
}

```



## Lw_Time_MDelay：使线程睡眠指定的毫秒数


### 函数原型：

```C
VOID  Lw_Time_MDelay
(
	ULONG    ulMSeconds
);

```



### 描述：

该接口用来使当前线程睡眠指定的毫秒数(精度为 TICK HZ)，且不会被信号唤醒。

### 参数：

- ulMSeconds ：睡眠的时间（毫秒）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_MDelay(1000);
	// ……
	return (0);
}

```



## Lw_Time_Set：设置系统时间


### 函数原型：

```C
VOID  Lw_Time_ Set
(
	ULONG    ulKernenlTime
);

```



### 描述：

该接口用来设置系统时间。未实现此接口功能，无法使用

### 参数：

- ulKernenlTime ：系统时间。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_RUNNING ：系统正在运行。

### 备注

未实现此接口功能，无法使用。

### 样例：

```C
无
```



## Lw_Time_Get：获取系统时间节拍


### 函数原型：

```C
ULONG    Lw_Time_ Get
(
	VOID 
);

```


### 描述：

该接口用来获取系统时间节拍。

### 参数：

无。

### 返回值：

返回系统当前的时钟节拍计数。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	ULONG tick;
	// ……
	tick = Lw_Time_Get();
	printf("System tick :%lu", tick);
	// ……
	return (0);
}

```



## Lw_Time_Get64：获取系统时间节拍


### 函数原型：

```C
ULONG    Lw_Time_ Get
(
	VOID 
);

```
|


### 描述：

该接口用来获取系统时间节拍（64位）。

### 参数：

无。

### 返回值：

返回为一个64位的系统当前的时钟节拍计数。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	INT64 tick;
	// ……
	tick = Lw_Time_Get64();
	printf("System tick :%lld", tick);
	// ……
	return (0);
}

```



## Lw_Time_GetFrequency：获取系统时钟频率


### 函数原型：

```C
ULONG    Lw_Time_ GetFr equency
(
	VOID 
);

```



### 描述：

该接口用来获取系统时钟频率。

### 参数：

无。

### 返回值：

返回系统时钟节拍频率，即每秒产生多少次时钟节拍。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	ULONG tick;
	// ……
	tick = Lw_Time_Get();
	printf("System tick :%lu", tick);
	// ……
	return (0);
}

```



## Lw_Time_TodAdj：微调TOD时间


### 函数原型：

```C
VOID	  Lw_Time_TodAdj
(
	INT32  *piDelta, 
	INT32 *piOldDelta
);

```



### 描述：

该接口用来微调TOD时间。

### 参数：

- piDelta ：TOD调整时间

正数表示时间加速多少个对应的ticks
负数表示时间减速多少个对应的ticks

（如想让TOD时间加速一秒,而且时钟hz为100,则此参数为100；想让TOD时间减速一秒,而且时钟hz为100,则此参数为-100）

- piOldDelta ：上次没有调整完的剩余调整值。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	int delta , olddelta;
	delta = 100;
	// ……
	Lw_Time_TodAdj(&delta, LW_NULL); 
	// ……
	return (0);
}

```



## Lw_Time_Show：显示操作系统时间信息


### 函数原型：

```C
VOID    Lw_Time_Show
(
	VOID
);

```



### 描述：

该接口用来打印操作系统时间信息，不可在中断中使用。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Time_Show(0, 0);
	// ……
	return (0);
}

```



## LW_MSECOND_TO_TICK_0：毫秒转换为时钟节拍数


### 函数原型：

```C
ULONG  LW_MSECOND_TO_TICK_0
{
	ULONG  ulMs
};

```



### 描述：

接口LW_MSECOND_TO_TICK_0将毫秒转换为时钟节拍数，不足一个时钟节拍的毫秒值被丢弃。

### 参数：

- ulMs：毫秒值。

### 返回值：

时钟节拍数。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	LW_MSECOND_TO_TICK_0 (1000);
	// ……
	return (0);
}

```



## LW_MSECOND_TO_TICK_1：毫秒转换为时钟节拍数


### 函数原型：

```C
ULONG  LW_MSECOND_TO_TICK_1
{
	ULONG  ulMs
};

```



### 描述：

该接口LW_MSECOND_TO_TICK_1将毫秒转换为时钟节拍数，不足一个时钟节拍的毫秒值当作一个时钟节拍处理。

### 参数：

- ulMs：毫秒值。

### 返回值：

时钟节拍数。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	LW_MSECOND_TO_TICK_1(1000);
	// ……
	return (0);
}

```



## Lw_Rtc_Set ：设置RTC时钟源


### 函数原型：

```C
INT    Lw_Rtc_Set
(
	time_t  time
);

```



### 描述：

该接口用来设置硬件RTC；设备时间：UTC时间。

### 参数：

- time：时间。

### 返回值：

成功返回ERROR_NONE，失败返回-1并设置错误号。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	time_t t
	// ……
	Lw_Rtc_Set(t);
	// ……
	return (0);
}

```



## Lw_Rtc_Get：获取RTC时钟源


### 函数原型：

```C
INT    Lw_Rtc_Get
(
	time_t  *ptime
);

```



### 描述：

该接口用来获取硬件 RTC；设备时间：UTC时间。

### 参数：

- ptime：时间。

### 返回值：

成功返回ERROR_NONE，失败返回-1并设置错误号。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	time_t t
	// ……
	Lw_Rtc_Set(t);
	// ……
	return (0);
}

```



## Lw_Rtc_SysToRtc：将系统时间同步到RTC时间


### 函数原型：

```C
INT    Lw_Rtc_SysToRtc
(
	VOID
);

```



### 描述：

此函数将系统时间同步到RTC时间，成功返回ERROR_NONE，失败返回-1并设置错误号。

### 参数：

无。

### 返回值：

成功返回ERROR_NONE，失败返回-1并设置错误号。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Rtc_SysToRtc ;
	// ……
	return (0);
}

```


## Lw_Rtc_RtcToSys：将RTC时间同步到系统时间


### 函数原型：

```C
INT    Lw_Rtc_RtcToSys
(
	VOID
);

```



### 描述：

此函数将RTC时间同步到系统时间，成功返回ERROR_NONE，失败返回-1并设置错误号。

### 参数：

无。

### 返回值：

成功返回ERROR_NONE，失败返回-1并设置错误号。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Rtc_RtcToSys;
	// ……
	return (0);
}

```


## Lw_Rtc_RtcToRoot：将RTC时间同步到根文件系统时间 


### 函数原型：

```C
INT    Lw_Rtc_RtcToRoot
(
	VOID
);

```


### 描述：

此函数将RTC时间同步到根文件系统时间，成功返回ERROR_NONE，失败返回-1并设置错误号。

### 参数：

无。

### 返回值：

成功返回ERROR_NONE，失败返回-1并设置错误号。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
	// ……
	Lw_Rtc_RtcToRoot;
	// ……
	return (0);
}

```



## API_TimerCreate：建立一个定时器


### 函数原型：

```C
LW_OBJECT_HANDLE  API_TimerCreate
 (
	CPCHAR   pcName,
	ULONG   ulOption,
	LW_OBJECT_ID   *pulId
)

```


### 描述：

该接口用来建立一个定时器。

### 参数：

- pcName ：定时器的名字；
- ulOption ：创建定时器的选项;
- pulId ：定时器ID指针，与返回值相同，可以为LW_NULL。

|选项名称|解释|
|---|---|
|LW_OPTION_ITIMER|普通定时器|
|LW_OPTION_HTIMER|高精度定时器|

### 返回值：

此函数成功时返回定时器句柄，失败返回LW_HANDLE_INVALID。

### 错误码：

- LW_OBJECT_HANDLE_INVALID ：API返回无效句柄。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}

int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);               /*  启动一个定时器              */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    API_TimerShow (ulTimerId);         /*  显示定时器信息       */

    ret = API_TimerCancel(ulTimerId);     /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);         /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}
}

```



## API_TimerStart：启动一个定时器


### 函数原型：

```C
ULONG  API_TimerStart
(
	LW_OBJECT_HANDLE   ulId,
	ULONG   ulCounter,
	ULONG   ulOption,
	PTIMER_CALLBACK_ROUTINE   cbTimerRoutine,
	PVOID   pvArg
);

```



### 描述：

该接口用来启动一个定时器。

### 参数：

- ulId 定时器句柄
- ulCounter ：计数初始值
- ulOption ：操作选项
- cbTimerRoutine ：回调函数
- pvArg ：参数。

|选项名称|解释|
|---|---|
|LW_OPTION_AUTO_RESTART|定时器自动重载|
|LW_OPTION_MANUAL_RESTART|定时器手动重载|

### 返回值：

成功返回0，失败返回相应错误码。

### 错误码：

- ERROR_TIMER_NULL ：定时器为空;
- ERROR_TIMER_CALLBACK_NULL ：回调为空;
- ERROR_TIMER_TIME ：时间出错;
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}

int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;
    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器              */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    API_TimerShow (ulTimerId);        /*  显示定时器信息       */

    ret = API_TimerCancel(ulTimerId);     /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);   /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerCancel：停止一个定时器


### 函数原型：

```C
ULONG  API_TimerCancel
 (
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来停止一个定时器。

### 参数：

- ulId：定时器句柄。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_TIMER_NULL ：定时器为空;
- ERROR_TIMER_CALLBACK_NULL ：回调为空;
- ERROR_TIMER_TIME ：时间出错;
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}

int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器              */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    API_TimerShow (ulTimerId);        /*  显示定时器信息       */

    ret = API_TimerCancel(ulTimerId);     /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);   /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerDelete：删除一个定时器


### 函数原型：

```C
ULONG  API_TimerDelete
(
	LW_OBJECT_HANDLE  *pulId
);

```



### 描述：

该接口用来删除一个定时器, 当成功删除时，会将该ID设置为无效。

### 参数：

- pulId ：定时器ID指针。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中
- ERROR_KERNEL_HANDLE_NULL ：句柄出错
- ERROR_TIMER_NULL ：定时器为空

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}

int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器              */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    API_TimerShow (ulTimerId);        /*  显示定时器信息       */

    ret = API_TimerCancel(ulTimerId);     /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);   /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerReset：复位一个定时器


### 函数原型：

```C
ULONG  API_TimerReset
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来在定时器运行状态下复位一个定时器。

### 参数：

- ulId ：定时器句柄。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错
- ERROR_TIMER_TIME ：时间出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static LW_HANDLE   G_ulTimerId;
static int  G_ret;


VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
    G_ret = API_TimerReset(G_ulTimerId);                                /*  复位一个定时器   */
       if(G_ret == 0)
       {
           printf("API_TimerReset success!\n");
       }
}

int main (int argc, char *argv[])
{

    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    LW_HANDLE   ulTimerId;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    G_ret = API_TimerStart(G_ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器              */
    if(G_ret != 0)
    {
        printf("API_TimerStart failed\n");
    }

    sleep(4);
    API_TimerShow (G_ulTimerId);        /*  显示定时器信息       */

    G_ret = API_TimerCancel(G_ulTimerId);     /*  停止一个定时器      */
    if(G_ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }

    G_ret = API_TimerDelete(&G_ulTimerId);   /*  删除一个定时器      */
    if(G_ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerStartEx：启动一个定时器扩展接口

### 函数原型：

```C
ULONG  API_TimerStartEx 
(
	LW_OBJECT_HANDLE         ulId,
	ULONG                    ulInitCounter,
	ULONG                    ulCounter,
	ULONG                    ulOption,
	PTIMER_CALLBACK_ROUTINE  cbTimerRoutine,
	PVOID                    pvArg
);

```



### 描述：

启动一个定时器扩展接口。

### 参数：

- ulId ：定时器句柄
- ulInitCounter ：计数初始值
- ulCounter ：重复计数初始值
- ulOption ：操作选项
- cbTimerRoutine ：回调函数
- pvArg ：参数。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_TIMER_CALLBACK_NULL ：回调为空
- ERROR_TIMER_TIME ：时间出错
- ERROR_KERNEL_HANDLE_NULL ：句柄出错
- ERROR_TIMER_NULL ：定时器为空。


### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}

int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;

ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);
  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStartEx(ulTimerId,ulPeriod, 0, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器扩展接口  */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    API_TimerShow (ulTimerId);                      /*  显示定时器信息       */

    ret = API_TimerCancel(ulTimerId);                  /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);                  /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}
```






## API_TimerStatus：获得定时器相关状态


### 函数原型：

```C
ULONG  API_TimerStatus
(
	LW_OBJECT_HANDLE          ulId,
	BOOL                     *pbTimerRunning,
	ULONG                    *pulOption,
	ULONG                    *pulCounter,
	ULONG                    *pulInterval
);

```



### 描述：

该接口用来获得定时器相关状态。

### 参数：

- ulId ：定时器句柄
- pbTimerRunning ：定时器是否在运行
- pulOption ：定时器选项
- pulCounter ：定时器当前计数值
- pulInterval ：间隔时间，为0表示单次运行。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错
- ERROR_TIMER_NULL ：定时器为空。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static    LW_HANDLE   G_ulTimerId;

VOID timerRoutine (PVOID pvArg)
{
    BOOL i=1;
    ULONG  pulOption = LW_OPTION_ITIMER;
    ULONG  pulCounter = 0;
    ULONG  pulInterval = 1;
    int ret;

    ret = API_TimerStatus (G_ulTimerId, &i,&pulOption , &pulCounter,&pulInterval ); /*  获得一个定时器状态     */
    if(ret == 0)
    {
        printf("API_TimerStatus success\n");
    }

}

int main (int argc, char *argv[])
{
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int  ret;
    LW_HANDLE   ulTimerId;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  /*  建立一个定时器              */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }
    ret = API_TimerStart(G_ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);/*  启动一个定时器    */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);

    ret = API_TimerCancel(G_ulTimerId);     /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&G_ulTimerId);   /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerStatusEx：获得定时器相关状态扩展接口


### 函数原型：

```C
ULONG  API_TimerStatusEx
(
	LW_OBJECT_HANDLE         ulId,
	 BOOL                    *pbTimerRunning,
	ULONG                    *pulOption,
	ULONG                    *pulCounter,
	ULONG                    *pulInterval,
	clockid_t                   *pclockid
);

```



### 描述：

该接口用来获得定时器相关状态扩展接口, 仅提供 POSIX 接口内部使用。

### 参数：

- ulId ：定时器句柄
- pbTimerRunning ：定时器是否在运行
- pulOption ：定时器选项
- pulCounter ：定时器当前计数值
- pulInterval ：间隔时间，为0表示单次运行
- pclockid ：POSIX 时间类型。

### 返回值：

成功返回ERROR_NONE，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄出错
- ERROR_TIMER_NULL ：定时器为空。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
static    LW_HANDLE   G_ulTimerId;

VOID timerRoutine (PVOID pvArg)
{
    BOOL i=1;
    ULONG  pulOption = LW_OPTION_ITIMER;
    ULONG  pulCounter = 0;
    ULONG  pulInterval = 1;
    int ret;

    ret = API_TimerStatusEx(G_ulTimerId, &i,&pulOption , &pulCounter,&pulInterval ,LW_NULL);           /*  获得一个定时器状态扩展接口*/
    if(ret == 0)
    {
        printf("API_TimerStatusEx success\n");
    }

}

int main (int argc, char *argv[])
{
    ULONG   ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int   ret;
    LW_HANDLE   ulTimerId;

ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);  
/*  建立一个定时器    */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }
    ret = API_TimerStart(G_ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);                            /*  启动一个定时器    */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);

    ret = API_TimerCancel(G_ulTimerId);                /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&G_ulTimerId);              /*  删除一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



## API_TimerHGetFrequency：获得高速定时器计数频率


### 函数原型：

```C
ULONG  API_TimerHGetFrequency 
(
	VOID
);

```



### 描述：

该接口用来获得高速定时器计数频率。

### 参数：

无。

### 返回值：

高速定时器计数频率。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    ULONG count;
    count = API_TimerHGetFrequency ();              /*  获得高速定时器计数频率  */
    printf("API_TimerHGetFrequency is %lu\n", count);
}

int main (int argc, char *argv[])
{
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    LW_HANDLE   ulTimerId;
    int ret;

ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL); 
 /*  建立一个定时器       */
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }
    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);                                      /*  启动一个定时器       */
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);

    ret = API_TimerCancel(ulTimerId);               /*  停止一个定时器      */
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);              /*  删除一个定时器     */
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");

    return  (0);
}

```



# RMS调度


## Lw_Rms_Create：创建Rms调度器


### 函数原型：

```C
LW_OBJECT_HANDLE	  Lw_Rms_Create
(
	CPCHAR             pcName, 
	ULONG              ulOption,
	LW_OBJECT_ID      *pulId
);

```



### 描述：

该接口用来建立一个精度单调调度器。每创建一个任务需要对应创建一个调度器。

### 参数：

- pcName ：调度器的名字。
- ulOption ：选项。
- pulId ：存放调度器ID号的指针。

### 返回值：

成功返回调度器的句柄，失败返回LW_OBJECT_HANDLE_INVALID，并置错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <SylixOS.h>
LW_OBJECT_HANDLE G_rms1; 
PVOID Thread1 (PVOID arg)
{
    // ……
	return LW_NULL;
}

int main (int argc, char **argv)
{
	LW_HANDLE hId1;

	hId1 = Lw_Thread_Create("t_test", Thread1, LW_NULL, LW_NULL);
	if (hId1 == LW_HANDLE_INVALID)
	{
		perror("fun Lw_Thread_Create error");
		return (PX_ERROR);
	}

	G_rms1 = Lw_Rms_Create("Rms1", 0, NULL);
	if(G_rms1 == LW_OBJECT_HANDLE_INVALID)
    {
        perror("fun Lw_Rms_Create error\n");
        return (PX_ERROR);
    }
    // ……
	Lw_Thread_Join(hId1, NULL);
    // ……
	return 0;
}


```



## Lw_Rms_Delete：删除指定的Rms调度器


### 函数原型：

```C
ULONG	  Lw_Rms_ Delete
(
	LW_OBJECT_HANDLE   *pulId, 
);

```



### 描述：

该接口用来删除指定精度单调调度器。

### 参数：

- pulId ：调度器的ID指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_STATUS ：状态错误。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <SylixOS.h>
LW_OBJECT_HANDLE G_rms1;
int main (int argc, char **argv)
{
	// ……
	G_rms1 = Lw_Rms_Create("Rms1", 0, NULL);
	if(G_rms1 == LW_OBJECT_HANDLE_INVALID)
	{
		perror("fun Lw_Rms_Create error\n");
		return (PX_ERROR);
	}
	// ……
	Lw_Rms_Delete(&G_rms1);
	return 0;
}

```



## Lw_Rms_DeleteEx：删除指定的Rms调度器


### 函数原型：

```C
ULONG	  Lw_Rms_ DeleteEx
(
	LW_OBJECT_HANDLE   *pulId, 
	BOOL  bForce
);

```



### 描述：

该接口用来删除指定精度单调调度器。

### 参数：

- pulId ：调度器的ID指针。
- bForce ：是否强制删除。1表示强制删除。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_STATUS ：状态错误。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
LW_OBJECT_HANDLE G_rms1;
int main (int argc, char **argv)
{
	// ……
    G_rms1 = Lw_Rms_Create("Rms1", 0, NULL);
    if(G_rms1 == LW_OBJECT_HANDLE_INVALID)
    {
        perror("fun Lw_Rms_Create error\n");
        return (PX_ERROR);
    }
	// ……
	ret = Lw_Rms_DeleteEx(&G_rms2,1);
	if(ret != 0)
    {
        perror("Lw_Rms_Delete");
        return -1;
    }
	return 0;
}

```



## Lw_Rms_ExecTimeGet：获取Rms 设置周期到目前的时间


### 函数原型：

```C
ULONG	  Lw_Rms_ExecTimeGet
(
	LW_OBJECT_HANDLE   ulId, 
	ULONG  *pulExecTime
);

```



### 描述：

该接口用来获取当前任务从调用Lw_Rms_Period()函数到目前指向的时间。单位为Tick

### 参数：

- pulId ：调度器的ID指针。
- pulExecTime ：存放运行时间的指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_BUFFER_NULL ：缺少缓冲。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_STATUS ：状态错误。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
LW_OBJECT_HANDLE G_rms1;
PVOID Thread1 (PVOID arg)
{
    ULONG ret = 0;
    ULONG ExecTime;
    while(1)
    {
        ret = Lw_Rms_Period(G_rms1,200);
        if(ret != 0)
        {
            perror("fun Lw_Rms_Period error\n");
            return (PVOID)-1;
        }
        ret = Lw_Rms_ExecTimeGet(G_rms1, &ExecTime);
        if(ret == 0)
        {
            printf("ExecTime :%lu\n", ExecTime);
        }
        printf("test1 run \n");
    }
    return LW_NULL;
}

```



## Lw_Rms_Period：指定Rms工作周期


### 函数原型：

```C
ULONG	  Lw_Rms_Period
(
LW_OBJECT_HANDLE   ulId, 
ULONG   Period
);

```



### 描述：

该接口用来指定精度单调调度器开始按固定周期工作。

使用精度单调调度器，不可以设置系统时间，但是可是设置RTC时间。

### 参数：

- pulId ：调度器的ID指针。
- Period ：程序段执行周期。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_RMS_TICK ：TICK 错误。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
LW_OBJECT_HANDLE G_rms1;
PVOID Thread1 (PVOID arg)
{
    ULONG ret = 0;
    ULONG ExecTime;
    while(1)
    {
        ret = Lw_Rms_Period(G_rms1,200);
        if(ret != 0)
        {
            perror("fun Lw_Rms_Period error\n");
            return (PVOID)-1;
        }
        ret = Lw_Rms_ExecTimeGet(G_rms1, &ExecTime);
        if(ret == 0)
        {
            printf("ExecTime :%lu\n", ExecTime);
        }
        printf("test1 run \n");
    }
    return LW_NULL;
}

```



## Lw_Rms_Cancel：停止指定的Rms调度器


### 函数原型：

```C
ULONG	  Lw_Rms_Cancel
(
	LW_OBJECT_HANDLE   pulId, 
);

```



### 描述：

该接口用来停止指定的精度单调调度器工作。

### 参数：

- pulId ：调度器的ID指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_STATUS ：状态错误。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
LW_OBJECT_HANDLE rms;
PVOID Thread1 (PVOID arg)
{
	ULONG ret = 0;
	
	// ……
	count++;
     if(count > 10)
     {
         ret = Lw_Rms_Cancel(G_rms2);
         if(ret != 0)
         {
             printf("fun Lw_Rms_Cancel error\n");
             return (PVOID)-1;
        }
        break;
    }
    printf("test2 run \n");
	// ……
	return LW_NULL;
}

```



## Lw_Rms_Status：查询指定的Rms信息


### 函数原型：

```C
ULONG	  Lw_Rms_Status
(
	LW_OBJECT_HANDLE   pulId, 
	UINT8            *pucStatus,
	ULONG            *pulTimeLeft,
	LW_OBJECT_HANDLE *pulOwnerId
);

```



### 描述：

该接口用来获取精度单调调度器的状态。

### 参数：

- pulId ：调度器的ID指针。
- pucStatus ：状态缓存区。状态有：

|权限宏定义|解释|
|---|---|
|LW_RMS_INACTIVE|欲打开的文件不存在，则创建。存在不受影响。|
|LW_RMS_ACTIVE|读文件时会从文件尾开始移动。写文件时追加|
|LW_RMS_EXPIRED|文件存在，长度截为0|

- pulTimeLeft ：等待剩余时间。
- pulOwnerId ：所有者ID。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
LW_OBJECT_HANDLE G_rms1;
PVOID Thread1 (PVOID arg)
{
	ULONG ret = 0;
	UINT8 status;
	ULONG timeLeft;
	LW_OBJECT_HANDLE ownerId;
	// ……
	ret = Lw_Rms_Status(G_rms1, &status, &timeLeft, &ownerId);
	if(ret == 0)
    {
        printf("G_rms1 status : %d\n", status);
        printf("G_rms1 timeLeft : %lu\n", timeLeft);
        printf("G_rms1 ownerId : %lu\n", ownerId);
    }// ……

}

```


Lw_Rms_Info：查询指定的Rms信息


### 函数原型：

```C
ULONG	  Lw_Rms_Info
(
	LW_OBJECT_HANDLE   pulId, 
	UINT8            *pucStatus,
	ULONG            *pulTimeLeft,
	LW_OBJECT_HANDLE *pulOwnerId
);

```



### 描述：

该接口用来获取精度单调调度器的状态。对应时间单位为系统Ticks

### 参数：

- pulId ：调度器的ID指针。
- pucStatus ：名字缓存区。
- pulTimeLeft ：等待剩余时间。
- pulOwnerId ：所有者ID。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
LW_OBJECT_HANDLE G_rms2;
PVOID Thread1 (PVOID arg)
{
	ULONG ret = 0;
	UINT8 status;
	ULONG timeLeft;
	LW_OBJECT_HANDLE ownerId;
	// ……
    ret = Lw_Rms_Info(G_rms2, &status, &timeLeft, &ownerId);
    if(ret == 0)
    {
        printf("G_rms2 status : %d\n", status);
        printf("G_rms2 timeLeft : %lu\n", timeLeft);
        printf("G_rms2 ownerId : %lu\n", ownerId);
    }
	// ……
}

```



## Lw_Rms_GetName：获取指定Rms调度器的名字

### 函数原型：

```C
ULONG  Lw_Rms_GetName
(
	LW_OBJECT_HANDLE  ulId, 
	PCHAR  pcName
);

```



### 描述：

该接口用来获取精度单调调度器的名字。

### 参数：

- pulId ：事件句柄。
- pcName ：存放调度器名字的指针。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_RMS_NULL ：控制块错误。

### 样例：

```C
LW_OBJECT_HANDLE G_rms2; 
PVOID Thread2 (PVOID arg)
{
    char  name[128];
    int   ret;
    ULONG ExecTime;
    while(1)
    {

        ret = Lw_Rms_Period(G_rms2, 20);
         if(ret != 0)
         {
            perror("fun Lw_Rms_Period error\n");
            return (PVOID)-1;
         }

         ret = Lw_Rms_ExecTimeGet(G_rms2,&ExecTime);
         if(ret == 0)
         {
            printf("ExecTime :%lu\n", ExecTime);
         }

         memset(name,0,sizeof(name));

         ret = Lw_Rms_GetName(G_rms2, name);
         if(ret == 0)
         {
            printf("G_rms2 name :%s\n", name);
         }
		// ……
         printf("test2 run \n");

    }

    return NULL;
}


```


## Lw_Rms_Show：显示指定Rms信息


### 函数原型：

```C
VOID    Lw_Rms_Show
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示操作系统精度单调调度器信息，不可在中断中使用。

### 参数：

- ulId 精度单调调度器句柄。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
LW_OBJECT_HANDLE G_rms1;
PVOID Thread1 (PVOID arg)
{
	// ……
	Lw_Rms_Show(G_rms1);
	// ……
	return LW_NULL;
}

```



## sched_rms_destroy：销毁RMS调度器


### 函数原型：

```C
int  sched_rms_destroy 
(
	sched_rms_t  
	*prms
)

```


### 描述：

删除 RMS 调度器。

### 参数：

- prms ：指向RMS调度器的指针

### 返回值：

成功返回0，失败返回-1并置错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```C
sched_rms_t prms;
sched_rms_t prms1; 
int main (int argc, char *argv[]) 
{
	// ……
    ret = sched_rms_destroy(&prms);
    if(ret != 0)
    {
        perror("sched_rms_destroy");
        return -1;
    }

    ret = sched_rms_destroy(&prms1);
    if(ret != 0)
    {
        perror("sched_rms_destroy");
        return -1;
    }
	// ……

	return LW_NULL;
}

```



## sched_rms_period：设置Rms的调度周期


### 函数原型：

```C
int  sched_rms_period 
(
	sched_rms_t  *prms,
	const struct timespec *period
)

```



### 描述：

设置 Rms 的调度周期。

### 参数：

- prms ：指向RMS调度器的指针。
- period ：RMS的周期。

### 返回值：

成功返回0，失败返回-1并置错误码。

### 错误码：

- EINVAL ：参数无效。
- ENOTSUP ：不支持的值。

### 样例：

```C
sched_rms_t prms;
sched_rms_t prms1; 
PVOID Thread2 (PVOID arg)
{
    int   ret;
    struct timespec time;
    // ……
    while(1)
    {
        time.tv_sec = 2;
        time.tv_nsec = 0;
        ret = sched_rms_period(&prms1,&time);
        if(ret != 0)
        {
            perror("fun Lw_Rms_Period error\n");
            return (PVOID)-1;
        }
    	API_TimeShow();
    	// ……
    }
    return NULL;
}

```



# 中断异常


## Lw_Interrupt_Lock：关闭系统中断

```C
ULONG   Lw_Interrupt_Lock
(
	INTREG  *piregInterLevel
);

```



### 描述：

该接口用来关闭系统中断。

### 参数：

- piregInterLevel ：保存中断控制字。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

- ERROR_INTER_LEVEL_NULL ：LOCK入口参数为空。

### 样例：

```C
int main (int argc, char **argv)
{
	ULONG  ret ;
	INTREG level;
    ret = Lw_Interrupt_Lock(&level);
    if(ret != 0)
    {
        perror("fun Lw_Interrupt_Lock error\n");
        return PX_ERROR;
	} 
    // ……
    
    Lw_Interrupt_Unlock(level);

    return  (0);
}

```



## Lw_Interrupt_Unlock：打开系统中断


### 函数原型：

```C
ULONG  Lw_Interrupt_Unlock 
(
	INTREG  iregInterLevel
);

```



### 描述：

该接口用来打开系统中断。

### 参数：

- iregInterLevel ：需要恢复的中断控制字。

### 返回值：

返回0。

### 错误码：

无。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{
	ULONG  ret ;
	INTREG level;

    ret = Lw_Interrupt_Lock(&level);
    if(ret != 0)
    {
    		perror("fun Lw_Interrupt_Lock error\n");
    		return PX_ERROR;
	} 
    // ……
    
    Lw_Interrupt_Unlock(level);

    return  (0);
}

```



## Lw_Interrupt_Context：检测是否处于中断


### 函数原型：

```C
BOOL  Lw_Interrupt_Context
(
	VOID
);

```



### 描述：

该接口用来检查系统是否在中断状态下。

### 参数：

无。

### 返回值：

系统当前处于中断返回1，不处于返回0。

### 错误码：

无。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{
    BOOL isInter = 0;
	// ……
    isInter = Lw_Interrupt_Context();
    if(isInter)    //处于中断
    {
        // ……
    }
    else         //不处于中断
    {
        // ……
    }
    // ……
    return  (0);
}

```



## Lw_Interrupt_GetNesting：查询中断嵌套层数


### 函数原型：

```C
ULONG 		Lw_Interrupt_GetNesting
(
	VOID
);

```



### 描述：

该接口用来获得中断嵌套层数。

### 参数：

无。

### 返回值：

返回中断嵌套层数。

### 错误码：

无。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{
    ULONG  nest = 0;

    nest = Lw_Interrupt_GetNesting();
    printf("interrupt nesting :%lu\n", nest);
    // ……

    return  (0);
}

```



## Lw_Interrupt_GetNestingById：查询指定CPU中断嵌套层数


### 函数原型：

```C
ULONG  Lw_Interrupt_GetNestingById
(
	ULONG  ulCPUId, 
	ULONG *pulMaxNesting
);

```



### 描述：

该接口用来获得指定CPU的中断嵌套层数。

### 参数：

- ulCPUId ：CPUID。
- pulMaxNesting ：存放最大嵌套层数的指针。

### 返回值：

成功返回相应CPU的中断嵌套层数；失败返回0，并置相应的错误码。

### 错误码：

- EINVAL ：参数无效。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{
	ULONG  nest = 0, maxNest;

    // ……

    nest =  Lw_Interrupt_GetNestingById(0, &maxNest);
    if(errno != ERROR_NONE && nest == 0)
    {
    	perror("fun Lw_Interrupt_GetNestingById error");
    }
    else
    {
    		printf("CPU 0 nest :%lu, MaxNest :%lu\n", nest, maxNest);
	}

    // ……

    return  (0);
}

```



## Lw_Interrupt_StackCheck：查询指定CPU中断堆栈使用量


### 函数原型：

```C
VOID   Lw_Interrupt_StackCheck
(
	ULONG   ulCPUId,
	size_t *pstFreeByteSize,
	size_t *pstUsedByteSize
);

```



### 描述：

该接口用来获得指定CPU的中断堆栈使用量。

### 参数：

- ulCPUId ：CPUID。
- pstFreeByteSize ：空闲堆栈大小。
- pstUsedByteSize ：使用堆栈大小。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_CPU_NULL ：指定CPU错误。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{

    while(1)
    {
        sleep(3);
        Lw_Interrupt_Show(0, 0);
    }

    return  (0);
}

```



## Lw_Interrupt_Show：显示指定中断向量表信息


### 函数原型：

```
VOID    Lw_Interrupt_Show
(
	ULONG  ulCPUStart, 
	ULONG  ulCPUEnd
);
```


### 描述：

该接口用来显示中断向量表的所有内容，不可在中断中使用。

### 参数：

- ulCPUStart ：需要显示详细信息的起始CPU号。
- ulCPUEnd ：需要显示详细信息的结束CPU号。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <Sylixos.h>
#include <stdio.h>
#include <unistd.h>
int main (int argc, char **argv)
{

	// ……

	Lw_Interrupt_Show(0, 0);

	// ……

	return  (0);
}

```



# 内核


## Lw_Kernel_Nop：内核空函数


### 函数原型：

```C
VOID  Lw_Kernel_Nop
(
	CPCHAR  pcArg, 
	LONG  lArg
);

```



### 描述：

该接口是内核空函数，未使用。

### 参数：

- pcArg ：任务ID。
- lArg ：错误号。

### 返回值：

成功返回0，失败返回相应的错误码。

### 错误码：

无

### 样例：

无

## Lw_Kernel_Version：查询系统版本


### 函数原型：

```C
ULONG  Lw_Kernel_Version
(
	VOID
);

```



### 描述：

该接口用来获取系统版本。

### 参数：

无。

### 返回值：

返回系统版本。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	ULONG version;
	// ……

	version = Lw_Kernel_Version();                              /* 查询内核版本  */
	printf("version :%lu\n", version);

    // ……
}

```



## Lw_Kernel_Verinfo：查询系统版本信息字串


### 函数原型：

```C
PCHAR  Lw_Kernel_Verinfo
(
	VOID
);

```



### 描述：

该接口用来获取系统版本信息字串。

### 参数：

无。

### 返回值：

返回系统版本字串。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	PCHAR verinfo;
	// ……

	verinfo = Lw_Kernel_Verinfo();                               /* 查询内核版本  */
	printf("verinfo :%s\n",verinfo);

    // ……
}

```



## Lw_Kernel_Verpatch：查询系统当前修正版本


### 函数原型：

```C
ULONG   Lw_Kernel_Verpatch 
(
	VOID
);

```



### 描述：

该接口用来获取系统当前修正版本。

### 参数：

无。

### 返回值：

返回系统当前修正版本。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	ULONG verpatch ;
	// ……

	verpatch = Lw_Kernel_Verpatch();                     /* 查询系统当前修正版本 */
	printf("verpatch :%lu\n",verpatch);

    // ……
}

```



## Lw_Kernel_Reboot：重新启动内核 


### 函数原型：

```C
VOID   Lw_Kernel_Reboot
(
	INT  iRebootType
);

```



### 描述：

该接口用来重新启动内核。

### 参数：

- iRebootType ：重启类型。重启类型有：

|iRebootType|说明|
|---|---|
|LW_REBOOT_FORCE|立即重新启动计算机(致命错误)|
|LW_REBOOT_WARM|热启动(BSP决定具体行为)|
|LW_REBOOT_COLD|冷启动(BSP决定具体行为)|
|LW_REBOOT_SHUTDOWN|关闭(BSP决定具体行为)|

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	// ……

	Lw_Kernel_Reboot(LW_REBOOT_WARM);                    /* 重新启动内核 */
	// …….
	return  (0);

}

```



## Lw_Kernel_RebootEx：重新启动内核


### 函数原型：

```C
VOID   Lw_Kernel_RebootEx
(
	INT   iRebootType , 
	addr_t  ulStartAddress
);

```



### 描述：

该接口用来重新启动内核。

### 参数：

- iRebootType ：重启类型。重启类型有：

|iRebootType|说明|
|---|---|
|LW_REBOOT_FORCE|立即重新启动计算机(致命错误)|
|LW_REBOOT_WARM|热启动(BSP决定具体行为)|
|LW_REBOOT_COLD|冷启动(BSP决定具体行为)|
|LW_REBOOT_SHUTDOWN|关闭(BSP决定具体行为)|

- ulStartAddress ：启动地址。

### 返回值：

无。

### 错误码： 

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	// ……

	Lw_Kernel_RebootEx(LW_REBOOT_WARM, 0ull);          /* 重新启动内核   */
	// …….

	return  (0);
}

```



## Lw_Kernel_GetIdle：获取空闲线程句柄


### 函数原型：

```C
LW_OBJECT_HANDLE  Lw_Kernel_GetIdle
(
	VOID
);

```



### 描述：

该接口用来获得空闲线程句柄。

### 参数：

无。

### 返回值：

返回空闲线程句柄。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	LW_OBJECT_HANDLE handle;
	// ……

	handle = Lw_Kernel_GetIdle();                      /* 获取空闲线程句柄    */
	printf("handle :%lu\n",handle);

	// …….
	return  (0);
}

```



## Lw_Kernel\_ GetItimer：获取空闲应用定时器扫描线程句柄


### 函数原型：

```C
LW_OBJECT_HANDLE  Lw_Kernel_GetItimer 
(
	VOID
);

```



### 描述：

该接口用来获得空闲应用定时器扫描线程句柄。

### 参数：

无。

### 返回值：

返回空闲应用定时器扫描线程句柄。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	LW_OBJECT_HANDLE handle;
	// ……

	handle = Lw_Kernel_GetItimer ();            /* 获取空闲应用定时器扫描线程句柄 */
	printf("handle :%lu\n",handle);

	// ……
	return  (0);
}

```



## Lw_Kernel_GetExc：获取异常截获线程句柄


### 函数原型：

```C
LW_OBJECT_HANDLE  Lw_Kernel_GetExc
(
	VOID
);

```



### 描述：

该接口用来获得异常截获线程句柄。

### 参数：

无。

### 返回值：

返回异常截获线程句柄。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	LW_OBJECT_HANDLE handle;
	// ……

	handle = Lw_Kernel_GetExc ();                   /* 获取异常截获线程句柄 */
	printf("handle :%lu\n",handle);

	// …….
	return  (0);
}

```



## Lw_Kernel_GetPriorityMax：获取最低优先级


### 函数原型：

```C
UINT8   Lw_Kernel_GetPriorityMax 
(
	VOID
);

```



### 描述：

该接口用来获得内核最低优先级。

### 参数：

无。

### 返回值：

返回内核最低优先级。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	UINT8 priMax;
	// ……

	priMax = Lw_Kernel_GetPriorityMax();                   /* 获取最低优先级   */
	printf("priMax :%d\n",priMax);

	// …….
	return  (0);
}

```



## Lw_Kernel_GetPriorityMin：获取最高优先级


### 函数原型：

```C
UINT8   Lw_Kernel_GetPriorityMin 
(
	VOID
);

```


### 描述：

该接口用来获得内核最高优先级。

### 参数：

无。

### 返回值：

返回内核最高优先级。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	UINT8  priMin;
	// ……

	priMin = Lw_Kernel_GetPriorityMin();                       /* 获取最高优先级 */
    printf("priMin :%d\n",priMin);

	// …….
	return  (0);
}

```



## Lw_Kernel_GetThreadNum：获取当前线程数量


### 函数原型：

```C
UINT16   Lw_Kernel_GetThreadNum
(
	VOID
);

```




### 描述：

该接口用来获得当前线程数量。

### 参数：

无。

### 返回值：

返回当前线程数量。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	UINT16  ThreadNum;
	// ……

	ThreadNum = Lw_Kernel_GetThreadNum();               /*  获取当前线程数量*/
	printf("ThreadNum :%d\n",ThreadNum); 

	// …….
	return  (0);
}

```



## Lw_Kernel_GetThreadNumByPriority：获取进程中线程数量


### 函数原型：

```C
UINT16  Lw_Kernel_GetThreadNumByPriority 
(
	UINT8  ucPriority
);

```



### 描述：

该接口用来获得内核指定优先级的线程数量，从1.0.0-rc44 版本开始，不再支持此函数。

### 参数：

- ucPriority ：指定优先级。

### 返回值：

返回内核指定优先级的线程数量。

### 错误码：

- ENOSYS ：函数不受支持。

### 样例：

```C
无
```




## LW_Kernel_IsRunning：检测实时内核是否运行


### 函数原型：

```C
BOOL  	Lw_Kernel_IsRunning 
(
	VOID
);

```



### 描述：

该接口用来检测实时内核是否已经运行。

### 参数：

无。

### 返回值：

运行返回1，没运行返回0。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	BOOL run;
	// ……

	run = Lw_Kernel_IsRunning();                        /* 检测实时内核是否运行 */
	if(run == 0)
	{
		// ……
	}
	else
	{
		// ……
	}
	// …….
	return  (0);
}

```



## Lw_Kernel_HeapInfo：查询系统内核堆状态


### 函数原型：

```C
ULONG  		Lw_Kernel_HeapInfo
(
	ULONG    ulOption, 
	size_t      *pstByteSize,
	ULONG    *pulSegmentCounter,
	size_t      *pstUsedByteSize,
	size_t      *pstFreeByteSize,
	size_t      *pstMaxUsedByteSize
);

```



### 描述：

该接口用来查询系统内核堆状态。

### 参数：

- ulOption ：堆选择选项，选项有：

|ulOption|说明|
|---|---|
|LW_OPTION_HEAP_KERNEL|内核堆|
|LW_OPTION_HEAP_SYSTEM|系统堆|

- pstByteSize ：堆总大小，字节数。
- pulSegmentCounter ：堆分段数。
- pstUsedByteSize ：堆使用的字节数。
- pstFreeByteSize ：堆空闲的字节数。
- pstMaxUsedByteSize ：堆空闲最大使用量。

### 返回值：

成功返回0，失败返回相应的错误码，并设置相应的错误标志。

### 错误码：

- ERROR_KERNEL_OPTION ：选项出错

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	int ret;
	size_t  ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;
	ULONG   SegmentCounter;
	// …….
                                                     
	ret = Lw_Kernel_HeapInfo(LW_OPTION_HEAP_KERNEL,&ByteSize, &SegmentCounter,
	     &UsedByteSize, &FreeByteSize, &MaxUsedByteSize);  /* 查询系统内核堆状态 */
	if(ret == 0)
	{
		printf("LW_OPTION_HEAP_KERNEL ByteSize :%d\n", ByteSize);
		printf("LW_OPTION_HEAP_KERNEL SegmentCounter :%lu\n", SegmentCounter);
		printf("LW_OPTION_HEAP_KERNEL UsedByteSize :%d\n", UsedByteSize);
		printf("LW_OPTION_HEAP_KERNEL FreeByteSize :%d\n", FreeByteSize);
		printf("LW_OPTION_HEAP_KERNELMaxUsedByteSize:%d\n", MaxUsedByteSize);
	}

	// …….
	return  (0);
}

```



## Lw_Kernel_HeapStatus：查询系统内核堆状态


### 函数原型：

```C
ULONG  Lw_Kernel_HeapStatus
(
	ULONG    ulOption, 
	size_t     *pstByteSize,
	ULONG   *pulSegmentCounter,
	size_t     *pstUsedByteSize,
	size_t     *pstFreeByteSize,
	size_t     *pstMaxUsedByteSize
);

```



### 描述：

该接口用来查询系统内核堆状态。

### 参数：

- ulOption ：堆选择选项，选项有：

|ulOption|说明|
|---|---|
|LW_OPTION_HEAP_KERNEL|内核堆|
|LW_OPTION_HEAP_SYSTEM|系统堆|

- pstByteSize ：堆总大小，字节数。
- pulSegmentCounter ：堆分段数。
- pstUsedByteSize ：堆使用的字节数。
- pstFreeByteSize ：堆空闲的字节数。
- pstMaxUsedByteSize ：堆空闲最大使用量。

### 返回值：

成功返回0，失败返回相应的错误码，并设置相应的错误标志。

### 错误码：

- ERROR_KERNEL_OPTION ：选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	int ret;
	size_t  ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;
	ULONG   SegmentCounter;
	// …….
                                                  
	ret=Lw_Kernel_HeapStatus(LW_OPTION_HEAP_KERNEL,&ByteSize,&SegmentCounter,	&UsedByteSize, &FreeByteSize, &MaxUsedByteSize);  /* 查询系统内核堆状态 */
	if(ret == 0)
	{
		printf("LW_OPTION_HEAP_KERNEL ByteSize :%d\n", ByteSize);
		printf("LW_OPTION_HEAP_KERNEL SegmentCounter :%lu\n", SegmentCounter);
		printf("LW_OPTION_HEAP_KERNEL UsedByteSize :%d\n", UsedByteSize);
		printf("LW_OPTION_HEAP_KERNEL FreeByteSize :%d\n", FreeByteSize);
		printf("LW_OPTION_HEAP_KERNELMaxUsedByteSize:%d\n", MaxUsedByteSize);
	}
	// …….

	return  (0);
}

```



## Lw_Kernel_HeapInfoEx：查询系统内核堆状态


### 函数原型：

```C
ULONG  Lw_Kernel_HeapInfoEx
(
	ULONG                ulOption, 
	size_t                  *pstByteSize,
	ULONG                *pulSegmentCounter,
	size_t                  *pstUsedByteSize,
	size_t                  *pstFreeByteSize,
	size_t                  *pstMaxUsedByteSize,
	PLW_CLASS_SEGMENT  psegmentList[],
	INT                    iMaxCounter
);

```



### 描述：

该接口用来查询系统内核堆状态。

### 参数：

- ulOption ：堆选择选项，选项有：

|ulOption|说明|
|---|---|
|LW_OPTION_HEAP_KERNEL|内核堆|
|LW_OPTION_HEAP_SYSTEM|系统堆|

- pstByteSize ：堆总大小，字节数。
- pulSegmentCounter ：堆分段数。
- pstUsedByteSize ：堆使用的字节数。
- pstFreeByteSize ：堆空闲的字节数。
- pstMaxUsedByteSize ：堆空闲最大使用量。
- psegmentList[] ：分段头地点表
- iMaxCounter ：分段头地点表所能保存的最大分段数.

### 返回值：

成功返回0，失败返回相应的错误码，并设置相应的错误标志。

### 错误码：

- ERROR_KERNEL_OPTION ：选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	int ret, i;
	size_t  ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;
	ULONG   SegmentCounter;
	PLW_CLASS_SEGMENT memList[20] = {NULL};
	// …….

  	/*
	 *  查询系统内核堆状态 
	 */
	ret=Lw_Kernel_HeapInfoEx(LW_OPTION_HEAP_KERNEL,&ByteSize,
	&SegmentCounter,&UsedByteSize, &FreeByteSize, &MaxUsedByteSize, memList, 20);
	if(ret == 0)
	{
		printf("LW_OPTION_HEAP_KERNEL ByteSize :%d\n", ByteSize);
		printf("LW_OPTION_HEAP_KERNEL SegmentCounter :%lu\n", SegmentCounter);
		printf("LW_OPTION_HEAP_KERNEL UsedByteSize :%d\n", UsedByteSize);
		printf("LW_OPTION_HEAP_KERNEL FreeByteSize :%d\n", FreeByteSize);
		printf("LW_OPTION_HEAP_KERNELMaxUsedByteSize:%d\n", MaxUsedByteSize);
		   for(i = 0; i<10 && memList[i] != NULL;i++)
		   {
			   printf("memlist %d SEGMENT_stByteSize %d\n",
 						i, memList[i]->SEGMENT_stByteSize);
			   printf("memlist %d SEGMENT_stMagic %d\n", 
						i, memList[i]->SEGMENT_stMagic);
		   }
	  }
	  // …….
	  return  (0);
}

```



## Lw_Kernel_HeapStatusEx：查询系统内核堆状态


### 函数原型：

```C
ULONG  Lw_Kernel_HeapStatusEx
(
	ULONG                  ulOption, 
	size_t                   *pstByteSize,
	ULONG                 *pulSegmentCounter,
	size_t                    *pstUsedByteSize,
	size_t                    *pstFreeByteSize,
	size_t                    *pstMaxUsedByteSize,
	PLW_CLASS_SEGMENT    psegmentList[],
	INT                       iMaxCounter
);

```



### 描述：

该接口用来查询系统内核堆状态。

### 参数：

- ulOption ：堆选择选项，选项有：

|ulOption|说明|
|---|---|
|LW_OPTION_HEAP_KERNEL|内核堆|
|LW_OPTION_HEAP_SYSTEM|系统堆|

- pstByteSize ：堆总大小，字节数。
- pulSegmentCounter ：堆分段数。
- pstUsedByteSize ：堆使用的字节数。
- pstFreeByteSize ：堆空闲的字节数。
- pstMaxUsedByteSize ：堆空闲最大使用量。
- psegmentList[] ：分段头地点表
- iMaxCounter ：分段头地点表所能保存的最大分段数

### 返回值：

成功返回0，失败返回相应的错误码，并设置相应的错误标志。

### 错误码：

- ERROR_KERNEL_OPTION ：选项出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
PVOID Thread1 (PVOID pvArg)
{
	int ret, i;
	size_t  ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;
	ULONG   SegmentCounter;
	PLW_CLASS_SEGMENT memList[20] = {NULL};
	// …….

    /* 
	 *  查询系统内核堆状态 
	 */
	ret=Lw_Kernel_HeapStatusEx(LW_OPTION_HEAP_KERNEL,&ByteSize, 	&SegmentCounter,&UsedByteSize, &FreeByteSize, &MaxUsedByteSize, memList, 20);
	if(ret == 0)
	{
		printf("LW_OPTION_HEAP_KERNEL ByteSize :%d\n", ByteSize);
		printf("LW_OPTION_HEAP_KERNEL SegmentCounter :%lu\n", SegmentCounter);
		printf("LW_OPTION_HEAP_KERNEL UsedByteSize :%d\n", UsedByteSize);
		printf("LW_OPTION_HEAP_KERNEL FreeByteSize :%d\n", FreeByteSize);
		printf("LW_OPTION_HEAP_KERNELMaxUsedByteSize:%d\n", MaxUsedByteSize);
		   for(i = 0; i<10 && memList[i] != NULL;i++)
		   {
			  printf("memlist %d SEGMENT_stByteSize %d\n",
						 i, memList[i]->SEGMENT_stByteSize);
			  printf("memlist %d SEGMENT_stMagic %d\n", 
						i, memList[i]->SEGMENT_stMagic);
		   }
	 }
	 // …….
	 return  (0);
}

```



# 显示


## Lw_Backtrace_Show：显示调用栈信息


### 函数原型：

```C
VOID    Lw_Backtrace_Show 
(
	INT  iFd,
	INT  iMaxDepth
);

```


### 描述：

该接口显示调用栈信息。

### 参数：

- iFd ：输出文件
- iMaxDept ：最大堆栈深度。

### 返回值：

无。

### 错误码：

无。

### 备注：

无。

### 样例：

```c
#include <stdio.h>
#include <SylixOS.h> 
int main (int argc, char **argv)
{
    int file = open ("/apps/time/a", O_CREAT | O_RDWR, 0777);            /*创建文件 */
    if(file == -1)
    {
        perror("fun open error\n");
        return PX_ERROR;
    }
    Lw_Backtrace_Show(file, 5);                        /*显示调用栈信息*/
    close(file);
    return (0);
}
```

## Lw_Thread_Show：打印所有线程信息


### 函数原型：

```c
VOID    Lw_Thread_Show
(
	VOID
);

```



### 描述：

该接口用来显示所有的线程的信息，不可在中断中使用。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```C
#include <SylixOS.h>
static PVOID Thread2(PVOID arg)
{
	// ……
	Lw_Thread_Show();
    // ……
}

```



## Lw_Thread_ShowEx：显示指定进程中线程的信息


### 函数原型：

```C
VOID    Lw_Thread_ShowEx
(
	pid_t  pid
);

```



### 描述：

该接口用来显示指定进程中线程的信息，不可在中断中使用。

### 参数：

- pid ：需要显示对应进程中的线程的进程ID（-1表示所有线程）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

### 样例：

```C
#include <SylixOS.h>
#include <unistd.h>
PVOID Thread2 (PVOID arg)
{
    while(1)
    {
        …...
        Lw_Thread_ShowEx(getpid());
        …...
    }
    return NULL;
}

```



## Lw_Thread_PendShow：显示所有阻塞线程的信息


### 函数原型：

```C
VOID   	Lw_Thread_PendShow
(
	VOID
);

```



### 描述：

该接口用来显示正在阻塞线程的信息，不可在中断中使用。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。

- LW_OBJECT_HANDLE_INVALID ：API返回无效句柄。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <unistd.h>
static PVOID Thread2(PVOID arg)
{
	// ……
	Lw_Thread_PendShow();
    // ……
}

```



## Lw_Thread_PendShowEx：显示指定进程阻塞线程的信息


### 函数原型：

```C
VOID   Lw_Thread_PendShowEx 
(
	pid_t  pid
)

```



### 描述：

该接口用来显示指定进程中阻塞线程的信息，不可在中断中使用。

### 参数：

- pid ：需要显示对应进程中的线程的进程ID（-1表示所有线程）。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统出于中断。
- LW_OBJECT_HANDLE_INVALID ：API 返回无效句柄。

### 样例：

```C
#include <SylixOS.h>
#include <unistd.h>
int main()
{
	// ……
	Lw_Thread_PendShowEx(getpid());
	// ……
	return 0;
}

```



## Lw_Stack_Show：打印所有线程堆栈使用信息


### 函数原型：

```C
VOID    Lw_Stack_Show
(
	VOID
);

```



### 描述：

该接口用来显示所有的线程的堆栈使用信息。

### 参数：

无。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中
- ERROR_THREAD_NULL ：线程句柄无效
- ERROR_THREAD_OPTION ：线程选项与执行操作不符

### 样例：

```C
#include <SylixOS.h>
#include <unistd.h>
int main()
{
	// ……
	Lw_Thread_PendShowEx(getpid());
	// ……
	return 0;
}

```



## Lw_Semaphore_Show：显示指定信号量信息


### 函数原型：

```C
VOID   Lw_Semaphore_Show 
(
	LW_OBJECT_HANDLE  ulId
)

```



### 描述：

该接口用来显示指定的信号量信息。

### 参数：

- ulId ：信号量句柄。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_HANDLE_NULL ：句柄类型错误
- ERROR_EVENT_TYPE ：事件类型出错。

### 样例：

```C
#include <SylixOS.h>
#include < stdio.h >
PVOID Thread1 (PVOID pvArg)
{
	…..
}
PVOID Thread2 (PVOID pvArg)
{
	// …….
}
int main (int argc, char **argv)
{
    LW_HANDLE hId1, hId2;
    int       ret;
Semaphore = Lw_SemaphoreC_Create("SemaphoreC1", 2, 5,              
 /*  创建一个计数信号量   */
            LW_OPTION_WAIT_PRIORITY|LW_OPTION_OBJECT_LOCAL, LW_NULL);
    if(Semaphore == LW_HANDLE_INVALID)
    {
        perror("fun Lw_SemaphoreC_Create error");
        return (PX_ERROR);
    }
hId1 = Lw_Thread_Create("t_test1", Thread1, LW_NULL, LW_NULL);  
/*  创建第 1 个线程    */
    if (hId1 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }
hId2 = Lw_Thread_Create("t_test2", Thread2, LW_NULL, LW_NULL); 
/*  创建第 2 个线程  */
    if (hId2 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }
    ret = Lw_Thread_Join(hId1, LW_NULL);       /*  回收第 1 个线程    */
    if(ret != 0)
    {
        perror("fun Lw_Thread_Join error\n");
        return (PX_ERROR);
    }
    ret = Lw_Thread_Join(hId2, LW_NULL);        /*  回收第 2 个线程  */
    if(ret != 0)
    {
        perror("fun Lw_Thread_Join error\n");
        return (PX_ERROR);
    }
    return (ERROR_NONE);
}

```



## Lw_Interrupt_Show：显示操作系统中断向量表内容


### 函数原型：

```C
VOID   Lw_Interrupt_Show 
(
	ULONG  ulCPUStart, 
	ULONG  ulCPUEnd
);

```



### 描述：

该接口用来显示中断向量表的所有内容。

### 参数：

- ulCPUStart ：需要显示详细信息的起始CPU号
- ulCPUEnd ：需要显示详细信息的结束CPU号。

### 返回值：

无。

### 错误码： 

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
    Lw_Interrupt_Show(0, 0);        /* 显示操作系统中断向量表内容*/
    return (0);
}

```



## Lw_Time_Show：打印操作系统时间信息


### 函数原型：

```C
VOID   Lw_Time_Show
(
	VOID
);

```



### 描述：

该接口用来打印操作系统时间信息。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
int main (int argc, char **argv)
{
    Lw_Time_Show();                        /* 打印系统日期、时间、年份     */
    return 0;
}

```



## Lw_Timer_Show：显示定时器的相关信息


### 函数原型：

```C
VOID    Lw_Timer_Show 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示定时器的相关信息。

### 参数：

- ulId ：定时器句柄。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
VOID timerRoutine (PVOID pvArg)
{
    fprintf(stdout, "timer is triggered.\r\n");
}
int main (int argc, char *argv[])
{
    LW_HANDLE   ulTimerId;
    ULONG       ulPeriod = LW_MSECOND_TO_TICK_1(1000);
    int ret;

    ulTimerId = API_TimerCreate("timer_test", LW_OPTION_ITIMER, LW_NULL);
    if (ulTimerId == LW_HANDLE_INVALID) {
        fprintf(stderr, "create timer failed.\n");
        return  (-1);
    }

    ret = API_TimerStart(ulTimerId,ulPeriod, LW_OPTION_AUTO_RESTART, timerRoutine, LW_NULL);
    if(ret != 0)
    {
        printf("API_TimerStart failed\n");
    }
    sleep(4);
    Lw_Timer_Show(ulTimerId);     /* 显示定时器的相关信息*/
    ret = API_TimerCancel(ulTimerId);
    if(ret != 0)
    {
        printf("API_TimerCancel failed\n");
    }
    ret = API_TimerDelete(&ulTimerId);
    if(ret != 0)
    {
        printf("API_TimerDelete failed\n");
    }
    fprintf(stdout, "timer is deleted.\n");
    return  (0);
}

```



## Lw_Rms_Show：打印操作系统精度单调调度器信息

### 函数原型：
```C
VOID    Lw_Rms_Show
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示操作系统精度单调调度器信息，不可在中断中使用。

### 参数：

- ulId ：精度单调调度器句柄。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <SylixOS.h>
int main()
{
	// ……
	Lw_Rms_Show(G_rms1);
	// ……
	return LW_NULL;
}

```



## Lw_CPUUsage_Show：显示所有线程的CPU占用率信息


### 函数原型：

```C
VOID    Lw_CPUUsage_Show 
(
	INT  iWaitSec, 
	INT  iTimes
);’

```



### 描述：

该接口用来显示所有的线程的CPU占用率信息。

### 参数：

- iWaitSec ：每次检测多少秒
- iTimes ：检测多少次不超过10s。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
int main (int argc, char **argv)
{
    Lw_CPUUsage_Show(1, 3);               /* 显示所有的线程的 CPU 占用率信息*/
    return (0);
}

```



## Lw_MsgQueue_Show：显示指定的消息队列信息


### 函数原型：

```C
VOID   API_MsgQueueShow
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示指定的消息队列信息，不可在中断中使用。

### 参数：

- ulId ：消息队列句柄。

### 返回值：

成功打印相应信息，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件类型出错。
- ERROR_MSGQUEUE_TYPE ：消息类型错。

### 样例：

```C
#include <stdio.h>
#include <string.h>
#include <SylixOS.h> 
static LW_OBJECT_HANDLE G_queue;
PVOID Thread1(PVOID arg)
{
    ULONG ret;
    char *str = "HYSylixOS ease of use system!";

    ret = Lw_MsgQueue_Send(G_queue, str, strlen(str)); /* 向消息队列里无等待发送消息 */
    if(ret != 0)
    {
        perror("fun Lw_MsgQueue_Send error\n");
        return (PVOID)-1;
    }
    Lw_MsgQueue_Show(G_queue);         /* 显示指定的消息队列信息     */

    return LW_NULL;
}
PVOID Thread2(PVOID arg)
{
    ULONG ret;
    char MsgBuffer[1024];
    size_t msglen = 0;
    memset(MsgBuffer, 0, sizeof(MsgBuffer));
    /*
       从消息队列里无等待接收消息
    */
    ret = Lw_MsgQueue_TryReceive(G_queue, MsgBuffer, sizeof(MsgBuffer), &msglen);
    if(ret != 0)
    {
        perror("fun Lw_MsgQueue_TryReceive error\n");
        return (PVOID)-1;
    }
    MsgBuffer[msglen] = '\0';
    printf("receive data :%s\n", MsgBuffer);
    return LW_NULL;
}
int main (int argc, char **argv)
{
    LW_HANDLE hId1, hId2;
hId1 = Lw_Thread_Create("t_test1", Thread1, LW_NULL, LW_NULL);      
 /*  创建第一个线程              */
    if (hId1 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }

hId2 = Lw_Thread_Create("t_test2", Thread2, LW_NULL, LW_NULL);      
 /*  创建第二个线程              */
    if (hId2 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }
    /*
     *  创建一个消息队列
    */
    G_queue= Lw_MsgQueue_Create("msgqueue1", 20, 1024, LW_OPTION_WAIT_PRIORITY, LW_NULL);
    if(G_queue == LW_OBJECT_HANDLE_INVALID)
    {
        perror("fun Lw_MsgQueue_Create error\n");
        return PX_ERROR;
    }
    Lw_Thread_Join(hId1,LW_NULL);           /*  等待线程结束，并回收资源   */
    Lw_Thread_Join(hId2,LW_NULL);

    Lw_MsgQueue_Delete(&G_queue);           /*  删除消息队列               */
    return  (0);
}

```



## Lw_EventSet_Show：显示事件集的相关信息


### 函数原型：

```C
VOID    API_EventSetShow 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示指定事件集的相关信息，不可在中断中使用。

### 参数：

- ulId ：事件集句柄。

### 返回值：

成功打印相应信息，失败返回相应错误码。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_EVENTSET_TYPE ：事件类型出错。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h>
#include <string.h>
static LW_OBJECT_HANDLE G_eventSet;
PVOID Thread1(PVOID arg)
{
    Lw_EventSet_Show(G_eventSet);                  /*显示事件集的相关信息*/

    return LW_NULL;
}
PVOID Thread2(PVOID arg)
{
    printf("Create Thread2 success!\n");
    return LW_NULL;
}
int main (int argc, char **argv)
{
    LW_HANDLE hId1, hId2;
hId1 = Lw_Thread_Create("t_test", Thread1, LW_NULL, LW_NULL);          
/*建立线程1               */
    if (hId1 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }
hId2 = Lw_Thread_Create("t_test", Thread2, LW_NULL, LW_NULL); 
 /*建立线程2               */
    if (hId2 == LW_HANDLE_INVALID)
    {
        perror("fun Lw_Thread_Create error");
        return (PX_ERROR);
    }
    G_eventSet = Lw_Event_Create("event1", 0, LW_OPTION_WAIT_PRIORITY, LW_NULL);
    if(G_eventSet == LW_OBJECT_HANDLE_INVALID)
    {
        perror("fun Lw_Event_Create error\n");
        return (PX_ERROR);
    }
    return  (0);
}

```



## Lw_Region_Show：显示指定的内存池信息


### 函数原型：

```C
VOID   API_RegionShow 
(
	LW_OBJECT_HANDLE  ulId
);

```



### 描述：

该接口用来显示指定的内存池信息。

### 参数：

- ulId ：内存池句柄：(0表示显示内核堆和系统堆信息)。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_OPTION ：选项出错。
- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
#define REGION_SIZE     (1024)
#define BLOCK_SIZE      (256)
#define BLOCK_CNT       (REGION_SIZE / BLOCK_SIZE)
LW_STACK     _G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];
LW_HANDLE    _G_hMyRegion;

int main(int argc, char *argv[])
{
    VOID    *pvBlockTable[BLOCK_CNT] = {LW_NULL};
    VOID    *pvBlockTmp;
    ULONG    ulError;
    INT      i = 0;

    _G_hMyRegion = Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZE,LW_OPTION_DEFAULT,LW_NULL);
    if (_G_hMyRegion == LW_HANDLE_INVALID)       /*  创建一个内存可变分区  */
    {
        fprintf(stderr, "create region failed.\n");
        return  (-1);
    }

    while (1)       
    {
        pvBlockTmp = Lw_Region_Allocate(_G_hMyRegion, BLOCK_SIZE);
        if (pvBlockTmp != LW_NULL)
        {
            pvBlockTable[i] = pvBlockTmp;
            fprintf(stdout, "alloc block successfully, count = %d.\n", i);
        }
        else
        {
            fprintf(stderr, "alloc block failed,        count = %d.\n", i);
            break;
        }
        i++;
    }
    for (i = 0; i < BLOCK_CNT; i++)
    {
        pvBlockTmp = pvBlockTable[i];
        if (pvBlockTmp != LW_NULL)
        {
            pvBlockTmp = Lw_Region_Put(_G_hMyRegion, pvBlockTmp);       
/*  释放指定内存缓冲区到内存可变分区 */
            if (pvBlockTmp != LW_NULL)
            {
                fprintf(stderr, "block%d put failed.\n", i);
            }
        }
        else
        {
            break;
        }
    }
    Lw_Region_Show(_G_hMyRegion);          /* 显示指定内存池信息            */
ulError = Lw_Region_Delete(&_G_hMyRegion);                          
/*  全部释放内存后删除内存分区  */
    if (ulError != ERROR_NONE)
    {
        fprintf(stderr, "delete region error.\n");
        return  (-1);
    }
    else
    {
        fprintf(stdout, "delete region successfully.\n");
    }
    return  (0);
}

```
|


## Lw_Partition_Show：显示指定的内存分区信息


### 函数原型：

```C
VOID   API_PartitionShow 
(
	LW_OBJECT_HANDLE  ulId
);

```
|


### 描述：

该接口用来显示指定的内存分区信息。

### 参数：

- ulId ：内存分区句柄。

### 返回值：

无。

### 错误码：

- ERROR_KERNEL_IN_ISR ：系统处于中断中。
- ERROR_KERNEL_PNAME_NULL ：名字指针为NULL。
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
typedef struct my_element
{
    INT     iValue;
} MY_ELEMENET;
#define ELEMENT_MAX     (8)
UINT8           _G_pucMyElementPool[sizeof(MY_ELEMENET) * ELEMENT_MAX];
LW_HANDLE    _G_hMyPartition;
int main (int argc, char *argv[])
{
    MY_ELEMENET     *peleTable[ELEMENT_MAX] = {LW_NULL};
    MY_ELEMENET     *peleTmp;
    ULONG            ulError;
    INT                i = 0;

    _G_hMyPartition = Lw_Partition_Create("my_partition",_G_pucMyElementPool,            ELEMENT_MAX,sizeof(MY_ELEMENET),LW_OPTION_DEFAULT,      LW_NULL);
    if (_G_hMyPartition == LW_HANDLE_INVALID)      /*  创建一个定长内存分区  */
    {
        fprintf(stderr, "create partition failed.\n");
        return  (-1);
    }
    while (1)
    {
        peleTmp = (MY_ELEMENET *)Lw_Partition_Get(_G_hMyPartition);     
/*  最多能够获取多少个元素内存   */
        if (peleTmp != LW_NULL)
        {
            peleTable[i]       = peleTmp;
            peleTmp->iValue = i;
            fprintf(stdout, "get element successfully, count = %d.\n", i);
        }
        else
        {
            fprintf(stderr, "get element failed,       count = %d.\n", i);
            break;
        }

        i++;
    }

    for (i = 0; i < ELEMENT_MAX; i++)
    {
        peleTmp = peleTable[i];
        if (peleTmp != LW_NULL)
        {
            fprintf(stdout, "element%d value = %d.\n", i, peleTmp->iValue);

            peleTmp = Lw_Partition_Put(_G_hMyPartition, peleTmp);      
 /*  释放内存块到定长内存分区中    */
            if (peleTmp != LW_NULL)
            {
                fprintf(stderr, "element%d put failed.\n", i);
            }
        }
        else
        {
            break;
        }
    }
    Lw_Partition_Show(_G_hMyPartition);      /*  显示指定内存分区的信息         */
ulError = Lw_Partition_Delete(&_G_hMyPartition); 
  /*  全部回收元素内存后删除内存分区 */
    if (ulError != ERROR_NONE)
    {
        fprintf(stderr, "delete partition error.\n");
        return  (-1);
    }
    else
    {
        fprintf(stderr, "delete partition successfully.\n");
    }
    return  (0);
}
```


## Lw_Vmm_PhysicalShow：显示vmm物理存储器信息

### 函数原型：

```C
VOID  API_VmmPhysicalShow 
(
	VOID
);
```


### 描述：

显示vmm物理存储器信息。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
i int main (int argc, char **argv)
{
    Lw_Vmm_PhysicalShow();                      /* 显示 vmm 物理存储器信息*/
    return (0);
}
```


## Lw_Vmm_VirtualShow：显示vmm虚拟存储器信息


### 函数原型：

```C
VOID  API_VmmVirtualShow
(
	VOID
);
```

### 描述：

显示vmm虚拟存储器信息。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
int main (int argc, char **argv)
{
    Lw_Vmm_VirtualShow();                     /* 显示 vmm 虚拟存储器信息   */
    return (0);
}
```


## Lw_Vmm_AbortShow：显示vmm访问中止信息


### 函数原型：

```C
VOID  API_VmmAbortShow 
(
	VOID
);
```

### 描述：

显示vmm访问中止信息。

### 参数：

无。

### 返回值：

无。

### 错误码：

无。

### 样例：

```C
#include <stdio.h>
#include <SylixOS.h> 
int main (int argc, char **argv)
{
    Lw_Vmm_AbortShow();                      /* 显示 vmm 访问中止信息    */
    return (0);
}
```
