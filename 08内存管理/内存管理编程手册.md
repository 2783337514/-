# 概述

内存管理机制是实时操作系统的重要组成部分，从实时性角度出发，要求内存分配过程的时间要尽可能的确定和快速。HYSylixOS 提供定长内存管理、变长内存管理和虚拟内存管理三种内存管理方式。

## 定长内存管理

所谓定长内存，指的是我们每次分配获得的内存大小是相同的，即使用的是有确定长度的内存块。同时，这些内存块总的个数也是确定的，即整个内存总的大小也是确定的。这和我们通常理解的内存池的概念是一样的。使用这样的内存，有两大优点：一是由于事先已经分配好了足够的内存，可极大提高关键应用的稳定性；二是对于定长内存的管理通常有更为简单的算法，分配/释放的效率更高。在 HYSylixOS 中，将管理的一个定长内存称作 PARTITION，即内存分区。

## 变长内存管理

变长内存相对于定长内存，最大的不同就是每次分配的内存可能大小是不同的。同时，在使用上，它和 malloc/free 类似，唯一的区别是所使用的内存由用户提供。HYSylixOS 中，将变长内存称作 REGION，即内存区域。由于使用 malloc/free 这类函数操作的是系统中的同一个内存堆，当一个应用程序中某个组件存在频繁分配/释放内存的操作时，可能会产生很多内存碎片，同时还会影响其他应用程序使用内存堆的效率，该情况下应该考虑为此组件创建一个单独的内存区域，可有效地避免上面的情况。

## 虚拟内存管理

### 内存划分

HYSylixOS 作为一个多进程操作系统，像其他多进程操作系统一样，有内核空间和用户空间之分。内核线程、驱动程序和内核模块均存在于内核空间，应用程序（即进程）和动态链接库均存在于用户空间。

@import "./image/系统内存划分.jpg"

<center>系统内存划分</center>  
  
上图描述了HYSylixOS在物理内存上的布局以及与虚拟内存的关系。通用内存区就是操作系统本身使用的内存空间，即内核空间，主要包括操作系统镜像、系统使用的内存堆和栈空间，它们的物理地址和虚拟地址是完全相同的，因此可以看到，它们没有对应的虚拟页面。VMM（Virtual Memory Management），即虚拟内存管理单元，以页面的方式管理除通用内存区外的所有物理内存，VMM还负责以页面的方式管理一片虚拟内存空间，并在需要的时候，将虚拟内存页面映射到物理内存页面。虚拟页面和物理页面的大小是相同的，通常为4KB。  

上图中，有一个特别的DMA页面区，专门用于DMA数据传输（因为DMA硬件只能访问物理地址）。HYSylixOS专门提供了分配DMA内存的API，仅供内核模块和驱动程序使用，应用程序不应该使用这些API，因此这里不作介绍。剩下的就是供应用程序和动态链接库使用的物理页面，它们均有对应的虚拟页面。通常我们所说的虚拟内存就是这一片地址连续的虚拟页面空间。操作系统会保证虚拟页面地址不会与通用内存和DMA内存地址有任何重叠。设想一下，若有任何重叠，则进程本身的数据（全局变量、栈空间、代码等）都可能会映射到系统内存或DMA内存，造成严重错误。我们把这片不能重叠的空间通常叫做操作系统保留空间。上图中的虚拟页面与物理页面的映射关系仅仅表示两者之间有页面的对应关系（后面将会讲到应用程序使用特殊的方法在虚拟空间直接访问DMA内存），但DMA Page物理地址空间不能与虚拟地址空间重合，因此图中将DMA Page与Physical Page作了明显的区分。  
  
### 进程页面管理
  
HYSylixOS中，进程访问的都是虚拟地址，这包括两方面：其一是创建进程时，装载器会为进程自身分配虚拟页面，包括进程的数据段、代码段、堆内存等；其二是进程运行时，访问栈内存或使用前面所讲的内存分配函数分配的内存。HYSylixOS当前为每个新创建的进程预分配32MB地址连续的虚拟内存页面，并会为进程自身的某些必要数据（如代码段、数据段等）分配物理内存，除此之外，只有进程在运行时，根据内存访问的需要才分配物理内存。  

虚拟内存空间可以大于物理内存空间的范围，系统可同时支持的进程数不仅受限于物理内存的大小，同时也受限于虚拟内存空间的大小。前面介绍过，由于保留空间的原因，虚拟空间总是小于硬件所能访问的最大空间（如在32位CPU中，虚拟空间小于4GB），这是所有多进程操作系统的共同特点。目前HYSylixOS虚拟空间默认配置是从3GB到4GB的范围，大小为1GB，在这种配置下，最大可支持32个进程，这是一个可接收并能广泛适应当前嵌入式系统的配置。当然，不同的硬件平台可以通过操作系统启动参数配置合适的虚拟空间范围，通常在BSP包里面完成。  

VMM可保证每次分配的虚拟页面是地址连续的，但对应的物理页面地址不一定连续。当进程释放内存时，仅仅释放对应的物理页面内存，虚拟页面不会被回收。当进程退出时，虚拟页面和物理页面均全部被回收。  
  
### 虚拟内存映射
  
应用程序可以使用mmap函数将一个设备文件与应用程序虚拟空间建立映射关系，将对文件的I/O访问转变为内存访问。本文档描述了HYSylixOS内存管理的应用程序编程接口。  
  
# 定长内存管理编程接口
  
## Lw_Partition_Create ：创建一个定长内存分区
  
### 函数原型：
  
```c  
LW_OBJECT_HANDLE Lw_Partition_Create   
(   
    CPCHAR pcName,   
    PVOID pvLowAddr,   
    ULONG ulBlockCounter,   
    size_t stBlockByteSize,   
    ULONG ulOption,   
    LW_OBJECT_ID *pulId   
);  
```  
  
### 描述：
  
该接口用来建立一个内存分区。  
  
### 参数：
  
- pcName ：名字。  
- pvLowAddr ：内存块起始地址。  
- ulBlockCounter ：内存块个数（至少为两块）。  
- stBlockByteSize ：内存块大小。  
- ulOption ：选项。  
- pulId ：Id 号。  
  
### 返回值：
  
成功返回内存分区的ID号；失败返回LW_OBJECT_HANDLE_INVALID，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
- ERROR_KERNEL_MEMORY ：内存地址出现错误。  
- ERROR_PARTITION_BLOCK_COUNTER ：分块数量错误。  
- ERROR_PARTITION_BLOCK_SIZE ：分块大小错误。  
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。  
- ERROR_PARTITION_FULL ：缺乏PARTITION控制块。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyPartition=Lw_Partition_Create("my_partition",_G_pucMyElementPool,ELEMENT_MAX,sizeof(MY_ELEMENET),LW_OPTION_DEFAULT,LW_NULL); /*创建一个定长内存分区*/   
    if (_G_hMyPartition == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create partition failed.n");   
        return (-1);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Delete ：删除定长内存分区
  
### 函数原型：
  
```c  
ULONG Lw_Partition_Delete   
(   
    LW_OBJECT_ID*pulId   
);  
```  
  
### 描述：
  
该接口用来删除一个内存分区。  
  
### 参数：
  
- pulId ：PARTITION 句柄指针。  
  
### 返回值：
  
成功返回0；失败相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
- ERROR_PARTITION_BLOCK_USED ：有分块被使用。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    ULONG ulError;   
    // ……   
    ulError=Lw_Partition_Delete(&_G_hMyPartition); /*全部回收元素内存后删除内存分区*/   
    if (ulError != ERROR_NONE)   
    {   
        fprintf(stderr, "delete partition error.n");   
        return (-1);   
    }   
    else {   
        fprintf(stderr, "delete partition successfully.n");   
    }   
    return (0);   
}  
  
```  
  
## Lw_Partition_DeleteEx ：删除指定的定长内存分区
  
### 函数原型：
  
```c  
ULONG Lw_Partition_DeleteEx   
(   
    LW_OBJECT_ID*pulId,   
    BOOL bForce   
);  
```  
  
### 描述：
  
该接口用来删除一个内存分区。并且可指定是否强制删除。  
  
### 参数：
  
- pulId ：PARTITION 句柄指针。  
- bForce ：是否强制删除。  
  
### 返回值：
  
成功返回0；失败相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
- ERROR_PARTITION_BLOCK_USED ：有分块被使用。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    ULONG ulError;   
    // ……   
    ulError=Lw_Partition_DeleteEx(&_G_hMyPartition,1); /*强制删除指定的定长内存分区*/   
    if (ulError != ERROR_NONE)   
    {   
        fprintf(stderr, "delete partition error.n");   
        return (-1);   
    } else {   
        fprintf(stderr, "deleteEx partition successfully.n");   
        return (0);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Get ：从定长内存分区获取一个内存块
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Get   
(   
    LW_OBJECT_ID ulId   
);  
```  
  
### 描述：
  
该接口用来获取一个内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
  
### 返回值：
  
成功返回获取到的内存块的首地址；失败0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{  
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    while (1)   
    {   
        peleTmp = (MY_ELEMENET*)Lw_Partition_Get(_G_hMyPartition); /* 最多能够获取多少个元素内存*/   
        if (peleTmp != LW_NULL)   
        {   
            peleTable[i] = peleTmp;   
            peleTmp->iValue = i;   
            fprintf(stdout, "get element successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "get element failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Take ：从定长内存分区获取一个内存块
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Take   
(   
    LW_OBJECT_ID ulId   
);  
```  
  
### 描述：
  
该接口用来获取一个内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
  
### 返回值：
  
成功返回获取到的内存块的首地址；失败0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;  
    // ……   
    while (1)   
    {   
        peleTmp = (MY_ELEMENET*)Lw_Partition_Take(_G_hMyPartition); /* 最多能够获取多少个元素内存*/   
        if (peleTmp != LW_NULL)   
        {   
            peleTable[i] = peleTmp;   
            peleTmp->iValue = i;   
            fprintf(stdout, "take element successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "take element failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Allocate ：从定长内存分区获取一个内存块
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Allocate   
(   
    LW_OBJECT_ID ulId   
);  
```  
  
### 描述：
  
该接口用来获取一个内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
  
### 返回值：
  
成功返回获取到的内存块的首地址；失败0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    while (1)   
    {   
        peleTmp = (MY_ELEMENET*)Lw_Partition_Allocate(_G_hMyPartition); /* 最多能够获取多少个元素内存*/   
        if (peleTmp != LW_NULL)   
        {   
            peleTable[i] = peleTmp;   
            peleTmp->iValue = i;   
            fprintf(stdout, "allocate element successfully, count = %d.n", i);   
        } else {   
            fprintf(stderr, "allocate element failed, count = %d.n", i);   
            break;   
        } i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Put ：释放内存块到定长内存分区中
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Put   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvBlock   
);  
```  
  
### 描述：
  
该接口用来交还指定内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pvBlock ：块地址。  
  
### 返回值：
  
成功返回0；失败返回未交还的内存块首地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    for (i = 0; i< ELEMENT_MAX; i++)   
    {   
        peleTmp = peleTable[i];   
        if (peleTmp != LW_NULL)   
        {   
            fprintf(stdout, "element%d value = %d.n", i, peleTmp->iValue);   
            peleTmp = Lw_Partition_Put(_G_hMyPartition, peleTmp); /* 释放内存块到定长内存分区中*/   
            if (peleTmp != LW_NULL)   
            {   
                fprintf(stderr, "element%d put failed.n", i);   
            }   
        } else {  
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Give ：释放内存块到定长内存分区中
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Give   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvBlock   
);  
```  
  
### 描述：
  
该接口用来交还指定内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pvBlock ：块地址。  
  
### 返回值：
  
成功返回0；失败返回未交还的内存块首地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    for (i = 0; i< ELEMENT_MAX; i++)   
    {   
        peleTmp = peleTable[i];   
        if (peleTmp != LW_NULL)   
        {   
            fprintf(stdout, "element%d value = %d.n", i, peleTmp->iValue);   
            peleTmp = Lw_Partition_Give(_G_hMyPartition, peleTmp); /* 释放内存块到定长内存分区中*/   
            if (peleTmp != LW_NULL)   
            {   
                fprintf(stderr, "element%d put failed.n", i);  
            }   
        } else {   
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Free ：释放内存块到定长内存分区中
  
### 函数原型：
  
```c  
PVOID Lw_Partition_Free   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvBlock   
);  
```  
  
### 描述：
  
该接口用来交还指定内存分区的内存块。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pvBlock ：块地址。  
  
### 返回值：
  
成功返回0；失败返回未交还的内存块首地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;  
    // ……   
    for (i = 0; i< ELEMENT_MAX; i++)   
    {   
        peleTmp = peleTable[i];   
        if (peleTmp != LW_NULL)   
        {   
            fprintf(stdout, "element%d value = %d.n", i, peleTmp->iValue);   
            peleTmp = Lw_Partition_Free(_G_hMyPartition, peleTmp); /* 释放内存块到定长内存分区中*/   
            if (peleTmp != LW_NULL)   
            {   
                fprintf(stderr, "element%d put failed.n", i);   
            }   
        } else {   
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Status ：查询定长内存分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Partition_Status   
(   
    LW_OBJECT_ID ulId,   
    ULONG*pulBlockCounter,   
    ULONG*pulFreeBlockCounter,   
    size_t*pstBlockByteSize   
);  
```  
  
### 描述：
  
该接口用来查询指定内存分区的信息。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pulBlockCounter ：存放块数量的指针。  
- pulFreeBlockCounter ：存放空闲块数量的指针。  
- pstBlockByteSize ：存放块大小的指针。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    ULONG ulError;   
    ULONG BlockCounter, FreeBlockCounter;   
    size_t BlockByteSize;   
    // ……   
    ulError = Lw_Partition_Status(_G_hMyPartition, &BlockCounter, &FreeBlockCounter,&BlockByteSize); /*查询定长内存分区的信息*/   
    if( ulError == 0)   
    {   
        printf("part BlockCounter :%lun", BlockCounter);   
        printf("part FreeBlockCounter :%lun", FreeBlockCounter);   
        printf("part BlockByteSize :%lun", BlockByteSize);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Info ：查询定长内存分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Partition_Info   
(   
    LW_OBJECT_ID ulId,   
    ULONG*pulBlockCounter,   
    ULONG*pulFreeBlockCounter,   
    size_t*pstBlockByteSize   
);  
```  
  
### 描述：
  
该接口用来查询指定内存分区的信息。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pulBlockCounter ：存放块数量的指针。  
- pulFreeBlockCounter ：存放空闲块数量的指针。  
- pstBlockByteSize ：存放块大小的指针。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    ULONG ulError;   
    ULONG BlockCounter, FreeBlockCounter;   
    size_t BlockByteSize;  
    // ……   
    ulError = Lw_Partition_Info(_G_hMyPartition, &BlockCounter, &FreeBlockCounter,&BlockByteSize); /*查询定长内存分区的信息*/   
    if( ulError == 0)   
    {   
        printf("part BlockCounter :%lun", BlockCounter);   
        printf("part FreeBlockCounter :%lun", FreeBlockCounter);   
        printf("part BlockByteSize :%lun", BlockByteSize);   
    }  
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_GetName ：获取定长内存分区的名字
  
### 函数原型：
  
```c  
ULONG Lw_Partition_GetName   
(   
    LW_OBJECT_ID ulId,   
    PCHAR pcName   
);  
```  
  
### 描述：
  
该接口用来获取指定内存分区的名字。  
  
### 参数：
  
- ulId ：PARTITION 句柄。  
- pcName ：存放内存分区名字的缓冲区。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_PARTITION_NULL ：PARTITION相关参数为空。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyPartition=Lw_Partition_Create("my_partition",_G_pucMyElementPool,ELEMENT_M AX,sizeof(MY_ELEMENET),LW_OPTION_DEFAULT,LW_NULL); /*创建一个定长内存分区*/   
    if (_G_hMyPartition == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create partition failed.n");   
        return (-1);   
    }   
    ulError = Lw_Partition_GetName(_G_hMyPartition, name); /*获取定长内存分区的名字*/   
    if(ulError == 0)   
    {   
        printf("_G_hMyPartition name :%sn", name);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Partition_Show ：显示指定内存分区的信息
  
### 函数原型：
  
```c  
VOID Lw_Partition_Show   
(   
    LW_OBJECT_HANDLE ulId   
);  
```  
  
### 描述：
  
该接口用来显示指定内存分区的相关信息，不可在中断中使用。  
  
### 参数： 
  
- ulId ：内存分区句柄。  
  
### 返回值：
  
无。  
  
### 错误码：
  
无。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>   
typedef struct my_element   
{   
    INT iValue;   
}   
MY_ELEMENET;  
#define ELEMENT_MAX (8)   
UINT8_G_pucMyElementPool[sizeof(MY_ELEMENET)* ELEMENT_MAX];   
LW_HANDLE_G_hMyPartition;   
int main (int argc, char*argv[])   
{   
    MY_ELEMENET*peleTable[ELEMENT_MAX] = {LW_NULL};   
    MY_ELEMENET*peleTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyPartition=Lw_Partition_Create("my_partition",_G_pucMyElementPool,ELEMENT_M AX,sizeof(MY_ELEMENET),LW_OPTION_DEFAULT,LW_NULL); /*创建一个定长内存分区*/   
    if (_G_hMyPartition == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create partition failed.n");   
        return (-1);   
    }   
    Lw_Partition_Show(_G_hMyPartition); /* 显示指定内存分区的信息*/   
    // ……;   
    return (0);   
}  
```  
  
# 变长内存管理编程接口
  
## Lw_Region_Create ：创建一个内存可变分区
  
### 函数原型：
  
```c  
LW_OBJECT_HANDLE Lw_Region_Create   
(   
    CPCHAR pcName,   
    PVOID pvLowAddr,   
    ULONG stRegionByteSize,   
    ULONG ulOption,   
    LW_OBJECT_ID*pulId   
);  
```  
  
### 描述：
  
该接口用来建立一个内存可变分区。  
  
### 参数：
  
- pcName ：名字。  
- pvLowAddr ：内存分区起始地址。  
- stRegionByteSize ：内存分区大小。  
- ulOption ：选项。  
- pulId ：REGION 句柄指针。  
  
### 返回值：
  
成功返回内存分区的ID号；失败返回LW_OBJECT_HANDLE_INVALID，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_NULL ：控制块错误。  
- ERROR_KERNEL_MEMORY ：内存地址出现错误。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_PNAME_TOO_LONG ：名字太长。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Delete ：删除指定的内存可变分区
  
### 函数原型：
  
```c  
ULONG Lw_Region_Delete   
(   
    LW_OBJECT_ID*pulId   
);  
```  
  
### 描述：
  
该接口用来删除一个内存可变分区。  
  
### 参数：
  
- pulId ：REGION句柄指针。  
  
### 返回值：
  
成功返回0；失败相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_USED ：有分块被使用。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_S IZE, LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    // ……   
    ulError = Lw_Region_Delete(&_G_hMyRegion);/*全部释放内存后删除内存分区*/   
    if (ulError != ERROR_NONE)   
    {   
        fprintf(stderr, "delete region error.n");   
        return (-1);   
    } else {   
        fprintf(stdout, "delete region successfully.n");  
    }   
    return (0);   
}  
```  
  
## Lw_Region_DeleteEx ：删除指定的内存可变
  
### 函数原型：
  
ULONG Lw_Region_DeleteEx   
(   
    LW_OBJECT_ID*pulId,   
    BOOL bForce   
);  
  
  
### 描述：
  
该接口用来删除一个内存可变分区。并且可指定是否强制删除。  
  
### 参数：
  
- pulId ：REGION句柄指针。  
- bForce ：指定是否强制删除。  
  
### 返回值：
  
成功返回0；失败相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_USED ：有分块被使用。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    // ……   
    ulError = Lw_Region_DeleteEx(&_G_hMyRegion,1); /*强制删除指定的定长内存分区*/   
    if (ulError != ERROR_NONE)   
    {   
        fprintf(stderr, "delete partition error.n");   
        return (-1);   
    } else {   
        fprintf(stderr, "deleteEx partition successfully.n");   
    }   
    return (0);  
}  
```  
  
## Lw_Region_AddMem ：为指定的内存可变分区增加内存
  
### 函数原型：
  
```c  
ULONG Lw_Region_AddMem   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvMem,   
    size_t stByteSize   
);  
```  
  
### 描述：
  
该接口用来向指定的内存可变分区增加内存。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：内存地址。  
- stByteSize ：内存大小。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_MEMORY ：内存地址出现错误。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZE,LW_OPTION_DEFAULT,LW_NULL);  
    /*创建一个内存可变分区*/  
    if (_G_hMyRegion == LW_HANDLE_INVALID)  
    {  
        fprintf(stderr, "create region failed.n");  
        return (-1);  
    }  
    while (1) /* 从内存可变分区获取内存缓冲区*/  
    {  
        pvBlockTmp = Lw_Region_Allocate(_G_hMyRegion, BLOCK_SIZE);  
        if (pvBlockTmp != LW_NULL)  
        {  
            pvBlockTable[i] = pvBlockTmp;  
            fprintf(stdout, "alloc block successfully, count = %d.n", i);  
        }  
        else{  
            fprintf(stderr, "alloc block failed, count = %d.n", i);  
            break;  
        }  
        i++;  
    }  
    ulError = Lw_Region_AddMem(_G_hMyRegion, arr, 1024);  
    /*为内存可变分区增加内存*/  
    if(ulError != 0)  
    {  
        perror("fun Lw_Region_AddMem errorn");  
        return PX_ERROR;  
    }  
    // ……  
    return (0);  
}  
```  
  
## Lw_Region_Get ：从内存可变分区获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Get   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Get(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "get block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "get block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Take ：从内存可变分区获取内存缓冲区
  
  
### 函数原型：
  
```c  
PVOID Lw_Region_Take   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Take(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "take block successfully, count = %d.n", i);   
        }  
        else {   
            fprintf(stderr, "take block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Allocate ：从内存可变分区获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Allocate   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Allocate(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "allocate block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "allocate block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_GetAlign ：从内存可变分区获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_GetAlign   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize,   
    size_t stAlign   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取一块指定内存对齐关系的缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
- stAlign ：指定的内存对齐关系。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0(NULL)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_ALIGN ：对齐关系错误。  
- ERROR_REGION_NOMEM ：没有内存可供分配。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_GetAlign(_G_hMyRegion, BLOCK_SIZE,4);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "getAlign block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "getAlign block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}   
```  
  
## Lw_Region_TakeAlign ：从内存可变分区获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_GetAlign   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize,   
    size_t stAlign   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取一块指定内存对齐关系的缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
- stAlign ：指定的内存对齐关系。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0(NULL)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_ALIGN ：对齐关系错误。  
- ERROR_REGION_NOMEM ：没有内存可供分配。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_TakeAlign(_G_hMyRegion, BLOCK_SIZE,4);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {  
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "takeAlign block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "takeAlign block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_AllocateAlign ：从内存可变分区获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_GetAlign   
(   
    LW_OBJECT_ID ulId,   
    size_t stByteSize,   
    size_t stAlign   
);  
```  
  
### 描述：
  
该接口用来向从指定的内存可变分区中获取一块指定内存对齐关系的缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- stByteSize ：内存缓存区大小。  
- stAlign ：指定的内存对齐关系。  
  
### 返回值：
  
成功返回获取内存缓存区的首地址；失败返回0(NULL)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_SIZE ：分区大小太小。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_ALIGN ：对齐关系错误。  
- ERROR_REGION_NOMEM ：没有内存可供分配。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_AllocateAlign(_G_hMyRegion, BLOCK_SIZE,4);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/  
        {  
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "allocateAlign block successfully, count = %d.n", i);  
        }   
        else {   
            fprintf(stderr, "allocateAlign block failed, count = %d.n", i);   
            break;   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Reget ：从内存可变分区重新获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Reget   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvOldMem,   
    size_t stNewByteSize   
);  
```  
  
### 描述：
  
该接口用来重新获得一个内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：原先分配的内存。  
- stNewByteSize ：新的分段大小。  
  
### 返回值：
  
成功返回新分配的缓冲区首地址；失败返回NULL(0)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);  
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Get(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "get block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "get block failed, count = %d.n", i);   
            break;   
        }   
        pvBlockTmp = Lw_Region_Reget(_G_hMyRegion, pvBlockTmp,512); /* 从内存可变分区重新获取内存缓冲区*/   
        if (pvBlockTmp != LW_NULL)   
        {   
            fprintf(stdout,"fun Lw_Region_Reget successfullyn");   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Retake ：从内存可变分区重新获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Retake   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvOldMem,   
    size_t stNewByteSize   
);  
```  
  
### 描述：
  
该接口用来重新获得一个内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：原先分配的内存。  
- stNewByteSize ：新的分段大小。  
  
### 返回值：
  
成功返回新分配的缓冲区首地址；失败返回NULL(0)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)  
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);  
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Get(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "get block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "get block failed, count = %d.n", i);  
            break;   
        }   
        pvBlockTmp = Lw_Region_Retake(_G_hMyRegion, pvBlockTmp,512); /* 从内存可变分区重新获取内存缓冲区*/   
        if (pvBlockTmp != LW_NULL)   
        {   
            fprintf(stdout,"fun Lw_Region_Retake successfullyn");   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Realloc ：从内存可变分区重新获取内存缓冲区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Realloc   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvOldMem,   
    size_t stNewByteSize   
);  
```  
  
  
### 描述：
  
该接口用来重新获得一个内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：原先分配的内存。  
- stNewByteSize ：新的分段大小。  
  
### 返回值：
  
成功返回新分配的缓冲区首地址；失败返回NULL(0)，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
- ERROR_REGION_NOMEM ：没有内存可供分配。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    while (1)   
    {   
        pvBlockTmp = Lw_Region_Get(_G_hMyRegion, BLOCK_SIZE);   
        if (pvBlockTmp != LW_NULL) /*从内存可变分区获取内存缓冲区*/   
        {   
            pvBlockTable[i] = pvBlockTmp;   
            fprintf(stdout, "get block successfully, count = %d.n", i);   
        }   
        else {   
            fprintf(stderr, "get block failed, count = %d.n", i);   
            break;   
        }   
        pvBlockTmp = Lw_Region_Realloc(_G_hMyRegion, pvBlockTmp,512); /* 从内存可变分区重新获取内存缓冲区*/   
        if (pvBlockTmp != LW_NULL)   
        {   
            fprintf(stdout,"fun Lw_Region_Realloc successfullyn");   
        }   
        i++;   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Put ：释放指定内存缓冲区到内存可变分区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Put   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvSegmentData,   
);  
```  
  
### 描述：
  
该接口用来释放指定的内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：分段指针。  
  
### 返回值：
  
成功返回NULL，失败返回未释放的分段地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_NULL ：控制块错误。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    for (i = 0; i< BLOCK_CNT; i++)   
    {   
        pvBlockTmp = pvBlockTable[i];   
        if (pvBlockTmp != LW_NULL)   
        {   
            pvBlockTmp = Lw_Region_Put(_G_hMyRegion, pvBlockTmp); /*释放指定内存缓冲区到内存可变分区*/   
            if (pvBlockTmp != LW_NULL)   
            {   
                fprintf(stderr, "block%d put failed.n", i);   
            }   
        }   
        else {   
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Give ：释放指定内存缓冲区到内存可变分区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Give   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvSegmentData,   
);  
```  
  
### 描述：
  
该接口用来释放指定的内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：分段指针。  
  
### 返回值：
  
成功返回NULL，失败返回未释放的分段地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_NULL ：控制块错误。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    for (i = 0; i< BLOCK_CNT; i++)   
    {   
        pvBlockTmp = pvBlockTable[i];   
        if (pvBlockTmp != LW_NULL)   
        {   
            pvBlockTmp = Lw_Region_Give(_G_hMyRegion, pvBlockTmp); /*释放指定内存缓冲区到内存可变分区*/   
            if (pvBlockTmp != LW_NULL)   
            {   
                fprintf(stderr, "block%d give failed.n", i);   
            }   
        } else {   
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Free ：释放指定内存缓冲区到内存可变分区
  
### 函数原型：
  
```c  
PVOID Lw_Region_Free   
(   
    LW_OBJECT_ID ulId,   
    PVOID pvSegmentData,   
);  
```  
  
### 描述：
  
该接口用来释放指定的内存缓存区。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pvMem ：分段指针。  
  
### 返回值：
  
成功返回NULL，失败返回未释放的分段地址，并置相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断。  
- ERROR_REGION_NULL ：控制块错误。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    // ……   
    for (i = 0; i< BLOCK_CNT; i++)   
    {   
        pvBlockTmp = pvBlockTable[i];   
        if (pvBlockTmp != LW_NULL)  
        {   
            pvBlockTmp = Lw_Region_Free(_G_hMyRegion, pvBlockTmp); /*释放指定内存缓冲区到内存可变分区*/   
            if (pvBlockTmp != LW_NULL)   
            {   
                fprintf(stderr, "block%d free failed.n", i);   
            }   
        }   
        else {   
            break;   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Status ：查询内存可变分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Region_Status   
(  
    LW_OBJECT_ID ulId,   
    size_t*pstByteSize,   
    ULONG*pulSegmentCounter,   
    size_t*pstUsedByteSize,   
    size_t*pstFreeByteSize,   
    size_t*pstMaxUsedByteSize   
);  
```  
  
### 描述：
  
该接口用来查询指定可变内存分区的信息。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pstByteSize ：REGION 大小 可以为 NULL。  
- pulSegmentCounter ：分段数量 可以为 NULL。  
- pstUsedByteSize ：使用的字节数 可以为 NULL。  
- pstFreeByteSize ：空闲的字节数 可以为 NULL。  
- pstMaxUsedByteSize ：使用峰值字节数 可以为 NULL。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    ULONG SegmentCounter;   
    size_t ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError=Lw_Region_Status(_G_hMyRegion,&ByteSize, &SegmentCounter,&UsedByteSize, &FreeByteSize,&MaxUsedByteSize); /* 查询内存可变分区的信息*/   
    if(ulError == 0)   
    {   
        printf("region ByteSize :%zdn", ByteSize);   
        printf("region SegmentCounter :%ldn", SegmentCounter);   
        printf("region UsedByteSize :%zdn", UsedByteSize);   
        printf("region FreeByteSize :%zdn", ByteSize);   
        printf("region MaxUsedByteSize :%zdn", MaxUsedByteSize);  
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Info ：查询内存可变分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Region_Info   
(   
    LW_OBJECT_ID ulId,   
    size_t*pstByteSize,   
    ULONG*pulSegmentCounter,   
    size_t*pstUsedByteSize,   
    size_t*pstFreeByteSize,   
    size_t*pstMaxUsedByteSize   
);  
```  
  
### 描述：
  
该接口用来查询指定可变内存分区的信息。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pstByteSize ：REGION 大小 可以为 NULL。  
- pulSegmentCounter ：分段数量 可以为 NULL。  
- pstUsedByteSize ：使用的字节数 可以为 NULL。  
- pstFreeByteSize ：空闲的字节数 可以为 NULL。  
- pstMaxUsedByteSize ：使用峰值字节数 可以为 NULL。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- RROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    ULONG SegmentCounter;   
    size_t ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_S IZE, LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError=Lw_Region_Info(_G_hMyRegion,&ByteSize,&SegmentCounter,&UsedByteSize, &FreeByteSize,&MaxUsedByteSize); /* 查询内存可变分区的信息*/   
    if(ulError == 0)   
    {   
        printf("region ByteSize :%zdn", ByteSize);   
        printf("region SegmentCounter :%ldn", SegmentCounter);   
        printf("region UsedByteSize :%zdn", UsedByteSize);  
        printf("region FreeByteSize :%zdn", ByteSize);  
        printf("region MaxUsedByteSize :%zdn", MaxUsedByteSize);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_StatusEx ：查询内存可变分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Region_StatusEx   
(   
    LW_OBJECT_ID ulId,   
    size_t*pstByteSize,   
    ULONG*pulSegmentCounter,   
    size_t*pstUsedByteSize,   
    size_t*pstFreeByteSize,   
    size_t*pstMaxUsedByteSize,   
    PLW_CLASS_SEGMENT psegmentList[],   
    INT iMaxCounter   
);  
```  
  
### 描述：
  
该接口用来查询指定可变内存分区的信息。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pstByteSize ：REGION 大小 可以为 NULL。  
- pulSegmentCounter ：分段数量 可以为 NULL。  
- pstUsedByteSize ：使用的字节数 可以为 NULL。  
- pstFreeByteSize ：空闲的字节数 可以为 NULL。  
- pstMaxUsedByteSize ：使用峰值字节数 可以为 NULL。  
- psegmentList ：分段头地址表 可以为 NULL。  
- iMaxCounter ：分段头地址表最多可以保存的数量  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    INT a = 0;   
    ULONG SegmentCounter;   
    size_t ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;   
    PLW_CLASS_SEGMENT memList[5] = {NULL};  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError=Lw_Region_StatusEx(_G_hMyRegion,&ByteSize,&SegmentCounter,&UsedByteSi ze, &FreeByteSize, &MaxUsedByteSize, memList, 5); /*查询内存可变分区的信息*/   
    if(ulError == 0)   
    {   
        printf("region ByteSize :%zdn", ByteSize);   
        printf("region SegmentCounter :%ldn", SegmentCounter);   
        printf("region UsedByteSize :%zdn", UsedByteSize);   
        printf("region FreeByteSize :%zdn", ByteSize);   
        printf("region MaxUsedByteSize :%zdn", MaxUsedByteSize);   
        for(a = 0; ((i< 5) && (memList[a] != NULL)); a++)   
        {   
            printf("memList %d SEGMENT_stByteSize :%zdn", a, memList[a]->SEGMENT_stByteSize);   
            printf("memList %d SEGMENT_stMagic :%zdn", a, memList[a]->SEGMENT_stMagic);   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_InfoEx ：查询内存可变分区的信息
  
### 函数原型：
  
```c  
ULONG Lw_Region_InfoEx   
(   
    LW_OBJECT_ID ulId,   
    size_t*pstByteSize,   
    ULONG*pulSegmentCounter,   
    size_t*pstUsedByteSize,   
    size_t*pstFreeByteSize,   
    size_t*pstMaxUsedByteSize,   
    PLW_CLASS_SEGMENT psegmentList[],   
    INT iMaxCounter   
);  
```  
  
### 描述：
  
该接口用来查询指定可变内存分区的信息。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pstByteSize ：REGION 大小 可以为 NULL。  
- pulSegmentCounter ：分段数量 可以为 NULL。  
- pstUsedByteSize ：使用的字节数 可以为 NULL。  
- pstFreeByteSize ：空闲的字节数 可以为 NULL。  
- pstMaxUsedByteSize ：使用峰值字节数 可以为 NULL。  
- psegmentList ：分段头地址表 可以为 NULL。  
- iMaxCounter ：分段头地址表最多可以保存的数量。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;   
    INT a = 0;   
    ULONG SegmentCounter;   
    size_t ByteSize, UsedByteSize, FreeByteSize, MaxUsedByteSize;   
    PLW_CLASS_SEGMENT memList[5] = {NULL};  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError=Lw_Region_InfoEx(_G_hMyRegion,&ByteSize,&SegmentCounter,&UsedByteSiz, &FreeByteSize, &MaxUsedByteSize, memList, 5); /* 查询内存可变分区的信息*/   
    if(ulError == 0)   
    {   
        printf("region ByteSize :%zdn", ByteSize);   
        printf("region SegmentCounter :%ldn", SegmentCounter);   
        printf("region UsedByteSize :%zdn", UsedByteSize);   
        printf("region FreeByteSize :%zdn", ByteSize);   
        printf("region MaxUsedByteSize :%zdn", MaxUsedByteSize);   
        for(a = 0; ((i< 5) && (memList[a] != NULL)); a++)   
        {   
            printf("memList %d SEGMENT_stByteSize :%zdn", a, memList[a]->SEGMENT_stByteSize);   
            printf("memList %d SEGMENT_stMagic :%zdn", a, memList[a]->SEGMENT_stMagic);   
        }   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_GetMax ：获取可变内存分区最大空闲区域大小
  
### 函数原型：
  
```c  
ULONG Lw_Region_GetMax   
(   
    LW_OBJECT_HANDLE ulId,   
    size_t*pstMaxFreeSize   
);  
```  
  
### 描述：
  
该接口用来获得一个内存堆最大空闲区域大小。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pstMaxFreeSize ：最大内存区域大小。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError = Lw_Region_GetMax(_G_hMyRegion,&max); /*获取可变内存分区最大空闲区域大小*/   
    if(ulError == 0)   
    {   
        printf("have access to max mem:%zdn", max);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_GetName ：获取可变内存分区的名字
  
### 函数原型：
  
```c  
ULONG Lw_Region_GetMax   
(   
    LW_OBJECT_HANDLE ulId,   
    PCHAR pcName   
);  
```  
  
### 描述：
  
该接口用来获得内存可变分区的名字。  
  
### 参数：
  
- ulId ：REGION 句柄。  
- pcName ：存放内存区域名字的缓冲区。  
  
### 返回值：
  
成功返回0；失败返回相应的错误码。  
  
### 错误码：
  
- ERROR_KERNEL_IN_ISR ：系统处于中断中。  
- ERROR_KERNEL_PNAME_NULL ：名字指针为 NULL。  
- ERROR_KERNEL_HANDLE_NULL ：句柄出错。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_SIZ E,LW_OPTION_DEFAULT,LW_NULL); /*创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    ulError=Lw_Region_GetName(_G_hMyRegion,name); /* 获取可变内存分区的名字*/   
    if(ulError==0)   
    {   
        printf("regoin name:%sn",name);   
    }   
    // ……   
    return (0);   
}  
```  
  
## Lw_Region_Show ：显示指定内存池信息
  
### 函数原型：
  
```c  
VOID Lw_Region_Show   
(   
    LW_OBJECT_HANDLE ulId   
);  
```  
  
### 描述：
  
该接口用来显示指定内存池的相关信息，不可在中断中使用。  
  
### 参数： 
  
- ulId ：内存池句柄 0: 表示显示内核堆和系统堆信息。  
  
### 返回值：
  
无。  
  
### 错误码：
  
无。  
  
### 样例：
  
```c  
#include<stdio.h>  
#include<SylixOS.h>  
#define REGION_SIZE (1024)  
#define BLOCK_SIZE (256)  
#define BLOCK_CNT (REGION_SIZE / BLOCK_SIZE)   
LW_STACK_G_pstackRegionMemory[REGION_SIZE / sizeof(LW_STACK)];   
LW_HANDLE_G_hMyRegion;   
int main(int argc, char*argv[])   
{   
    VOID*pvBlockTable[BLOCK_CNT] = {LW_NULL};   
    VOID*pvBlockTmp;   
    ULONG ulError;   
    INT i = 0;  
    _G_hMyRegion=Lw_Region_Create("my_region",_G_pstackRegionMemory,REGION_S IZE, LW_OPTION_DEFAULT,LW_NULL); /* 创建一个内存可变分区*/   
    if (_G_hMyRegion == LW_HANDLE_INVALID)   
    {   
        fprintf(stderr, "create region failed.n");   
        return (-1);   
    }   
    Lw_Region_Show(_G_hMyRegion); /* 显示指定内存池信息*/   
    // ……   
    return (0);   
}  
```  
  
# 虚拟内存管理编程接口
  
## API_VmmIoRemap：物理 IO 空间指定内存映射到逻辑空间
  
### 函数原型：
  
```c  
PVOID API_VmmIoRemap   
(   
    PVOID pvPhysicalAddr,   
    size_t stSize   
);  
```  
  
  
### 描述：
  
将物理 IO 空间指定内存映射到逻辑空间. (非CACHE)。其最小映射长度为4KB，并且必须保证物理地址的对齐。  
  
### 参数：
  
- pvPhysicalAddr ：物理内存地址  
- stSize ：需要映射的内存大小。  
  
### 返回值：
  
成功返回映射到的逻辑内存地址，失败返回-1并置错误码。  
  
### 错误码：  
  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
- EINVAL ：参数无效。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
int IoRmap(void)   
{   
    // ……   
    vrGPIO_BASE = API_VmmIoRemap((PVOID)rGPIOCON_BASE,1<<12);   
    if(vrGPIO_BASE == NULL)   
    {   
        printk("API_VmmIoRemap is error");   
        return -1;   
    }   
    // ……   
}  
```  
  
## API_VmmIoRemapEx ：物理 IO 空间指定内存映射到逻辑空间
  
### 函数原型：
  
```c  
PVOID API_VmmIoRemapEx   
(   
    PVOID pvPhysicalAddr,   
    size_t stSize,   
    ULONG ulFlags   
);  
```  
  
### 描述：
  
将物理 IO 空间指定内存映射到逻辑空间. (非CACHE)。其最小映射长度为4KB，并且必须保证物理地址的对齐。  
  
### 参数：
  
- pvPhysicalAddr ：物理内存地址  
- stSize ：需要映射的内存大小。  
- ulFlags ：内存属性。  
  
### 返回值：
  
成功返回映射到的逻辑内存地址，失败返回-1并置错误码。  
  
### 错误码：  
  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
- EINVAL ：参数无效。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
int IoRmap(void)   
{   
    // ……   
    vrGPIO_BASE = API_VmmIoRemapEx((PVOID)rGPIOCON_BASE,1<<12,LW_VMM_FLAG_DMA);   
    if(vrGPIO_BASE == NULL)  
    {   
        printk("API_VmmIoRemap is error");   
        return -1;   
    }   
    // ……   
}  
```  
  
## API_VmmIoRemapNocache：物理 IO空间映射到逻辑空间
  
### 函数原型：
  
```c  
PVOID API_VmmIoRemapNocache   
(   
    PVOID pvPhysicalAddr,   
    size_t stSize   
);  
```  
  
### 描述：
  
将物理 IO 空间指定内存映射到逻辑空间. (非CACHE)。其最小映射长度为4KB，并且必须保证物理地址的对齐。  
  
### 参数：
  
- pvPhysicalAddr ：物理内存地址  
- stSize ：需要映射的内存大小。  
  
### 返回值：
  
成功返回映射到的逻辑内存地址，失败返回-1并置错误码。  
  
### 错误码：  
  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
- EINVAL ：参数无效。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
int IoRmap(void)   
{   
    // ……   
    vrGPIO_BASE = API_VmmIoRemapNocache((PVOID)rGPIOCON_BASE,1<<12);   
    if(vrGPIO_BASE == NULL)   
    {   
        printk("API_VmmIoRemapNocache is error");   
        return -1;   
    }   
    // ……   
}  
```  
  
## API_VmmIoUnmap：释放 ioremap 占用的逻辑空间
  
### 函数原型：
  
```c  
VOID API_VmmIoUnmap   
(   
    PVOID pvVirtualAddr   
);  
```  
  
### 描述：
  
释放 ioremap 占用的逻辑空间。  
  
### 参数：
  
- pvVirtualMem ：虚拟地址。  
  
### 返回值：
  
无。  
  
### 错误码：
  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
void module_exit (void)   
{   
    // ……   
    led_init();   
    API_VmmIoUnmap((PVOID)vrGPIO_BASE);   
    unregister_device("/dev/leds");   
    unregister_driver(devno);   
    // ……   
}  
```  
  
## API_VmmMalloc：分配逻辑上连续, 物理可能不连续的内存
  
### 函数原型：
  
```c  
PVOID API_VmmMalloc   
(   
    size_t stSize   
)  
```  
  
### 描述：
  
分配逻辑上连续, 物理可能不连续的内存。  
  
### 参数：
  
- stSize ：需要分配的内存大小。  
  
### 返回值：
  
成功返回虚拟内存首地址，失败返回-1并置错误码。  
  
### 错误码：  
  
- ERROR_VMM_LOW_PHYSICAL_PAGE ：缺少物理页面。  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
- EINVAL ：参数无效。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
typedef struct leds  
{   
    const char*pathname;   
    int brightness;   
    int max_brightness;   
    int flags;   
    LW_DEV_HDR ledsDevhdr;   
}  
*leddrv;   
static int mini2440_led_probe(void)   
{   
    int res = 0;   
    // ……   
    led_drv = API_VmmMalloc(sizeof(struct leds));   
    if(led_drv == NULL)   
    {   
        printk("API_VmmMalloc errorn");   
        return -1;   
    }   
    // ……   
    return 0;   
}  
```  
  
## API_VmmFree：释放连续虚拟内存
  
### 函数原型：
  
```c  
VOID API_VmmFree   
(   
    PVOID pvVirtualMem   
)  
```  
  
### 描述：
  
释放连续虚拟内存。  
  
### 参数：
  
- pvVirtualMem ：虚拟地址。  
  
### 返回值：
  
无。  
  
### 错误码：  
  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
typedef struct leds  
{   
    const char*pathname;   
    int brightness;   
    int max_brightness;   
    int flags;   
    LW_DEV_HDR ledsDevhdr;   
}  
*leddrv;   
static int mini2440_led_probe(void)   
{   
    int res = 0;   
    // ……   
    API_VmmVirtualShow();   
    API_VmmPhysicalShow();  
    // ……   
    return 0;   
}  
```  
  
## API_VmmMallocArea：开辟虚拟空间
  
### 函数原型：
  
```c  
PVOID API_VmmMallocArea   
(   
    size_t stSize,   
    FUNCPTR pfuncFiller,   
    PVOID pvArg   
)  
```  
  
### 描述：
  
仅开辟虚拟空间, 当出现第一次访问时,将通过缺页中断分配物理内存,当缺页中断中无法分配物理页面时, 将收到 SIGSEGV 信号并结束线程。  
  
### 参数：
  
- stSize ：需要分配的内存大小。  
- pfuncFiller ：当出现缺页时, 获取物理分页后的填充函数, 一般为NULL。  
- pvArg ：填充函数参数.。  
  
### 返回值：
  
成功返回虚拟内存首地址，失败返回-1并置位错误码。  
  
### 错误码：
  
- ERROR_KERNEL_LOW_MEMORY ：缺少内存  
- ERROR_VMM_VIRTUAL_PAGE ：虚拟页面错误。  
  
### 样例：
  
```c  
#define__SYLIXOS_KERNEL  
#include<SylixOS.h>  
#include<module.h>  
#include<gjbext.h>  
#include<linux/compat.h>   
typedef struct leds  
{   
    const char*pathname;   
    int brightness;   
    int max_brightness;   
    int flags;   
    LW_DEV_HDR ledsDevhdr;   
}  
*leddrv;   
static int mini2440_led_probe(void)   
{   
    int res = 0;   
    // ……   
    API_VmmAbortShow();   
    // ……   
    return 0;   
}  
```
