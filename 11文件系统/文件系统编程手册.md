[toc]
# 概述

HYSylixOS提供了多种标准的文件系统，方便用户使用，这些文件系统是HYSylixOS内建的，如果需要更多的文件系统，则需要通过内核模块加入。
HYSylixOS的文件系统实际上是一组虚拟的设备驱动，它提供两组API接口，对上符合I/O系统虚拟文件系统（VFS）标准，对下要求设备驱动符合块设备标准。
HYSylixOS文件系统使用I/O系统提供的标准VFS进行挂载，然后通过标准I/O操作函数进行访问，换句话说，操作一个普通文件与操作一个设备文件没有什么区别。
HYSylixOS目前内建的文件系统包括：

- ROOT文件系统；  
- FAT文件系统；    
- YAFFS文件系统。    
    
本文档描述了HYSylixOS的文件系统应用程序编程接口。    
    
# 文件系统编程接口
    
## creat ：创建文件
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT creat    
(    
    CPCHAR cpcName,    
    INT iMode    
);    
```    
    
### 描 述：
    
以指定的权限创建文件，本接口等价与open((PCHAR)cpcName, (O_WRONLY|O_CREAT|    
O_TRUNC), iMode).    
    
### 参 数：
    
- cpcName ：（设备）文件路径。可以是相对路径，也可以是绝对路径。    
- iMode：创建文件的权限设置，可以使用下列宏或连接也可直接使用数字表示文件权限。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|S_IRUSR|0x0100|文件所有者可读|    
|S_IWUSR|0x0080|文件所有者可写|    
|S_IXUSR|0x0040|文件所有者可执行|    
|S_IRWXU|0x01c0|文件所有者可读可写可执行|    
|S_IRGRP|0x0020|文件所有者同组用户可读|    
|S_IWGRP|0x0010|文件所有者同组用户可写|    
|S_IXGRP|0x0008|文件所有者同组用户可执行|    
|S_IRWXG|0x0038|文件所有者同组用户可读可写可执行|    
|S_IROTH|0x0004|其他用户可读|    
|S_IWOTH|0x0002|其他用户可写|    
|S_IXOTH|0x0001|其他用户可执行|    
|S_IRWXO|0x0007|其他用户可读可写可执行|    
    
### 返回值：
    
成功返回创建文件的描述符，是否返回PX_ERROR，并设置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    ret = creat(FILE, 0666);    
    if(ret< 0)    
    {    
        perror("""FILE"" creat errorn");    
        return -1;    
    }    
    ……………    
    return 0;    
}    
```    
    
## open ：打开文件
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT open    
(    
    CPCHAR cpcName,    
    INT iFlag,    
    ...    
);    
```    
    
### 描 述：
    
该接口打开指定的文件（设备）并返回打开文件对应的文件描述符。文件描述符用于I/O模块中的其他接口操作响应的文件。    
    
### 参 数：
    
- cpcName ：打开文件路径（相对或绝对）。    
- iFlag ：打开选项。该参数由一下二进制或构成，必须指定O_RDONLY、O_WRONLY、O_RDWR中的一个。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|O_RDONLY|0x0000|以只读的方式打开|    
|O_WRONLY|0x0001|以只写的方式打开|    
|O_RDWR|0x0002|以读写的方式打开|    
|O_CREAT|0x0200|如果文件不存在，则创建文件，且 open 函数的第三个参数指定文件权限模式|    
|O_TRUNC|0x0400|如果文件存在，而且如果以只写或读写方式成功打开，则将其长度截断为 0|    
|O_APPEND|0x0008|将读写指针追加到文件的尾端|    
|O_EXCL|0x0800|如果指定了 O_CREAT，而文件存在，则出错。如果文件不存在，则创建|    
|O_NONBLOCK|0x4000|以非阻塞的方式打开文件|    
|O_SYNC|0x2000|使每次 write 等待物理 I/O 操作完成，包括由该 write 操作引起的文件属性更 新。|    
|O_DSYNC|0x0020|使每次 write 等待物理 I/O 操作完成，但是如果该写操作并不影响读取刚写入 的数据，则不许等待文件属性被更新|    
|O_NOCTTY|0x8000|如果 cpcName 引用的是终端设备，则不将该设备分配作为此进程的控制终端|    
|O_NOFOLLOW|0x20000|如果 cpcName 引用的是符号链接，则出错|    
|O_CLOEXEC|0x80000|把 FD_CLOEXEC 标志设置为文件描述符标志|    
|O_LARGEFILE|0x100000|打开大文件标志|    
    
以上权限还可以和以下参数组合使用。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|O_CREAT|0x0200|欲打开的文件不存在，则创建。存在不受影响。|    
|O_APPEND|0x0008|读文件时会从文件尾开始移动。写文件时追加|    
|O_TRUNC|0x0002|文件存在，长度截为0|    
    
若iFlag中有O_CREAT则还需要跟参数INT iMode，IMode宏设置参见creat接口。    
    
### 返回值：
    
成功返回相应的文件描述符，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
EEXIST ：文件已存在。    
EIO ：打开文件过程出错。    
EISDIR ：打开的文件是目录。    
ENAMETOOLONG ：路径名太长。    
ENFILE ：系统中存在太多消息队列。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
ENXIO ：打开的文件为特殊字符或块文件。    
EROFS ：文件为只读类型。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int file = 0;    
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
     ……    
    return 0;    
}    
```    
    
## open64 ：打开文件
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT open64    
(    
    CPCHAR cpcName,    
    INT iFlag,    
    ...    
);    
```    
    
### 描 述：
    
该接口主要针对大文件进行操作（超过2G），使用方式和open相同。    
    
### 参 数：
    
- cpcName ：打开文件路径（相对或绝对）。    
- iFlag ：打开选项。该参数由一下二进制或构成，必须指定O_RDONLY、O_WRONLY、O_RDWR中的一个。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|O_RDONLY|0x0000|以只读的方式打开|    
|O_WRONLY|0x0001|以只写的方式打开|    
|O_RDWR|0x0002|以读写的方式打开|    
    
以上权限还可以和以下参数组合使用。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|O_CREAT|0x0200|欲打开的文件不存在，则创建。存在不受影响。|    
|O_APPEND|0x0008|读文件时会从文件尾开始移动。写文件时追加|    
|O_TRUNC|0x0002|文件存在，长度截为0|    
    
若iFlag中有O_CREAT则还需要跟参数INT iMode，IMode宏设置参见creat接口。    
    
### 返回值：
    
成功返回相应的文件描述符，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int file = 0;    
    file = open64(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## unlink ：删除文件
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT unlink    
(    
    CPCHAR pcName    
);    
```    
    
### 描 述：
    
用于删除指定的文件。    
    
### 参 数：
    
- pcName ：删除文件的文件名。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
EBUSY ：文件正在被操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    ret = creat(FILE, 0666);    
    if(ret< 0)    
    {    
        perror("""FILE"" creat errorn");    
        return -1;    
    }    
    …...    
    ret = unlink(FILE);    
    if(ret != 0)    
    {    
        printf("func unlink errorn");    
        return PX_ERROR;    
    }    
    …...    
    return 0;    
}    
```    
    
## rename ：对文件进行重命名
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT rename    
(    
    CPCHAR pcOldName,    
    CPCHAR pcNewName    
);    
```    
    
### 描 述：
    
对存在的文件（或设备）进行重命名。要求原文件必须存在，否则出错。    
    
### 参 数：
    
- pcOldName ：需要重命名的文件名    
- pcNewName：新的文件名    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
ENFILE ：打开文件数量超出限制。    
ENAMETOOLONG ：路径名太长。    
EXDEV ：指向路径不属于文件系统。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<gjbext.h>    
#define FILE    "HYSylixOS_file1"      
#define RENAME  "HYSYlixOS_file2"    
int main (int argc, char**argv)    
{    
    int i = 0;    
    int ret = 0;    
    int file = 0;    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = rename(FILE, RENAME);    
    if(ret != 0)    
    {    
        perror("func rename errorn");    
        return PX_ERROR;    
    }    
    ……    
    return 0;    
}    
```    
    
##close ：关闭文件
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT close    
(    
    INT iFd    
);    
```    
    
### 描 述：
    
该接口用于关闭指定的文件，释放文件的描述符。    
    
### 参 数：
    
- iFd ：需要关闭的文件描述符。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int file = 0;    
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = close(file);    
    if(ret != 0)    
    {    
        perror("close file errorn");    
    }    
    return 0;    
}    
```    
    
## read ：对文件进行读操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t read    
(    
    INT iFd,    
    PVOID pvBuffer,    
    size_t stMaxBytes    
);    
```    
    
### 描 述：
    
该接口将试图从iFd指定的（设备）文件中读取stMaxBytes个字节存入buf只写的缓存区中。如果stMaxBytes等于0且read操作未发生错误则read接口返回0。    
    
### 参 数：
    
- iFd ：要读取文件的描述符。    
- pvBuffer ：存放读入内容的缓存区，有接口调用者分配空间。    
- stMaxBytes ：要读取的字符个数，以字节为单位。    
    
### 返回值：
    
成功返回实际读取的字节数，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。。    
ENOSYS ：函数不支持此操作。    
ERROR_IOS_FILE_READ_PROTECTED ：文件读保护    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
EBADF ：句柄无效。    
EIO ：打开文件过程出错。    
EISDIR ：打开的文件是目录。    
ENODEV ：文件描述符不支持read操作。    
    
### 样 例：
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char buf[1024] = {0};    
    file = open(FILE, O_RDWR|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = read(file, buf, sizeof(buf));    
    if(ret< 0)    
    {    
        perror("read data errorn");    
        return PX_ERROR;    
    }    
    printf("%sn", buf);    
    close(file);    
    return 0;    
}    
```    
    
## pread ：对文件进行读操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t pread    
(    
    INT iFd, PVOID pvBuffer,    
    size_t stMaxBytes,    
    off_t oftPos    
);    
```    
    
### 描 述：
    
从文件和设备指定偏移量读取数据，且不会改变文件的当前偏移量。    
    
### 参 数：
    
- iFd ：要读取文件的描述符。    
- pvBuffer ：存放读入内容的缓存区，有接口调用者分配空间。    
- stMaxBytes ：要读取的字符个数，以字节为单位。    
- oftPos ：指定位置。    
    
### 返回值：
    
成功返回实际读取的字节数，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：函数不支持此操作。    
ERROR_IOS_FILE_READ_PROTECTED ：文件读保护。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char buf[1024] = {0};    
    file = open(FILE, O_RDWR|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = pread(file, buf, sizeof(buf), 0);    
    if(ret< 0)    
    {    
        perror("read data errorn");    
        return PX_ERROR;    
    }    
    printf("%sn", buf);    
    close(file);    
    return 0;    
}    
```    
    
##pread64 ：对文件进行读操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t pread64    
(    
    INT iFd,    
    PVOID pvBuffer,    
    size_t stMaxBytes,    
    off64_t oftPo    
);    
```    
    
### 描 述：
    
从文件和设备指定偏移量读取数据，且不会改变文件的当前偏移量，与pread接口功能一样。    
    
### 参 数：
    
- iFd ：要读取文件的描述符。    
- pvBuffer ：存放读入内容的缓存区，有接口调用者分配空间。    
- stMaxBytes ：要读取的字符个数，以字节为单位。    
- oftPos ：指定位置。    
    
### 返回值：
    
成功返回实际读取的字节数，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：函数不支持此操作。    
ERROR_IOS_FILE_READ_PROTECTED ：文件读保护。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char buf[1024] = {0};    
    file = open64(FILE, O_RDWR|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = pread64(file, buf, sizeof(buf), 0);    
    if(ret< 0)    
    {    
        perror("read data errorn");    
        return PX_ERROR;    
    }    
    printf("%sn", buf);    
    close(file); return 0;    
}    
```    
    
##write ：对文件进行写操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t write    
(    
    INT iFd,    
    CPVOID pvBuffer,    
    size_t stNBytes    
);    
```    
    
### 描 述：
    
该接口试图将pvBuffer指向的缓存区中的stNBytes个字节写入iFd关联的（设备）文件中。对于常规文件或支持lseek操作的文件，write接口将从iFd关联的文件偏移offset的位置开始写入，对于不支持lseek操作的设备而言，write接口将从当前位置写入。如果stNBytes等于0且write操作未发生错误则write接口将返回0。    
    
### 参 数：
    
- iFd ：文件描述符。    
- pvBuffer ：存放内容的缓冲区，由调用者分配空间。    
- stNBytes ：要写入的字节数。    
    
### 返回值：
    
成功返回实际写入字符的个数，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EWRPROTECT ：文件写保护。    
ENOSYS ：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
EBADF ：句柄无效。    
EIO ：打开文件过程出错。    
ENODEV ：文件描述符不支持write操作。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char*buff = "hello HYSylixOS";    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = write(file, buff, strlen(buff));    
    if(ret != strlen(buff))    
    {    
        perror("pwrite data errorn");    
        return -1;    
    }    
    ……    
    close(file); return 0;    
}    
```    
    
    
## pwrite ：对文件进行写操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t pwrite    
(    
    INT iFd,    
    CPVOID pvBuffer,    
    size_t stNBytes,    
    off_t oftPos    
);    
```    
    
### 描 述：
    
从文件和设备指定偏移量读取数据，且不会改变文件的当前偏移量。    
    
### 参 数：
    
- iFd ：要写入文件的描述符。    
- pvBuffer ：存放内容的缓冲区，由调用者分配空间。    
- stNBytes ：要写入的字节数，以字节为单位。    
- oftPos ：指定位置。    
    
### 返回值：
    
成功返回实际写入字符的个数，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EWRPROTECT ：文件写保护。    
ENOSYS ：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char*buff = "hello HYSylixOS";    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = pwrite(file, buff, strlen(buff), 0);    
    if(ret != strlen(buff))    
    {    
        perror("pwrite data errorn");    
        return -1;    
    }    
    ……    
    close(file);    
    return 0;    
}    
```    
    
## pwrite64 ：对文件进行写操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t pwrite64    
(    
    INT iFd,    
    CPVOID pvBuffer,    
    size_t stNBytes,    
    off64_t oftPos    
);    
```    
    
### 描 述：
    
从文件和设备指定偏移量读取数据，且不会改变文件的当前偏移量，与pwrite接口功能一样。    
    
### 参 数：
    
- iFd ：要写入文件的描述符。    
- pvBuffer ：存放内容的缓冲区，由调用者分配空间。    
- stNBytes ：要写入的字节数，以字节为单位。    
- oftPos ：指定位置。    
    
### 返回值：
    
成功返回实际写入字符的个数，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EWRPROTECT ：文件写保护。    
ENOSYS ：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char*buff = "hello HYSylixOS";    
    file = open64(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
        }    
        ……    
        ret = pwrite64(file, buff, strlen(buff), 0);    
        if(ret != strlen(buff))    
        {    
            perror("pwrite data errorn");    
            return -1;    
        }    
        ……    
        close(file);    
        return 0;    
}    
```    
    
## ioctl ：对文件进行操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT ioctl    
(    
    INT iFd,    
    INT iFunction,    
    ...    
);    
```    
    
### 描 述：
    
该接口用于操作文件和设备的一些特性。    
    
### 参 数：
    
- iFd ：文件（设备）的文件描述符。    
- iFunction和… ：执行操作的文件（设备）解释和执行。对文件常用的操作有：    
    
|权限宏定义|解释|    
|---|---|    
|FIONBIO|set non-blocking I/O;|    
|FIONMSGS|return num msgs in pipe|    
|FIOGETNAME|return file name in arg|    
|FIOGETOPTIONS|get options|    
|FIOSETOPTIONS|set options|    
|FIOISATTY|is a tty|    
|FIOSYNC|将文件缓冲写入磁盘|    
|FIOPROTOHOOK|specify protocol hook routine|    
|FIOPROTOARG|specify protocol argument|    
|FIORBUFSET|alter the size of read buffer|    
|FIOWBUFSET|alter the size of write buffer|    
|FIORFLUSH|flush any chars in read buffers|    
|FIOWFLUSH|flush any chars in write buffers|    
|FIOSELECT|wake up process in select on I/O|    
|FIOUNSELECT|wake up process in select on I/O|    
|FIONFREE|get free byte count on device|    
|FIOTRIM|ATA TRIM command|    
|FIOSYNCMETA|sync range sector to disk|    
|FIOLABELGET|get volume label|    
|FIOLABELSET|set volume label|    
|FIOATTRIBSET|set file attribute|    
|FIOCONTIG|allocate contiguous space|    
|FIOREADDIR|读取一个以打开的目录|    
|FIOFSTATGET|get file status info|    
|FIOUNMOUNT|unmount disk volume|    
|FIONCONTIG|get size of max contig area on dev|    
|FIOTRUNC|缩减或扩展文件长度|    
|FIOGETFL|get file mode, like fcntl(F_GETFL)|    
|FIOTIMESET|change times on a file for utime()|    
|FIOFSTATFSGET|get file status info 64bit|    
|FIOFSTATGET64|move file, ala mv, (mv not rename)|    
|FIODATASYNC|将文件缓存写入磁盘(数据部分)|    
|FIOSETFL|set file mode, like fcntl(F_SETFL)|    
|FIOGETCC|get tty ctl char table|    
|FIOSETCC|set tty ctl char table|    
|FIOGETLK|get a lockf|    
|FIOSETLK|set a lockf|    
|FIOSETLKW|set a lockf (with blocking)|    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
EIO ：打开文件过程出错。    
ENODEV ：文件描述符不支持ioctl操作。    
ENXIO ： 对设备驱动而言，参数有效，只是不能被一些特殊子设备执行。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    char*buff = "hello HYSylixOS";    
    int ctl ;    
    file = open64(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ctl = 5;    
    ret = ioctl(file, FIOTRUNC, (LONG)&ctl);    
    if(ret == PX_ERROR)    
    {    
        perror("ioctl FIOTRUNC errorn");    
    }    
    ctl = 0;    
    ret = ioctl(file, FIOSEEK, (LONG)&ctl);    
    if(ret == PX_ERROR)    
    {    
        perror("ioctl FIOTRUNC errorn");    
    }    
    ……    
    close(file); return 0;    
}    
```    
    
## lseek ：移动文件读写位置
    
### 函数原型：
    
```c    
#include<stdio.h>    
off_t lseek    
(    
    INT iFd,    
    off_t oftOffset,    
    INT iWhence    
);    
```    
    
    
### 描 述：
    
该接口用于设置文件描述符fildes关联的文件的文件偏移位置。lseek允许设置文件偏移超过文件大小，如果设置的文件偏移超过文件，则以0填充扩展的区域，只有再次对文件进行写操作，才会将偏移填充的0写到文件0。    
    
### 参 数：
    
- iFd ：文件描述符。    
- oftOffset ：相对应方向iWhence的偏移。    
- iWhence ：设置文件偏移的基地址。    
    
|宏定义|解释|    
|---|---|    
|SEEK_SET|相对与文件头开始偏移|    
|SEEK_CUR|相对与当前位置开始偏移|    
|SEEK_END|相对与文件尾开始偏移|    
    
### 返回值：
    
成功返回文件偏移后的读写位置，失败返回PX_ERROR，并设置相应的错误码    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：文件描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
EBADF ：句柄无效。    
EOVERFLOW ：文件编译不能使用off_t类型表示。    
ESPIPE ：与文件关联的是管道、套接字或FIFO。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = lseek(file, 0, SEEK_END); /* 获取文件长度*/    
    if(ret == PX_ERROR)    
    {    
        perror("lseek SEEK_END errorn");    
        return PX_ERROR;    
    }    
    ……    
    close(file);    
    return 0;    
}    
```    
    
## lseek64 ：移动文件读写位置
    
### 函数原型：
    
```c    
#include<stdio.h>    
off64_t lseek64    
(    
    INT iFd,    
    off64_t oftOffset,    
    INT iWhence    
);    
```    
    
### 描 述：
    
该接口用于设置文件描述符fildes关联的文件的文件偏移位置。lseek64允许设置文件偏移超过文件大小，如果设置的文件偏移超过文件，则以0填充扩展的区域，只有再次对文件进行写操作，才会将偏移填充的0写到文件0。与lseek功能相同。    
    
### 参 数：
    
- iFd ：文件描述符。    
- oftOffset ：相对应方向iWhence的偏移。    
- iWhence ：设置文件偏移的基地址。    
    
|宏定义|解释|    
|---|---|    
|SEEK_SET|相对与文件头开始偏移|    
|SEEK_CUR|相对与当前位置开始偏移|    
|SEEK_END|相对与文件尾开始偏移|    
    
### 返回值：
    
成功返回文件偏移后的读写位置，失败返回PX_ERROR，并设置相应的错误码    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：文件描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    file = open64(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = lseek64(file, 0, SEEK_END); /* 获取文件长度*/    
    if(ret == PX_ERROR)    
    {    
        perror("lseek SEEK_END errorn");    
        return PX_ERROR;    
    }    
    ……    
    close(file);    
    return 0;    
}    
```    
    
## llseek ：移动文件读写位置
    
### 函数原型：
    
```c    
#include<stdio.h>    
off64_t llseek    
(    
    INT iFd,    
    off64_t oftOffset,    
    INT iWhence    
);    
```    
    
### 描 述：
    
该接口用于设置文件描述符fildes关联的文件的文件偏移位置。lseek允许设置文件偏移超过文件大小，如果设置的文件偏移超过文件，则以0填充扩展的区域，只有再次对文件进行写操作，才会将偏移填充的0写到文件0。与lseek功能相同。    
    
### 参 数：
    
- iFd ：文件描述符。    
- oftOffset ：相对应方向iWhence的偏移。    
- iWhence ：设置文件偏移的基地址。    
    
|宏定义|解释|    
|---|---|    
|SEEK_SET|相对与文件头开始偏移|    
|SEEK_CUR|相对与当前位置开始偏移|    
|SEEK_END|相对与文件尾开始偏移|    
    
### 返回值：
    
成功返回文件偏移后的读写位置，失败返回PX_ERROR，并设置相应的错误码    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：文件描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ……    
    ret = llseek(file, 0, SEEK_SET); /* 将文件读写位置置0*/    
    if(ret == PX_ERROR)    
    {    
        perror("lseek SEEK_END errorn");    
        return PX_ERROR;    
    }    
    ……    
    close(file);    
    return 0;    
}    
```    
    
## writev ：对文件进行写操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t writev    
(    
    INT iFd,    
    const struct iovec*piovec,    
    INT iIovcnt    
);    
```    
    
### 描 述：
    
以struct iovec数组对文件进行写操作。struct    
iovec中包含了写数据的起始地址和数据的长度。    
    
### 参 数：
    
- iFd ：文件描述符。    
- piovec ：发送缓冲区列表。    
- iIovcnt ：发送缓冲区列表中缓冲区的个数。    
    
### 返回值：
    
成功返回实际读取的字节数，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
ENOSYS ：驱动程序不支持。    
EWRPROTECT ：文件写保护。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    struct iovec*piovec =NULL;    
    int piovecNum = 5;    
    int i = 0; /** 准备写数据*/    
    piovec = (struct iovec*)malloc(sizeof(struct iovec)* piovecNum);    
    if(piovec == NULL)    
    {    
        perror("func malloc errorn");    
        return -1;    
    }    
    for(i = 0; i< piovecNum; i++)    
    {    
        piovec[i].iov_base = (char*)malloc(sizeof(char)* 20);    
        if(piovec[i].iov_base == NULL)    
        {    
            perror("func malloc errorn");    
            return -1;    
        }     
        memset(piovec[i].iov_base, 0, sizeof(char)* 20);    
        piovec[i].iov_len = 20;    
        strcpy(piovec[i].iov_base, "HYSylixOS systemn");    
    }    
    file = open(FILE, O_WRONLY|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = writev(file, piovec, piovecNum);    
    if(ret< 0)    
    {    
        perror("func writev errorn");    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## readv ：对文件进行读操作
    
### 函数原型：
    
```c    
#include<stdio.h>    
ssize_t readv    
(    
    INT iFd,    
    struct iovec*piovec,    
    INT iIovcnt    
);    
```    
    
### 描 述：
    
以struct iovec数组对文件进行读操作。struct    
iovec中包含了读数据缓冲区的起始地址和缓冲区的大小。    
    
### 参 数：
    
- iFd ：文件描述符。    
- piovec ：接收缓冲区列表。    
- iIovcnt ：接收缓冲区列表中缓冲区的个数。    
    
### 返回值：
    
成功返回实际读取的字节数，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
ENOSYS ：驱动程序不支持。    
ERROR_IOS_FILE_READ_PROTECTED ：文件读保护。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file = 0;    
    struct iovec*piovec =NULL;    
    int piovecNum = 5;    
    int i = 0; /** 准备读数据空间*/    
    piovec = (struct iovec*)malloc(sizeof(struct iovec)* piovecNum);    
    if(piovec == NULL)    
    {    
        perror("func malloc errorn");    
        return -1;    
    }    
    for(i = 0; i< piovecNum; i++)    
    {    
        piovec[i].iov_base = (char*)malloc(sizeof(char)* 20);    
        if(piovec[i].iov_base == NULL)    
        {    
            perror("func malloc errorn");    
            return -1;    
        }    
        memset(piovec[i].iov_base, 0, sizeof(char)* 20);    
        piovec[i].iov_len = 20;    
    }    
    file = open(FILE, O_RDWR|O_CREAT, 0666);    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = readv(file, piovec, piovecNum); /* 读取数据*/    
    if(ret< 0)    
    {    
        perror("readv data errorn");    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## chdir ：改变工作路径
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT chdir    
(    
    CPCHAR pcName    
);    
```    
    
### 描 述：
    
将Name指向的目录设置为当前的工作路径。    
    
### 参 数：
    
- pcName：要设定的工作路径    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ENOTDIR ：路径不存在。    
EBADF ：文件描述符无效。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/    
int main(int arhc ,char* argv[])    
{    
    int res;    
    ……    
    res = chdir("/apps/HYSylixOS_chdir/folder");    
    if(res != 0)    
    {    
        perror("fun chdir errorn");    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## cd ：改变工作路径
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT cd    
(    
    CPCHAR pcName    
);    
```    
    
### 描 述：
    
将Name指向的目录设置为当前的工作路径。与chdir功能相同。    
    
### 参 数：
    
- pcName：要设定的工作路径    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOTDIR ：路径不存在    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接    
ELOOP ：链接文件层数太多。    
ENOTDIR ：路径不存在。    
EBADF ：文件描述符无效。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
int main(int arhc ,char* argv[])    
{    
    int res;    
    ……    
    res = cd("/apps/HYSylixOS_cd/folder");    
    if(res != 0)    
    {    
        perror("fun chdir errorn");    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## fchdir ：改变工作路径
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT fchdir    
(    
    INT iFd    
);    
```    
    
### 描 述：
    
根据文件描述符将文件夹设定为当前工作路径。且文件夹的打开方式需要只读。    
    
### 参 数：
    
- iFd ：文件描述符。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
EACCES ：文件访问失败。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
ENOTDIR ：路径不存在。    
ENAMETOOLONG：文件名字太长。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define DIRNAME "HYSylixOS_dir" /* 文件名宏定义*/    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    DIR *dir;    
    int fd;    
    struct dirent*entry;    
    char wdbuf[1024] = {0};    
    char *wd = NULL;    
    ret = mkdir(DIRNAME , 0666);    
    if(ret != 0)    
    {    
        perror("mkdir creat error");    
        return PX_ERROR;    
    }    
    dir = opendir(DIRNAME); /* 打开相应的目录*/    
    if(dir< 0)    
    {    
        printf("opendir dir errorn");    
        return PX_ERROR;    
    }    
    fd = dirfd(dir); /* 通过DIR 获取目录的描述符*/    
    if(fd< 0)    
    {    
        perror("func dirfd errorn");    
        return PX_ERROR;    
    }    
    ret = fchdir(fd); /* 修改工作路径*/    
    if(ret != 0)    
    {    
        perror("func fchdir errorn");    
        return -1;    
    }    
    wd = getcwd(wdbuf, 1024);    
    if(wd == NULL)    
    {    
        perror("func getcwd errorn"); /* 获取工作路径*/    
        return -1;    
    }    
    printf("pwd :%sn", wdbuf);    
    closedir(dir);    
    return 0;    
}    
```    
    
## getcwd ：获取工作路径
    
### 函数原型：
    
```c    
#include<stdio.h>    
PCHAR getcwd    
(    
    PCHAR pcBuffer,    
    size_t stByteSize    
);    
```    
    
### 描 述：
    
用于获取当前的工作路径。    
    
### 参 数：
    
- pcBuffer ：存放当前工作目录字符串的指针（不能为空）。    
- stByteSize ：存放当前工作字符串的大小。    
    
### 返回值：
    
成功返回当前工作路径的指针，失败返回LW_NULL。    
    
### 错误码：
    
EINVAL：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
int main(int arhc ,char* argv[])    
{    
    int res;    
    char wdbuf[1024] = {0};    
    ……    
    res = cd("/apps/HYSylixOS_cd/folder");    
    if(res != 0)    
    {    
        perror("fun chdir errorn");    
        return -1;    
    }    
    ……    
    wd = getcwd(wdbuf, 1024);    
    if(wd == NULL)    
    {    
        perror("func getcwd errorn"); /* 获取工作路径*/    
        return -1;    
    }    
    return 0;    
}    
```    
    
## getwd ：获取工作路径
    
### 函数原型：
    
```c    
#include<stdio.h>    
PCHAR getwd    
(    
    PCHAR pcName    
);    
```    
    
### 描 述：
    
用于获取当前的工作路径。推荐使用getcwd接口    
    
### 参 数：
    
- pcName ：存放当前工作目录字符串的指针（不能为空）。    
    
### 返回值：
    
成功返回当前工作路径的指针，失败返回LW_NULL。    
    
### 错误码：
    
EINVAL：参数无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
int main(int arhc ,char* argv[])    
{    
    int res;    
    char wdbuf[1024] = {0};    
    ……    
    res = cd("/apps/HYSylixOS_cd/folder");    
    if(res != 0)    
    {    
        perror("fun chdir errorn");    
        return -1;    
    }    
    ……    
    wd = getwd(wdbuf);    
    if(wd == NULL)    
    {    
        perror("func getcwd errorn"); /* 获取工作路径*/    
        return -1;    
    }    
    ……    
    return 0;    
}    
```    
    
## isatty ：判断是否是tty设备
    
### 函数原型：
    
```c    
#include<stdio.h>    
BOOL isatty    
(    
    INT iFd    
);    
```    
    
### 描 述：
    
判断文件描述符是否是tty设备描述符。    
    
### 参 数：
    
- iFd：文件描述符。    
    
### 返回值：
    
是tty设备返回LW_TRUE，不是返回LW_FALSE。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "/dev/ttyS1"    
int main (int argc, char**argv)    
{    
    BOOL ret = 0;    
    int file = 0;    
    file = open(FILE, O_WRONLY );    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = isatty(file);    
    if(ret == LW_TRUE)    
    {    
        printf("""FILE"" is tty devicen");    
    }    
    else    
    {    
        printf("""FILE"" isnot tty devicen");    
    }    
    ……    
    close(file);    
    return 0;    
}    
```    
    
## ttyname ：获取tty设备名
    
### 函数原型：
    
```c    
#include<stdio.h>    
PCHAR ttyname    
(    
    INT iFd    
);    
```    
    
### 描 述：
    
返回终端设备描述符的设备名。    
    
### 参 数：
    
- iFd ：文件描述符。    
    
### 返回值：
    
文件描述符是终端设备则返回终端设备的名字，非终端设备返回LW_NULL。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
ENOTTY ：非中断设备。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "/dev/ttyS1"    
int main (int argc, char**argv)    
{    
    BOOL ret = 0;    
    int file = 0;    
    char*name = NULL;    
    file = open(FILE, O_WRONLY );    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = isatty(file);    
    if(ret == LW_TRUE)    
    {    
        printf("""FILE"" is tty devicen");    
        name = ttyname(file);    
        if(name == NULL)    
        {    
            printf("func ttyname errorn");    
            return -1;    
        }    
        printf("open tty device name is : %sn", name);    
    }    
    else    
    {    
        printf("""FILE"" isnot tty devicen");    
    }    
    close(file);    
    return 0;    
}    
```    
    
## ttyname_r ：获取tty设备名
    
### 函数原型：
    
```c    
#include<stdio.h>    
PCHAR ttyname_r    
(    
    INT iFd,    
    PCHAR pcBuffer,    
    size_t stLen    
);    
```    
    
### 描 述：
    
返回终端设备描述符的设备名。    
    
### 参 数：
    
- iFd ：文件描述符。    
- pcBuffer ：接受终端设备名的缓冲区。    
- stLen ：缓冲区的大小。    
    
### 返回值：
    
文件描述符是终端设备则返回终端设备的名字，非终端设备返回LW_NULL。    
    
### 错误码：
    
EBADF ：文件描述符无效。    
ENOTTY ：非中断设备。    
EINVAL ：参数无效    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "/dev/ttyS1"    
int main (int argc, char**argv)    
{    
    BOOL ret = 0;    
    int file = 0;    
    char name[1024] = {0};     
    char*pname = NULL;    
    file = open(FILE, O_WRONLY );    
    if(file< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = isatty(file);    
    if(ret == LW_TRUE)    
    {    
        printf("""FILE"" is tty devicen");    
        pname = ttyname_r(file, name, sizeof(name));    
        if(pname == NULL)    
        {    
            printf("func ttyname errorn");    
            return -1;    
        }    
        printf("open tty device name is : %sn", name);    
    }    
    else    
    {    
        printf("""FILE"" isnot tty devicen");    
    }    
    close(file);    
    return 0;    
}    
```    
    
## fcntl ：对文件描述符执行指定命令
    
### 函数原型：
    
```c    
#include<fcntl.h>    
INT fcntl    
(    
    INT iFd,    
    INT iCmd,    
    ...    
)    
```    
    
### 描 述：
    
该接口对文件描述符iFd指定的iCmd命令。    
当前支持的命令有F_DUPFD、F_DUPFD_CLOEXEC、F_DUP2FD、F_DUP2FD_CLOEXEC、F_GETFD、F_SETFD、F_GETFL、F_SETFL、F_GETLK、F_SETLK、F_SETLKW    
    
### 参 数：
    
- iFd ：文件描述符。    
- iCmd 和… ：对文件描述符执行的命令和执行命令的参数。    
    
|命令宏定义|解释|    
|---|---|    
|F_DUPFD|复制一个现有的文件描述符，且返回的文件描述符时最小的，与dup接口功能相同|    
|F_DUPFD_CLOEXEC|复制一个现有的文件描述符，且返回的文件描述符时最小的并设置文件的FD_CLOEXEC|    
|F_DUP2FD|复制一个现有的文件描述符，并且可指定复制的文件描述符，与dup2接口功能相同|    
|F_DUP2FD_CLOEXEC|复制一个现有的文件描述符，并且可指定复制的文件描述符并设置文件的FD_CLOEXEC|    
|F_GETFD|获取文件的FD_CLOEXEC|    
|F_SETFD|设置文件的FD_CLOEXEC|    
|F_GETFL|获取文件打开方式|    
|F_SETFL|获取文件打开方式是否阻塞|    
|F_GETLK|获取文件锁定状态|    
|F_SETLK|设置文件锁定状态|    
|F_SETLKW|设置文件锁定状态|    
    
### 返回值：
    
成功返回相应的值，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码： 
    
EBADF ：文件描述符无效。    
ENOSYS ：不支持的命令。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例    
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    int file1 = 0;    
    int file2 = 0;    
    char buf[1024] = {0};    
    char*buff = "hello HYSylixOS";    
    file1 = open(FILE, O_RDWR|O_CREAT|O_TRUNC|O_APPEND, 0666);    
    if(file1< 0)    
    {    
        perror("""FILE""open error");    
        return -1;    
    }    
    ret = write(file1, buff, strlen(buff));    
    if(ret != strlen(buff))    
    {    
        perror("write data errorn");    
        return -1;    
    }    
    file2 = fcntl(file1, F_DUPFD, file2);    
    if(ret< 0)    
    {    
        printf("func dup errorn");    
        return -1;    
    }    
    lseek(file1, 0, SEEK_SET);    
    ret = read(file2, buf, sizeof(buf));    
    if(ret< 0)    
    {    
        perror("read data errorn");    
    }    
    printf("%sn", buf);    
    close(file1);    
    close(file2);    
    return 0;    
}    
```    
    
## cat ：显示指定文件内容
    
### 函数原型：
    
```c    
#include<gjbext.h>    
int cat    
(    
    char*pathname    
)    
```    
    
### 描 述： 
    
存储设备格式化接口。    
    
### 参 数：
    
- fs ：存储设备要格式化的文件系统类型。    
- dev ：存储设备路径。    
    
### 返回值：
    
成功返回-1，失败返回0，并置相应的错误码。    
    
### 错误码： 
    
EACCES ：权限不足。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例    
    
```c    
#include<stdio.h>#include<gjbext.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/    
int main (int argc, char**argv)    
{    
    int ret = 0;     
    int file = 0;     
    char*buff = "hello HYSylixOS";     
    file = open(FILE, O_WRONLY|O_CREAT, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = write(file, buff, strlen(buff));     
    if(ret != strlen(buff))     
    {     
        perror("write data errorn"); return -1;     
    }     
    close(file);     
    cat(FILE);     
    return 0;     
}    
```    
    
## dup ：复制文件描述符
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT dup     
(     
    INT iFd     
);    
```    
    
### 描 述：
    
复制一个现有的文件描述符，且返回的文件描述符时最小的。新的文件描述符和原先的文件描述符共享同一个文件属性标志（读、写、追加）以及同一个文件当前指针（文件偏移量）。    
    
### 参 数：
    
iFd：需要复制的文件描述。    
    
### 返回值：
    
成功返回新文件描述符，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOTSUP ：不支持的操作。    
EBADF ：文件描述符无效。    
EBUSY ：文件正在被操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file1 = 0;     
    int file2 = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    file1 = open(FILE, O_RDWR|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file1< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    file2 = dup(file1);     
    if(file2< 0)     
    {     
        printf("func dup errorn");     
        return -1;     
    }     
    ……     
    close(file1);     
    close(file2);     
    return 0;     
}    
```    
    
## dup2 ：复制文件描述符
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT dup2     
(     
    INT iFd1,     
    INT iFd2     
);    
```    
    
### 描 述：
    
复制一个现有的文件描述符，并且可指定复制的文件描述符。新的文件描述符和原先的文件描述符共享同一个文件属性标志（读、写、追加）以及同一个文件当前指针（文件偏移量）。如果iFd2 已经打开，则先将其关闭。注意，HYSylixOS 内核目前并不支持 iFd1 等于 iFd2的情况。    
    
### 参 数：
    
- iFd1：需要复制的文件描述。    
- iFd2：指定新的文件描述符。    
    
### 返回值：
    
成功返回新文件描述符，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOTSUP ：不支持的操作。    
EBADF ：文件描述符无效。    
EBUSY ：文件正在被操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file1 = 0;     
    int file2 = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    file1 = open(FILE, O_RDWR|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file1< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    file2 = dup2(file1, file2);     
    if(file2< 0)     
    {     
        printf("func dup errorn");     
        return -1;     
    }     
    ……     
    close(file1);     
    close(file2);     
    return 0;     
}     
```    
    
## diskformat 格式化指定设备
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT diskformat     
(     
    CPCHAR pcDevName     
);    
```    
    
### 描 述：
    
格式化指定的设备，NULL表示格式化当前设备（x86环境测试）。    
    
### 参 数：
    
- pcDevName：设备名。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
EACCES ：文件访问失败。    
EBADF ：描述符无效。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define MOUNT_1 "/media/hdd0" /* 设备名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ……     
    ret = diskformat(MOUNT_1);     
    if(ret != 0)     
    {     
        perror("func format errorn");     
        return ret;     
    }     
    ……     
    return (0);     
}    
```    
    
## diskinit 初始化指定磁盘
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT diskinit     
(     
    CPCHAR pcDevName     
);    
```    
    
### 描 述：
    
初始化指定的磁盘设备，NULL表示初始化当前设备    
    
### 参 数：
    
- pcDevName：设备名。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
EBADF ：描述符无效。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
    
```    
    
## utime ：修改文件的时间
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT utime     
(     
    CPCHAR pcFile,     
    const struct utimbuf*utimbNew     
);    
```    
    
### 描 述：
    
通过文件描述符修改文件的时间，其中包括文件的访问时间和修改时间。    
    
### 参 数：
    
pcFile ：文件名。    
utimbNew ：修改时间。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct utimbuf tm;     
    file = creat(FILE, 0666);     
    if(file< 0)     
    {     
        printf("creat errorn");     
        return -1;     
    }     
    ……     
    tm.actime = timelocal(&tm.actime); /* 设置访问时间*/     
    tm.modtime = timelocal(&tm.modtime); /* 设置修改时间*/     
    ret = utime(FILE,&tm);     
    if(ret != 0)     
    {     
        printf("func utime errorn");     
        return -1;     
    }     
    ……     
    close(file);     
    return 0;     
}    
```    
    
## access ：判断文件权限
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT access     
(     
    CPCHAR pcName,     
    INT iMode     
);    
```    
    
### 描 述：
    
判断文件对于创建者的读写权限。    
    
### 参 数：
    
- pcName ：文件名。    
- iMode ：检测文件的权限。    
    
|权限宏|解释|    
|---|---|    
|R_OK|创建者读权限|    
|W_OK|创建者写权限|    
|X_OK|创建者执行权限|    
    
### 返回值：
    
检测的权限运行返回0，检测的权限不允许或发生错误返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
EACCES ：文件访问失败。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    file = creat(FILE, 0642);     
    if(file< 0)     
    {     
        printf("creat errorn");     
        return -1;     
    }     
    ret = access(FILE, R_OK);     
    if(ret == 0)     
    {     
        printf("""FILE"" is read okn");     
    }     
    ret = access(FILE, W_OK);     
    if(ret == 0)     
    {     
        printf("""FILE"" is write okn");     
    }     
    ret = access(FILE, X_OK);     
    if(ret == 0)     
    {     
        printf("""FILE"" is exe okn");     
    }     
    close(file);     
    return 0;     
}    
```    
    
## fstat ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fstat     
(     
    INT iFd,     
    struct stat*pstat     
);    
```    
    
### 描 述：
    
通过文件描述符获取文件的相关信息。    
    
### 参 数：
    
- iFd ：文件描述符。    
- pstat ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat st;     
    file = open(FILE, O_WRONLY|O_CREAT, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = fstat(file,&st);     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    close(file);     
    return 0;     
 }    
```    
    
## stat ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT stat     
(     
    CPCHAR pcName,     
    struct stat*pstat     
);    
```    
    
### 描 述：
    
通过文件名获取文件的相关信息。    
    
### 参 数：
    
- pcName：文件名。    
- pstat ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
ENAMETOOLONG ：路径名太长。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    struct stat st;     
    ……     
    ret = stat(FILE,&st);     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## lstat ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT lstat     
(     
    CPCHAR pcName,     
    struct stat*pstat     
);    
```    
    
### 描 述：
    
通过文件名获得文件的相关信息(如果是链接文件, 则返回连接文件相关信息)。    
    
### 参 数：
    
- pcName ：文件名    
- pstat ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码： 
    
EFAULT ：地址错误。    
ENOENT ：文件或设备不存在。。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
ERROR_SYSTEM_LOW_MEMORY：SYSTEM 堆缺少内存    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    struct stat st;     
    ……     
    ret = lstat(FILE,&st);     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## fstat64 ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fstat64     
(     
    INT iFd,     
    struct stat64*pstat64     
);    
```    
    
### 描 述：
    
通过文件描述符获取文件的相关信息。    
    
### 参 数：
    
- iFd ：文件描述符。    
- pstat64 ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：文件描述法无效。    
ENOSYS ：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat64 st;     
    file = open(FILE, O_WRONLY|O_CREAT, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = fstat64(file,&st);     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    close(file);     
    return 0;     
}    
```    
    
## stat64 ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT stat64     
(     
    CPCHAR pcName,     
    struct stat64*pstat64     
);    
```    
    
### 描 述：
    
通过文件名获取文件的相关信息。    
    
### 参 数：
    
- pcName ：文件名。    
- pstat64 ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    struct stat64 st;     
    ……     
    ret = stat64(FILE,&st);    
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## lstat64 ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>    
INT lstat64     
(     
    CPCHAR pcName,     
    struct stat64*pstat64     
);    
```    
    
### 描 述：
    
通过文件名获得文件的相关信息。(如果是链接文件, 则返回连接文件相关信息)。    
    
### 参 数：
    
- pcName ：文件名    
- pstat64 ：用于存放文件信息的缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码： 
    
EINVAL ：参数无效。    
EFAULT ：地址错误。    
ENOENT ：文件或设备不存在。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
ERROR_SYSTEM_LOW_MEMORY：SYSTEM 堆缺少内存。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    struct stat64 st;     
    ……     
    ret = lstat64(FILE,&st);;     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }    
    ……     
    return 0;     
}    
```    
    
## fstatfs ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fstatfs     
(     
    INT iFd,     
    struct statfs*pstatfs     
);    
```    
    
### 描 述：
    
通过文件描述符获取文件系统的相关信息。    
    
### 参 数：
    
- iFd：文件描述符。    
- pstatfs：文件系统状态缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat st;     
    file = open(FILE, O_WRONLY|O_CREAT, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = fstatfs(file,&st);;     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    close(file);     
    return 0;     
}    
```    
    
## statfs ：获取文件信息
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT statfs     
(     
    CPCHAR pcName,     
    struct statfs*pstatfs     
);    
```    
    
### 描 述：
    
通过文件名获得文件系统的相关信息。    
    
### 参 数：
    
- pcName：文件名。    
- pstatfs：文件系统状态缓冲区。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    struct stat st;     
    ……     
    ret = stat(FILE,&st);;     
    if(ret != strlen(buff))     
    {     
        perror("func fstat errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## ftruncate ：对文件长度操作
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT ftruncate     
(     
    INT iFd,     
    off_t oftLength     
);    
```    
    
### 描 述：
    
通过文件描述符缩减或扩展文件长度。如果之前的文件长度比length指定的长度大，额外的数据会丢失。如果之前的文件长度比指定的长度小，将会用‘/0’填充增大部分。    
    
### 参 数：
    
- iFd ：文件描述符。    
- oftLength ：文件长度。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
EIO ：打开文件过程出错。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    ret = creat(FILE, 0666);     
    if(ret< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    file = open(FILE, O_WRONLY);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    ret = ftruncate(file, 10);     
    if(ret != 0)     
    {     
        perror("func ftruncate errorn");     
        return -1;     
    }     
    close(file);     
    file = open(FILE, O_RDONLY);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = read(file, buf, sizeof(buf));     
    if(ret< 0)     
    {     
        perror("read data errorn");     
    }     
    printf("%sn", buf);     
    close(file);     
    return 0;     
}    
```    
    
## truncate ：对文件长度进行操作
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT truncate     
(     
    CPCHAR pcName,     
    off_t oftLength     
);    
```    
    
### 描 述：
    
通过文件名缩减或扩展文件长度。如果之前的文件长度比length指定的长度大，额外的数据会丢失。如果之前的文件长度比指定的长度小，将会用‘/0’填充增大部分。    
    
### 参 数：
    
- pcName ：文件名。    
- oftLength ：文件长度。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EIO ：打开文件过程出错。    
EISDIR ：打开的文件是目录。    
ENAMETOOLONG ：路径名太长。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ……     
    ret = truncate(FILE, 10);     
    if(ret != 0)     
    {     
        perror("func ftruncate errorn");     
        return -1;    
    }     
    ……     
    return 0;     
}    
```    
    
## ftruncate64 :对文件长度进行操作
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT ftruncate64     
(     
    INT iFd,     
    off64_t oftLength     
);    
```    
    
### 描 述：
    
通过文件描述符缩减或扩展文件长度。如果之前的文件长度比length指定的长度大，额外的数据会丢失。如果之前的文件长度比指定的长度小，将会用‘/0’填充增大部分。    
    
### 参 数：
    
- iFd ：文件描述符。    
- oftLength ：文件长度。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    ret = creat(FILE, 0666);     
    if(ret< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    file = open(FILE, O_WRONLY); if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    ret = ftruncate(file, 10);     
    if(ret != 0)     
    {     
        perror("func ftruncate errorn");     
        return -1;     
    }     
    close(file);     
    file = open(FILE, O_RDONLY);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ret = read(file, buf, sizeof(buf));     
    if(ret< 0)     
    {     
        perror("read data errorn");    
    }     
    printf("%sn", buf);     
    close(file);     
    return 0;     
}    
```    
    
## truncate64 ：对文件长度进行操作
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT truncate64     
(     
    CPCHAR pcName,     
    off64_t oftLength     
);    
```    
    
### 描 述    
    
通过文件名缩减或扩展文件长度。如果之前的文件长度比length指定的长度大，额外的数据会丢失。如果之前的文件长度比指定的长度小，将会用‘/0’填充增大部分。    
    
### 参 数：
    
- pcName ：文件名。    
- oftLength ：文件长度。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ……     
    ret = truncate64(FILE, 10);     
    if(ret != 0)     
    {     
        perror("func ftruncate errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## sync ：同步IO与磁盘
    
### 函数原型：
    
```c    
#include<stdio.h>     
VOID sync     
(     
    VOID     
);    
```    
    
### 描 述：
    
将系统IO缓冲写入磁盘。    
    
### 参 数：
    
无。    
    
### 返回值：
    
无。    
    
### 错误码：
    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int file = 0;     
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    sync();     
    ret = close(file);     
    if(ret != 0)     
    {     
        perror("close file errorn");     
    }     
    return 0;     
}    
```    
    
## fsync ：同步IO缓冲与磁盘
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fsync     
(     
    INT iFd     
);    
```    
    
### 描 述    
    
将文件描述符对应的文件缓冲写入磁盘。    
    
### 参 数：
    
- iFd ：文件描述符。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int file = 0;     
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    ret = fsync(file);     
    if(ret != 0)     
    {     
        perror("fsync file errorn");     
    }     
    ret = close(file);     
    if(ret != 0)     
    {     
        perror("close file errorn");     
    }     
    return 0;     
}    
```    
    
## fdatasync ：同步IO缓冲与磁盘
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fdatasync     
(     
    INT iFd     
);    
```    
    
### 描 述    
    
将文件描述符对应的文件缓冲数据部分写入磁盘。    
    
### 参 数：
    
- iFd ：文件描述符。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int file = 0;     
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    ret = fdatasync(file);     
    if(ret != 0)     
    {     
        perror("fdatasync file errorn");     
    }     
    ret = close(file);     
    if(ret != 0)    
    {     
        perror("close file errorn");     
    }     
    return 0;     
}    
```    
    
## fchmod ：修改文件访问权限
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fchmod     
(     
    INT iFd,     
    INT iMode     
);    
```    
    
### 描 述：
    
通过文件描述符修改文件的访问权限。    
    
### 参 数：
    
- iFd ：文件描述符。    
- iMode ：文件的访问权限，文件访问权限参加creat接口。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
EACCES ：文件访问失败。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int file = 0;     
    file = open(FILE, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    ret = fchmod(file, 0400);     
    if(ret != 0)     
    {     
        printf("func chmod errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## chmod ：修改文件访问权限
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT chmod     
(     
    CPCHAR pcName,     
    INT iMode     
);    
```    
    
### 描 述：
    
通过文件名修改文件的访问权限。    
    
### 参 数：
    
- pcName ：文件名。    
    
- iMode ：文件的访问权限，文件访问权限参加creat接口。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
EACCES ：文件访问失败。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILE "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int file = 0;     
    ……     
    ret = chmod(FILE, 0400);     
    if(ret != 0)     
    {     
        printf("func chmod errorn");     
        return -1;     
    }     
    ……     
    return 0;     
}    
```    
    
## fchown ：修改文件用户id
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT fchown     
(     
    INT iFd,     
    uid_t uid,     
    gid_t gid     
);    
```    
    
    
### 描 述：
    
通过文件描述符更改文件的用户ID和用户组ID。    
    
### 参 数：
    
iFd：文件描述符。    
uid：用户ID。    
gid：用户组ID。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
EACCES ：文件访问失败。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat stbuf;     
    file = open(FILE, O_CREAT|O_RDWR, 0666);     
    if(file< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    ret = fchown(file, 1, 0); /* 修改用户ID与组ID*/     
    if(ret != 0)     
    {     
        printf("func fchown errorn");     
        return -1;     
    }     
    close(file);     
    memset(&stbuf, 0, sizeof(stbuf));     
    ret = stat(FILE,&stbuf);     
    if(ret != 0)     
    {     
        printf("func stat errorn");     
        return -1;     
    }     
    printf("""FILE"" user id :%un", stbuf.st_uid);     
    printf("""FILE"" group id :%un", stbuf.st_gid);     
    return 0;     
}    
```    
    
## chown ：修改文件用户id
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT chown     
(     
    CPCHAR pcName,     
    uid_t uid,     
    gid_t gid     
);    
```    
    
### 描 述：
    
通过文件名更改文件的用户ID和用户ID。    
    
### 参 数：
    
- pcName ：文件名。    
- uid ：用户ID。    
- gid ：用户组ID。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
EINVAL ：参数无效。    
EACCES ：文件访问失败。    
ENOENT ：文件或设备不存在。    
FAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat stbuf;     
    file = open(FILE, O_CREAT|O_RDWR, 0666);     
    if(file< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1; } ret = chown(file, 1, 0); /* 修改用户ID与组ID*/ i    
        f(ret != 0) { printf("func fchown errorn");     
        return -1;     
    }     
    close(file);     
    memset(&stbuf, 0, sizeof(stbuf));     
    ret = stat(FILE,&stbuf);     
    if(ret != 0)     
    {     
        printf("func stat errorn");     
        return -1;     
    }     
    printf("""FILE"" user id :%un", stbuf.st_uid);     
    printf("""FILE"" group id :%un", stbuf.st_gid);     
    return 0;     
}    
```    
    
## lchown：修改文件用户id
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT lchown     
(     
    CPCHAR pcName,     
    uid_t uid,     
    gid_t gid     
);    
```    
    
### 描 述：
    
通过文件名更改文件的用户ID和用户ID。    
    
### 参 数：
    
- pcName：文件名。    
- uid：用户ID。    
- gid：用户组ID。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    struct stat stbuf;     
    file = open(FILE, O_CREAT|O_RDWR, 0666);     
    if(file< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    ret = lchown(file, 1, 0); /* 修改用户ID与组ID*/     
    if(ret != 0)     
    {    
        printf("func fchown errorn");     
        return -1;     
    }     
    close(file);    
    memset(&stbuf, 0, sizeof(stbuf));     
    ret = stat(FILE,&stbuf);     
    if(ret != 0)     
    {     
        printf("func stat errorn");     
        return -1;     
    }     
    printf("""FILE"" user id :%un", stbuf.st_uid);     
    printf("""FILE"" group id :%un", stbuf.st_gid);     
    return 0;     
}    
```    
    
## mkdir ：创建文件夹
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT mkdir     
(     
    CPCHAR dirname,     
    mode_t mode     
);    
```    
    
### 描 述：
    
用于创建指定的文件夹。    
    
### 参 数：
    
- dirname：文件夹名（可包含路径）。    
    
- mode ：文件夹访问权限，访问权限参见creat接口。    
    
### 返回值：
    
成功返回0，失败返回0，并置相应的错误码    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
ENAMETOOLONG ：路径名太长。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
EEXIST ：目录已存在。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define DIRNAME "HYSylixOS_dir"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ret = mkdir(DIRNAME, 0666);     
    if(ret< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    …...     
    return 0;     
}    
```    
    
## rmdir ：删除文件夹
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT rmdir     
(     
    CPCHAR pathname     
);    
```    
    
### 描 述：
    
用于删除一个已存在的空的目录。    
    
### 参 数：
    
- pathname：需要删除的目录名。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
EBUSY ：文件正在被操作。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
ENAMETOOLONG ：路径名太长。    
ENOTDIR ：文件路径中目录项不是目录。    
ENOENT ：文件或设备不存在。    
EBUSY ：设备资源忙。    
ENOTEMPTY ：目录中包括除”.”和”..”以外的目录项。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define DIRNAME "HYSylixOS_dir"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ret = mkdir(DIRNAME, 0666);     
    if(ret< 0)     
    {     
        perror("""DIRNAME"" creat errorn");     
        return -1;     
    }     
    …...     
    ret = rmdir(DIRNAME);     
    if(ret< 0)     
    {     
        perror("""DIRNAME"" rmdir errorn"); return -1; } return 0;     
}    
```    
    
## dirfd ：获取文件描述符
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT dirfd     
(     
    DIR*pdir     
);    
```    
    
### 描 述：
    
从目录控制块DIR结构中获取目录文件描述符。    
    
### 参 数：
    
- pdir：指向目录控制块的指针。    
    
### 返回值：
    
成功返回目录的文件描述符，失败返回PX_ERROR，并置位相应的错误码。    
    
### 错误码：
    
EINVAL：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```C    
#include<stdio.h>    
#include<string.h>    
#define DIRNAME "HYSylixOS_dir" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    DIR*dir;     
    int fd;     
    struct dirent*entry;     
    char wdbuf[1024] = {0};     
    char*wd = NULL;     
    ret = mkdir(DIRNAME , 0666);     
    if(ret != 0)     
    {     
        perror("mkdir creat error");     
        return PX_ERROR;     
    }     
    dir = opendir(DIRNAME); /* 打开相应的目录*/     
    if(dir< 0)     
    {     
        printf("opendir dir errorn");     
        return PX_ERROR;     
    }     
    fd = dirfd(dir); /* 通过DIR 获取目录的描述符*/     
    if(fd< 0)     
    {     
        perror("func dirfd errorn");     
        return PX_ERROR;     
    }     
    ret = fchdir(fd); /* 修改工作路径*/     
    if(ret != 0)     
    {     
        perror("func fchdir errorn");     
        return -1;     
    }     
    wd = getcwd(wdbuf, 1024);     
    if(wd == NULL)     
    {     
        perror("func getcwd errorn"); /* 获取工作路径*/     
        return -1;     
    }     
    printf("pwd :%sn", wdbuf);     
    closedir(dir);     
    return 0;     
}    
```    
    
## opendir ：打开文件夹
    
### 函数原型：
    
```C    
#include<stdio.h>    
DIR*opendir     
(     
    CPCHAR pathname     
);    
```    
    
### 描 述：
    
打开一个以及存在的目录。    
    
### 参 数：
    
- pathname：目录名。    
    
### 返回值：
    
成功返回目录结构的DIR流，失败返回NULL，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
EBADF ：描述符无效。    
EINVAL ：参数无效。    
ENOSYS ：函数不支持此操作。    
ENOTDIR ：文件或设置不存在。    
ERROR_SYSTEM_LOW_MEMORY ：系统缺少堆内存。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
ENFILE ：打开文件数量超出限制。    
ENOENT ：文件或设备不存在。    
ENOTDIR ：文件路径中目录项不是目录。    
ENOMEM ：内存不足。    
    
### 样 例：
    
```C    
void printdir (void)     
{     
    DIR*dir; struct dirent*entry;     
    dir = opendir("./"); /* 打开文件目录*/     
    if (!dir)     
    {     
        printf("failed to open current directoryn");     
        return ;     
    }     
    while(1)     
    {     
        entry = readdir(dir); /* 读取文件夹下文件*/     
        if(entry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/     
        {     
            printf("dir: %sn", entry->d_name);     
        }     
        else     
        {     
            printf("file: %sn", entry->d_name);     
        }     
    }     
    closedir(dir); /* 关闭文件目录*/     
}    
```    
    
## closedir ：关闭文件夹
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT closedir     
(     
    DIR*dir     
);    
```    
    
### 描 述：
    
用于关闭一个以及打开的目录。    
    
### 参 数：
    
- dir：目录控制块。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：描述符无效。    
ERROR_KERNEL_IN_ISR ：不能在中断中使用。    
ERROR_KERNEL_HANDLE_NULL ：句柄出错。    
ERROR_EVENT_TYPE ：事件类型错误。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
    
### 样 例：
    
```C    
void printdir (void)     
{     
    DIR*dir;     
    struct dirent*entry;     
    dir = opendir("./"); /* 打开文件目录*/     
    if (!dir)     
    {     
        printf("failed to open current directoryn");     
        return ;     
    }     
    while(1){     
        entry = readdir(dir); /* 读取文件夹下文件*/     
        if(entry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/     
        {     
            printf("dir: %sn", entry->d_name);     
        }     
        else {     
            printf("file: %sn", entry->d_name);     
        }     
    }     
    closedir(dir); /* 关闭文件目录*/     
}    
```    
    
## readdir ：读文件夹
    
### 函数原型：
    
```C    
#include<stdio.h>     
struct dirent*readdir     
(     
    DIR*dir     
);    
```    
    
### 描 述：
    
获取一个以及打开目录的单条信息。    
    
### 参 数：
    
- dir ：打开的目录控制块    
    
### 返回值：
    
成功返回获取到的单条目信息指针，失败返回LW_NULL，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
ENOENT ：文件或设备不存在。    
    
### 样 例：
    
```C    
void printdir (void)     
{     
    DIR*dir; struct dirent*entry;     
    dir = opendir("./"); /* 打开文件目录*/     
    if (!dir)     
    {     
        printf("failed to open current directoryn");     
        return ;     
    }     
    while(1)    
    {     
        entry = readdir(dir); /* 读取文件夹下文件*/     
        if(entry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/    
        {     
            printf("dir: %sn", entry->d_name);     
        }    
         else {     
             printf("file: %sn", entry->d_name);     
        }     
    } closedir(dir); /* 关闭文件目录*/     
}    
```    
    
## readdir_r ：读文件夹
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT readdir_r     
(     
    DIR*pdir,     
    struct dirent*pdirentEntry,     
    struct dirent**ppdirentResult     
);    
```    
    
### 描 述：
    
获取一个已经打开的目录的单条信息。    
    
### 参 数：
    
- pdir：目录控制块。    
- pdirentEntry：获取目录条目信息缓冲。    
- ppdirentResult：当成功时, 此指针指向 pdirentEntry, 当到达末位时, 此指针为NULL。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
EBADF ：描述符无效。    
ENOSYS ：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```C    
void printdir (void)     
{     
    DIR*dir;     
    struct dirent entry;     
    struct dirent*pentry = NULL;     
    dir = opendir("./"); /* 打开文件目录*/     
    if (!dir)     
    {     
        printf("failed to open current directoryn");     
        return ;     
    }     
    while(1)     
    {     
        readdir_r(dir, &entry,&pentry); /* 读取文件夹下文件*/     
        if(pentry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/     
        {     
            printf("dir: %sn", entry->d_name);     
        }     
        else {     
            printf("file: %sn", entry->d_name);     
        }     
    }     
    closedir(dir); /* 关闭文件目录*/     
}    
```    
    
## rewinddir ：复位目录指针
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT rewinddir     
(     
    DIR*dir     
);    
```    
    
### 描 述：
    
复位当前目录指针。    
    
### 参 数：
    
- dir ：目录控制块指针。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
    
### 样 例：
    
```C    
void printdir (void)     
{     
    DIR*dir;     
    struct dirent entry;     
    struct dirent*pentry = NULL;     
    dir = opendir("./"); /* 打开文件目录*/     
    if (!dir)     
    {     
        printf("failed to open current directoryn");     
        return ;     
    }     
    while(1)     
    {     
        readdir_r(dir, &entry,&pentry); /* 读取文件夹下文件*/     
        if(pentry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/     
        {     
            printf("dir: %sn", entry->d_name);     
        } else {     
            printf("file: %sn", entry->d_name);     
        }     
    }     
    printf("again output directory file");    
    while(1)     
    {     
        readdir_r(dir, &entry,&pentry); /* 读取文件夹下文件*/     
        if(pentry == NULL) /* 相应目录下没有文件 退出循环*/     
        {     
            break;     
        }     
        if (entry->d_type == DT_DIR) /* 判断文件的类型*/     
        {     
            printf("dir: %sn", entry->d_name);     
        } else {     
            printf("file: %sn", entry->d_name);     
        }     
    } closedir(dir); /* 关闭文件目录*/     
}    
```    
    
## mkfifo ：创建FIFO文件
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT mkfifo     
(     
    CPCHAR pcFifoName,     
    mode_t mode     
);    
```    
    
### 描 述：
    
创建一个新的FIFO文件，默认权限是0754。    
    
### 参 数：
    
- pcFifoName ：FIFO名字。    
- mode ：创建FIFO的权限，参见creat接口。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置位相应的错误码    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```C    
#include<stdio.h>    
#define FILE "HYSylixOS_fifo"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    ret = mkfifo (FILE, 0666);     
    if(ret< 0)     
    {     
        perror("""FILE"" creat errorn");     
        return -1;     
    }     
    …...     
    return 0;     
}    
```    
    
## pipe ：创建匿名管道
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT pipe     
(     
    INT iFd[2]     
);    
```    
    
### 描 述：
    
创建一个匿名管道，在 /dev/pipe/ 先创建一个FIFO文件。当消息队列为空时读阻塞。    
    
### 参 数：
    
- iFd：用与获取创建的匿名管道的描述符，其中iFd[0]用于读操作，iFd[1]用于写操作。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```C    
#include<stdio.h>    
#include<string.h>    
#include<pthread.h>     
static int ifd[2]; /* 匿名管道描述符*/     
void* Thread_pipeRead(void* arg)     
{     
    char buf[1024];     
    int ret = 0;     
    while(1)     
    {     
        memset(buf, 0, sizeof(buf));     
        ret = read(ifd[0], buf, sizeof(buf));     
        if(ret< 0)     
        {     
            printf("read data NULLn");     
        }     
        else{     
            printf("read data :%sn", buf);     
        }     
    }     
    return NULL;     
}     
void* Thread_pipeWrite(void* arg)     
{     
    int ret = 0;     
    char* str = "HYSylixOS system";     
    while(1)     
    {     
        ret = write(ifd[1], str, strlen(str));     
        if(ret != strlen(str))     
        {     
            perror("func write errorn");     
            return LW_NULL;     
        }     
        sleep(1);     
    }     
    return NULL;     
}     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    pthread_t tid_1, tid_2;     
    ret = pthread_create(&tid_1, NULL, Thread_pipeRead, NULL);     
    if(ret != 0)     
    {     
        printf("func pthread_create errorn");     
        return -1;     
    }     
    ret = pthread_create(&tid_2, NULL, Thread_pipeWrite, NULL);     
    if(ret != 0)     
    {     
        printf("func pthread_create errorn");     
        return -1;     
    }     
    ret = pipe(ifd);     
    if(ret != 0)     
    {     
        printf("func pipe errorn");     
        return -1;     
    }     
    pthread_join(tid_1, NULL);     
    pthread_join(tid_2, NULL);     
    return 0;     
}    
```    
    
## pipe2 ：创建匿名管道
    
### 函数原型：
    
```C    
#include<stdio.h>     
INT pipe2     
(     
    INT iFd[2],     
    INT iFlag     
);    
```    
    
### 描 述：
    
创建一个匿名管道，在 /dev/pipe/ 先创建一个FIFO文件。    
    
### 参 数：
    
- iFd ：用与获取创建的匿名管道的描述符，其中iFd[0]用于读操作，iFd[1]用于写操作。    
- iFlag ：获取匿名管道打开的方式。    
    
|权限宏定义|宏值|解释|    
|---|---|---|    
|0|0|默认的，当管道空是读阻塞|    
|O_NONBLOCK|0x4000|当管道空时读不会阻塞|    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#include<pthread.h>     
static int ifd[2]; /* 匿名管道描述符*/     
void* Thread_pipeRead(void* arg)     
{     
    char buf[1024];     
    int ret = 0;     
    while(1)     
    {     
        memset(buf, 0, sizeof(buf));     
        ret = read(ifd[0], buf, sizeof(buf));     
        if(ret< 0)     
        {     
            printf("read data NULLn");     
        }     
        else{     
            printf("read data :%sn", buf);     
        }     
    }     
    return NULL;     
}     
void* Thread_pipeWrite(void* arg)     
{     
    int ret = 0;     
    char* str = "HYSylixOS system";     
    while(1)     
    {     
        ret = write(ifd[1], str, strlen(str));     
        if(ret != strlen(str))     
        {     
            perror("func write errorn");     
            return LW_NULL;     
        }     
        sleep(1);     
    }     
    return NULL;     
}     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    pthread_t tid_1, tid_2;     
    ret = pthread_create(&tid_1, NULL, Thread_pipeRead, NULL);     
    if(ret != 0)     
    {     
        printf("func pthread_create errorn");     
        return -1;     
    }     
    ret = pthread_create(&tid_2, NULL, Thread_pipeWrite, NULL);     
    if(ret != 0)     
    {     
        printf("func pthread_create errorn");     
        return -1;     
    }     
    ret = pipe2(ifd, 0);     
    if(ret != 0)     
    {     
        printf("func pipe errorn");     
        return -1;     
    }     
    pthread_join(tid_1, NULL);     
    pthread_join(tid_2, NULL);     
    return 0;     
}    
```    
    
## link ：创建硬链接文件
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT link     
(     
    CPCHAR pcLinkDst,     
    CPCHAR pcSymPath     
);    
```    
    
### 描 述：
    
用于创建一个硬链接文件。当前HYSylixOS不支持。    
    
### 参 数：
    
- pcLinkDst：链接的目标。    
- pcSymPath：新创建的符号文件。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOSYS：函数不支持此操作。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
无    
```    
    
## symlink ：创建链接文件
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT symlink     
(     
    CPCHAR pcActualPath,     
    CPCHAR pcSymPath     
);    
```    
    
### 描 述：
    
创建一个指向 pcLinkDst 的新符号目录项 pcSymPath。    
    
### 参 数：
    
- pcActualPath ：链接的目标。    
- pcSymPath ：新创建的符号文件。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR并置相应的错误码。    
    
### 错误码：
    
EFAULT ：地址错误    
ENOENT ：文件和设备不存在。    
EEXIST ：重复命名。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define pcActualPath "/apps/HYSylixOS_file" /* 链接的目标*/    
#define pcSymPath "file"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    ret = symlink(pcActualPath, pcSymPath);     
    if(ret != 0)     
    {     
        perror("func symlink errorn");     
        return PX_ERROR;     
    }     
    ret = readlink(pcSymPath, buf, sizeof(buf));     
    if(ret< 0)     
    {     
        perror("func readlink errorn");     
        return PX_ERROR;     
    }     
    printf("%sn", buf);     
    ……     
    return 0;     
}    
```    
    
## readlink ：获取链接文件指向的文件名
    
### 函数原型：
    
```c    
#include<stdio.h>     
ssize_t readlink     
(     
    CPCHAR pcSymPath,     
    PCHAR pcBuffer,     
    size_t iSize     
);    
```    
    
### 描 述：
    
读取符号链接文件链接的文件名。    
    
### 参 数：
    
- pcSymPath：符号链接文件名。    
- pcBuffer：链接文件读取缓冲区。    
- iSize：缓冲区的大小。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EFAULT ：地址错误。    
ENOENT ：文件或设备不存在。    
ELOOP ：链接文件层数太多。    
EXDEV ：交叉设备连接。    
ENOSYS ：函数不支持此操作。    
ERROR_SYSTEM_LOW_MEMORY：系统缺少堆内存。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define pcActualPath "/apps/HYSylixOS_file" /* 链接的目标*/    
#define pcSymPath "file"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    char buf[1024] = {0};     
    char*buff = "hello HYSylixOS";     
    ret = symlink(pcActualPath, pcSymPath);     
    if(ret != 0)     
    {     
        perror("func symlink errorn");     
        return PX_ERROR;     
    }     
    ret = readlink(pcSymPath, buf, sizeof(buf));     
    if(ret< 0)     
    {     
        perror("func readlink errorn");     
        return PX_ERROR;     
    }     
    printf("%sn", buf);     
    ……     
    return 0;     
}    
```    
    
## realpath ：将相对路径转化为绝对路径
    
### 函数原型：
    
```c    
#include<stdio.h>     
PCHAR realpath     
(     
    CPCHAR pcPath,     
    PCHAR pcResolvedPath     
);    
```    
    
### 描 述：
    
此函数用来将参数pcPath所指的相对路径转换成绝对路径后存于参数 pcResolvedPath。    
    
### 参 数：
    
- pcPath ：相对路径。    
- pcResolvedPath ：获取绝对路径保存地址。    
    
### 返回值：
    
成功返回绝对路径，失败返回LW_NULL，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>     
int main (int argc, char**argv)     
{     
    char buf[1024] = {0};     
    char*pbuf = NULL;     
    pbuf = realpath("./", buf);     
    if(pbuf == NULL)     
    {     
        printf("func realpath errorn");     
        return -1;     
    }     
    printf("nonce path : %sn",buf);     
    return 0;     
}    
```    
    
## flock ：锁定文件
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT flock     
(     
    INT iFd,     
    INT iOperation     
);    
```    
    
### 描 述：
    
锁定整个文件。进程使用flock函数尝试锁文件时，如果文件已经被其他进程锁定，进程会被阻塞直到锁被释放，或者在调用flock函数的时候，采用LOCK_NB参数，在尝试锁住该文件时，发现已经被其他进程锁住，会返回错误。适用与不同的进程之间的锁请求，如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一个区间再加一把锁，那么也是可以的，这个时候新锁将替换已有锁。    
    
### 参 数：
    
- iFd ：文件描述符。    
- iOperation ：锁定参数。    
    
|参数宏|宏值|解释|    
|---|---|---|    
|LOCK_SH|1|共享锁，常被用做读上锁|    
|LOCK_EX|2|排他锁，常被用作写上锁|    
|LOCK_NB|0x0080|文件上锁不阻塞|    
|LOCK_UN|3|解锁|    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILENAME "HYSylixOS_file"     
int main(int argc, char**argv)     
{     
    int file = 0;     
    int ret = 0;     
    file = open(FILENAME, O_CREAT|O_RDWR, 0666);     
    if(file< 0)     
    {     
        printf("file open errorn");     
        return PX_ERROR;     
    }     
    ret = flock(file, LOCK_EX);     
    if(ret< 0)     
    {     
        printf("func flock errorn");     
        return PX_ERROR;     
    }     
    ……     
    flock(file, LOCK_UN);     
    return 0;     
}    
```    
    
## lockf ：锁定文件
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT lockf     
(     
    INT iFd,     
    INT iCmd,     
    off_t oftLen     
);    
```    
    
### 描 述：
    
通过文件描述符用与从文件指定位置开始锁定。适用与不同的进程之间的锁请求，如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一个区间再加一把锁，那么也是可以的，这个时候新锁将替换已有锁。    
    
### 参 数：
    
- iFd ：文件描述符。    
- iCmd ：锁定参数。    
    
|参数宏定义|宏值|解释|    
|---|---|---|    
|F_ULOCK|0|设置区域解锁|    
|F_LOCK|1|设置区域锁定|    
|F_TLOCK|2|非阻塞的锁定|    
|F_TEST|3|获得指定区域的锁状态|    
    
- oftLen ：要锁定的资源从读写当前位置向后的偏移量。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
EBADF ：描述符无效。    
EACCES ：文件访问失败。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILENAME "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    char*buff = "hello HYSylixOS";     
    file = open(FILE, O_RDWR|O_CREAT|O_TRUNC, 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    ……     
    lseek(file, 0, SEEK_SET);     
    ret = lockf(file, F_LOCK, 30);     
    if(ret != 0)     
    {     
        perror("func lockf errorn");     
        return 0;     
    }     
    ……     
    close(file);     
    return 0;     
}    
```    
    
## umask ：设置文件创建屏蔽字
    
### 函数原型：
    
```c    
#include<stdio.h>     
mode_t umask     
(     
    mode_t modeMask     
);    
```    
    
### 描 述：
    
设置文件的创建屏蔽字，当相应的位为1时，创建文件时相应的位设置会被拒绝。    
    
### 参 数：
    
- modeMask：新的屏蔽字。    
    
### 返回值：
    
返回旧的屏蔽字。    
    
### 错误码：
    
无。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#define FILENAME "HYSylixOS_file"     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    ret = umask(0137);     
    if(ret != 0)     
    {     
        printf("func umask errorn");     
    }     
    ……     
    return 0;     
}    
```    
    
## mknod ：创建特殊文件
    
### 函数原型：
    
```c    
#include<stdio.h>     
INT mknod     
(     
    CPCHAR pcNodeName,     
    mode_t mode,     
    dev_t dev     
);    
```    
    
### 描 述：
    
创建一个目录项和一个特殊文件的对应索引节点。创建的文件默认权限时0754。    
    
### 参 数：
    
- pcNodeName ：目录名。    
- mode ：文件类型。    
    
|类型宏定义|宏值|解释|    
|---|---|---|    
|S_IFIFO|0x1000|管道和命名管道|    
|S_IFCHR|0x2000|字符设备文件|    
|S_IFDIR|0x4000|目录文件|    
|S_IFBLK|0x6000|块设备文件|    
|S_IFREG|0x8000|普通文件|    
|S_IFLNK|0xa000|符号链接文件|    
|S_IFSOCK|0xc000|套接字文件|    
    
- dev ：文件对应的设备文件的设备号（暂时未用）。    
    
### 返回值：
    
成功返回0，失败返回PX_ERROR，并置相应的错误码。    
    
### 错误码：
    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<stdio.h>    
#include<string.h>    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/     
int main (int argc, char**argv)     
{     
    int ret = 0;     
    int file = 0;     
    ret = mknod(FILE, S_IFREG, 0);     
    if(ret != 0)     
    {     
        printf("func mknod errorn");     
        return -1;     
    }     
    file = open(FILE, O_WRONLY , 0666);     
    if(file< 0)     
    {     
        perror("""FILE""open error");     
        return -1;     
    }     
    …….     
    close(file);     
    return 0;     
}    
```    
    
## aio_cancel ：取消异步IO操作
    
### 函数原型：
    
```c    
#include<aio.h>     
int aio_cancel     
(     
    int fildes,     
    struct aiocb*paiocb     
);    
```    
    
### 描 述：
    
该接口取消异步IO操作。    
    
### 参 数：
    
- filde ：文件描述符。    
- paiocb ：aio 请求控制块 (可以为 NULL，表示取消全部请求)。    
    
### 返回值：
    
|返回值|含义|    
|---|---|    
|AIO_ALLDONE|取消全部请求|    
|AIO_CANCELED|取消某个请求|    
|-1|失败|    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<aio.h>    
#include<stdio.h>    
#include<fcntl.h>    
#include<stdlib.h>    
#include<string.h>    
#include<signal.h>    
#define BUFSIZE (64) /* 接受数据缓冲区大小*/    
#define FILE "HYSylixOS_file" /* 文件名宏定义*/    
void signal_handler(union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    printf("signal_handlern");    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error.n");    
        return;    
    }    
    if(paio->aio_lio_opcode == LIO_READ)    
    {    
        fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
    }    
    else if(paio->aio_lio_opcode ==LIO_WRITE)    
    {    
        fprintf(stdout, "write data leng :%ld : %sn", ret, (char*)(paio->aio_buf));    
    }    
}    
int main (int argc, char*argv[])    
{    
    int fd;    
    int ret;    
    struct aiocb aio[2];    
    const struct aiocb*const list[] = {&aio[0],&aio[1]};    
    char*data = "HYSylixOS system";    
    struct timespec timeout;    
    fd = open(FILE, O_RDWR|O_CREAT, 0666);    
    if (fd< 0)    
    {    
        fprintf(stderr, "open file failed.n");    
        return (-1);    
    }    
    memset(&aio[0], 0, sizeof(struct aiocb));    
    memset(&aio[1], 0, sizeof(struct aiocb)); /** 设置第一个AIO控制块*/    
    aio[0].aio_fildes = fd;    
    aio[0].aio_buf = malloc(BUFSIZE + 1);    
    aio[0].aio_nbytes = BUFSIZE;    
    aio[0].aio_offset = 0;    
    aio[0].aio_reqprio = 1;    
    aio[0].aio_lio_opcode = LIO_READ;    
    aio[0].aio_sigevent.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL;    
    aio[0].aio_sigevent.sigev_value.sival_ptr = (void*)&aio[0];    
    aio[0].aio_sigevent.sigev_signo = SIGUSR1;    
    aio[0].aio_sigevent.sigev_notify_function = signal_handler; /** 设置第二个AIO控制块*/    
    aio[1].aio_fildes = fd;    
    aio[1].aio_buf = data;    
    aio[1].aio_nbytes = strlen(data);    
    aio[1].aio_offset = 0;    
    aio[1].aio_reqprio = 2;    
    aio[1].aio_lio_opcode = LIO_WRITE;    
    aio[1].aio_sigevent.sigev_signo = SIGUSR1;    
    aio[1].aio_sigevent.sigev_notify_function = signal_handler;    
    aio[1].aio_sigevent.sigev_value.sival_ptr =(void*)&aio[1];    
    aio[1].aio_sigevent.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL;    
    ret = aio_write(&aio[1]);    
    if(ret != 0)    
    {    
        perror("func aio_write errorn");    
        return -1;    
    }    
    ret = aio_read(&aio[0]);    
    if(ret != 0)    
    {    
        perror("func aio_write errorn");    
        return -1;    
    }    
    timeout.tv_sec = 1;    
    timeout.tv_nsec = 100;    
    ret = aio_suspend(list, 2,&timeout);    
    if(ret != 0)    
    {    
        printf("func aio_suspend errorn");    
        aio_cancel(fd, NULL);    
    }    
    sleep(1);    
    close(fd);    
    return (0);    
}    
```    
    
## aio_error ：获取异步IO完成后的错误码
    
### 函数原型：
    
```c    
#include<aio.h>    
int aio_error    
(    
    const struct aiocb*paiocb    
);    
```    
    
### 描 述：
    
该接口用来获取异步IO操作完成后的错误码。    
    
### 参 数：
    
- paiocb：aio 请求控制块 (可以为 NULL)。    
    
### 返回值：
    
成功返回IO操作完成后的错误码；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
void signal_handler(union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    printf("signal_handlern");    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error, error id :%dn", aio_error(paio));    
        return;    
    }    
    if(paio->aio_lio_opcode == LIO_READ)    
    {    
        fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
    }    
    else if(paio->aio_lio_opcode ==LIO_WRITE)    
    {    
        fprintf(stdout, "write data leng :%ld : %sn", ret, (char*)(paio->aio_buf));    
    }    
}    
```    
    
## aio_fsync ：同步异步IO文件内容
    
### 函数原型：
    
```c    
#include<aio.h>    
int aio_fsync    
(    
    int op,    
    struct aiocb*paiocb    
);    
```    
    
### 描 述：
    
该接口用来aio同步文件内容。将缓冲区的数据写入文件。此函数不能在中断中调用。    
    
### 参 数：
    
- op：操作选项。    
    
- paiocb ：aio 请求控制块。    
    
### 返回值：
    
成功返回0；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<aio.h>    
#include<stdio.h>    
#include<fcntl.h>    
#include<stdlib.h>    
#include<string.h>    
#include<signal.h>    
#define BUFSIZE (64)    
void signal_handler (union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error.n");    
        return;    
    }    
    fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
}    
int main (int argc, char*argv[])    
{    
    int fd;    
    int ret;    
    static struct aiocb aio;    
    const struct aiocb*const list[] = {&aio};    
    fd = open("file", O_RDONLY|O_CREAT, 0666);    
    if (fd< 0)    
    {    
        fprintf(stderr, "open file failed.n");    
        return (-1);    
    }    
    memset(&aio, 0, sizeof(struct aiocb)); /** 设置AIO控制块*/    
    aio.aio_fildes = fd;    
    aio.aio_buf = malloc(BUFSIZE + 1);    
    aio.aio_nbytes = BUFSIZE;    
    aio.aio_offset = 0;    
    aio.aio_reqprio = 1;    
    aio.aio_lio_opcode = LIO_READ;    
    aio.aio_sigevent.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL;    
    aio.aio_sigevent.sigev_value.sival_ptr = (void*)&aio;    
    aio.aio_sigevent.sigev_signo = SIGUSR1;    
    aio.aio_sigevent.sigev_notify_function = signal_handler;    
    ret = aio_read(&aio);    
    if (ret< 0)    
    {    
        perror("aio_read");    
        close(fd);    
        return (-1);    
    }    
    aio_suspend(list, 1, NULL);    
    ret = aio_fsync(O_DSYNC,&aio);    
    if(ret != 0)    
    {    
        perror("aio_fsyncn");    
    }    
    ……    
    close(fd);    
    return (0);    
}    
```    
    
## aio_read ：异步读取文件内容
    
### 函数原型：
    
```c    
#include<aio.h>    
int aio_read    
(    
    struct aiocb*paiocb    
);    
```    
    
### 描 述：
    
该接口用来异步读取文件内容。此函数不能在中断中调用。    
    
### 参 数：
    
- paiocb ：aio 请求控制块。    
    
### 返回值：
    
成功返回0；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<aio.h>    
#include<stdio.h>    
#include<fcntl.h>    
#include<stdlib.h>    
#include<string.h>    
#include<signal.h>    
#define BUFSIZE (64)    
void signal_handler (union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error.n");    
        return;    
    }    
    fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
}    
int main (int argc, char*argv[])    
{    
    int fd;    
    int ret;    
    static struct aiocb aio;    
    const struct aiocb*const list[] = {&aio};    
    fd = open("file", O_RDONLY|O_CREAT, 0666);    
    if (fd< 0)    
    {    
        fprintf(stderr, "open file failed.n");    
        return (-1);    
    }    
    memset(&aio, 0, sizeof(struct aiocb)); /** 设置AIO控制块*/    
    aio.aio_fildes = fd;    
    aio.aio_buf = malloc(BUFSIZE + 1);    
    aio.aio_nbytes = BUFSIZE;    
    aio.aio_offset = 0;    
    aio.aio_reqprio = 1;    
    aio.aio_lio_opcode = LIO_READ;    
    aio.aio_sigevent.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL;    
    aio.aio_sigevent.sigev_value.sival_ptr = (void*)&aio;    
    aio.aio_sigevent.sigev_signo = SIGUSR1;    
    aio.aio_sigevent.sigev_notify_function = signal_handler;    
    ret = aio_read(&aio);    
    if (ret< 0)    
    {    
        perror("aio_read");    
        close(fd);    
        return (-1);    
    }    
    aio_suspend(list, 1, NULL);    
    close(fd);    
    return (0);    
}    
```    
    
## aio_write :异步写入文件内容
    
### 函数原型：
    
```c    
#include<aio.h>    
int aio_write    
(    
    struct aiocb*paiocb    
);    
```    
    
### 描 述：
    
该接口用来异步写入文件内容。此函数不能在中断中调用。    
    
### 参 数：
    
- paiocb ：aio 请求控制块。    
    
### 返回值：
    
成功返回0；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
static void* test1(void*arg)    
{    
    int ret = 0 ;    
    struct aiocb aio;    
    char buf[1024];    
    memset(buf, 0, 1024);    
    int file = open(FILENAME, O_WRONLY);    
    if(file == -1)    
    {    
        perror("func open errorn");    
        return (PVOID)-1;    
    }    
    strcpy(buf, "SylixOS systemtn");    
    bzero(&aio, sizeof(aio));    
    aio.aio_fildes = file;    
    aio.aio_buf = buf;    
    aio.aio_nbytes = 1024;    
    aio.aio_offset = 0;    
    ret = aio_write(&aio);    
    if(ret != 0)    
    {    
        perror("aio_writen");    
    }    
    ……    
    return NULL;    
}    
```    
    
## aio_return ：获取异步IO完成后的返回值
    
### 函数原型：
    
```c    
#include<aio.h>    
ssize_t aio_return    
(    
    struct aiocb*paiocb    
);    
```    
    
### 描 述：
    
该接口用来获取异步IO操作完成后的返回值。此函数不能在中断中调用。    
    
### 参 数：
    
- paiocb：aio 请求控制块。    
    
### 返回值：
    
成功返回IO操作后的返回值；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
EINPROGRESS ：IO操作正在进行。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
void signal_handler (union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error.n");    
        return;    
    }    
    fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
}    
```    
    
## aio_suspend ：等待指定异步IO操作
    
### 函数原型：
    
```c    
#include<aio.h>    
int aio_suspend    
(    
    const struct aiocb* const list[],    
    int nent,    
    const struct timespec*timeout    
);    
```    
    
    
### 描 述：
    
该接口用来等待指定的一个或多个异步 I/O 请求操作完成。此函数不能在中断中调用。    
    
### 参 数：
    
- list ：aio 请求控制块数组 (如果其中有 NULL, 程序将忽略)。    
- nent ：数组元素个数。    
- timeout ：超时时间。    
    
### 返回值：
    
成功返回IO操作后的返回值；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
ENOMEM ：内存不足。    
EAGAIN ：系统资源不足。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<aio.h>    
#include<stdio.h>    
#include<fcntl.h>    
#include<stdlib.h>    
#include<string.h>    
#include<signal.h>    
#define BUFSIZE (64)    
void signal_handler (union sigval val)    
{    
    struct aiocb*paio = (struct aiocb*)val.sival_ptr;    
    ssize_t ret;    
    ret = aio_return(paio);    
    if (ret< 0)    
    {    
        fprintf(stderr, "aio_return error.n");    
        return;    
    }    
    fprintf(stdout, "len: %ldncontent: %sn", ret, (char*)(paio->aio_buf));    
}    
int main (int argc, char*argv[])    
{    
    int fd;    
    int ret;    
    static struct aiocb aio;    
    const struct aiocb*const list[] = {&aio};    
    fd = open("file", O_RDONLY|O_CREAT, 0666);    
    if (fd< 0)    
    {    
        fprintf(stderr, "open file failed.n");    
        return (-1);    
    }    
    memset(&aio, 0, sizeof(struct aiocb)); /** 设置AIO控制块*/    
    aio.aio_fildes = fd;    
    aio.aio_buf = malloc(BUFSIZE + 1);    
    aio.aio_nbytes = BUFSIZE;    
    aio.aio_offset = 0;    
    aio.aio_reqprio = 1;    
    aio.aio_lio_opcode = LIO_READ;    
    aio.aio_sigevent.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL; aio.aio_sigevent.sigev_value.sival_ptr = (void*)&aio;    
    aio.aio_sigevent.sigev_signo = SIGUSR1;    
    aio.aio_sigevent.sigev_notify_function = signal_handler;    
    ret = aio_read(&aio);    
    if (ret< 0)    
    {    
        perror("aio_read");    
        close(fd);    
        return (-1);    
    }    
    aio_suspend(list, 1, NULL);    
    close(fd);    
    return (0);    
}    
```    
    
    
## lio_listio：等待全部异步IO操作
    
### 函数原型：
    
```c    
#include<aio.h>    
int lio_listio    
(    
    int mode,    
    struct aiocb* const list[],    
    int nent,    
    struct sigevent*sig    
)    
```    
    
### 描 述：
    
同时发起多个传输mode参数可以是LIO_WAIT或LIO_NOWAIT。LIO_WAIT会阻塞这个调用,直到所有的I/O都完成为止。在操作进行排队之后，LIO_NOWAIT就会返回。    
    
### 参 数：
    
- mode：等待方式。    
    
|等待方式|解释|    
|---|---|    
|LIO_WAIT|阻塞调用，直到所有的 I/O 都完成为止|    
|LIO_NOWAIT|在操作进行排队之后返回|    
    
- list ：aio请求控制块数组。    
- nent ：aio请求控制块数组元素个数。    
- sig **：**所有 I/O 操作都完成时产生信号的方法    
    
### 返回值：
    
成功返回IO操作后的返回值；失败返回-1，并置错误码。    
    
### 错误码：
    
ENOSYS ：函数不支持此操作。    
EINVAL ：参数无效。    
ENOMEM ：内存不足。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例：
    
```c    
#include<aio.h>    
#include<stdio.h>    
#include<fcntl.h>    
#include<stdlib.h>    
#include<string.h>    
#include<signal.h>    
#define BUFSIZE (64)    
void signal_handler (union sigval val)    
{    
    fprintf(stdout, "async operator complete.n");    
}    
int main (int argc, char*argv[])    
{    
    int fd;    
    int ret;    
    struct aiocb aio[2];    
    struct aiocb*const list[] = {&aio[0],&aio[1]};    
    static struct sigevent notify;    
    fd = open("file", O_RDONLY);    
    if (fd< 0)    
    {    
        fprintf(stderr, "open file failed.n");    
        return (-1);    
    }    
    memset(&aio[0], 0, sizeof(struct aiocb));    
    memset(&aio[1], 0, sizeof(struct aiocb)); /** 设置第一个AIO控制块*/    
    aio[0].aio_fildes = fd;    
    aio[0].aio_buf = malloc(BUFSIZE + 1);    
    aio[0].aio_nbytes = BUFSIZE;    
    aio[0].aio_offset = 0;    
    aio[0].aio_reqprio = 1;    
    aio[0].aio_lio_opcode = LIO_READ; /** 设置第二个AIO控制块*/    
    aio[1].aio_fildes = fd;    
    aio[1].aio_buf = malloc(BUFSIZE + 1);    
    aio[1].aio_nbytes = BUFSIZE;    
    aio[1].aio_offset = BUFSIZE;    
    aio[1].aio_reqprio = 2;    
    aio[1].aio_lio_opcode = LIO_READ;    
    notify.sigev_signo = SIGUSR1;    
    notify.sigev_notify_function = signal_handler;    
    notify.sigev_notify = SIGEV_THREAD|SIGEV_SIGNAL;    
    ret = lio_listio(LIO_NOWAIT, list, 2,&notify);    
    if (ret< 0)    
    {    
        perror("lio_listio");    
        close(fd);    
        return (-1);    
    }    
    sleep(60);    
    close(fd);    
    return (0);    
}    
```    
    
## mount() ： 挂载文件系统接口
    
### 函数原型：
    
```c    
#include<gjbext.h>    
int mount    
(    
    const char*fs,    
    const char*dev,    
    const char*mpath    
);    
```    
    
### 描 述： 
    
挂载文件系统接口，该接口把有dev指向的块设备加载到由mpath指向的加载点，所加载的文件系统类型有fs指定。(x86环境测试)    
    
### 参 数：
    
- fs ：文件系统（类型）名称，格式有"vfat" "iso9660" "ntfs" "nfs" "romfs" "ramfs" 等，当输出为NULL时，默认使用的式”vfat”文件系统。    
- dev ：存储设备路径。    
- mpath ：文件系统挂在点。    
    
### 返回值：
    
成功返回0，失败返回-1，并置相应的错误码。    
    
### 错误码： 
    
EINVAL ：参数无效。    
ERROR_IO_NO_DRIVER ：缺少驱动程序。    
ERROR_SYSTEM_LOW_MEMORY ：系统堆缺少内存。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EINVAL ：参数无效。    
ENODEV ：不是块设备文件。    
ENAMETOOLONG ：路径名太长。    
ENOENT ：文件或设备不存在。    
    
### 样 例    
    
```c    
#include<stdio.h>    
#include<gjbext.h>    
#define MOUNT "/mnt/hdd1"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    ret = mount(NULL, "/dev/blk/hdd-0", MOUNT);    
    if(ret != 0)    
    {    
        perror("func gjb_mount errorn");    
        return ret;    
    }    
    ……    
    return (0);    
}    
```    
    
## umount() ： 卸载文件系统接口
    
### 函数原型：
    
```c    
#include<gjbext.h>    
int umount    
(    
    const char*mpath    
);    
```    
    
### 描 述： 
    
该接口用来卸载mpath指向的加载点。(x86环境测试)    
    
### 参 数：
    
- mpath ：加载点路径。    
    
### 返回值：
    
成功返回0，失败返回-1，并置相应的错误码。    
    
### 错误码： 
    
ENOENT ：文件或设备不存在。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例    
    
```c    
#include<stdio.h>    
#include<gjbext.h>    
#define MOUNT "/mnt/hdd1"    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    ret = mount(NULL, "/dev/blk/hdd-0", MOUNT);    
    if(ret != 0)    
    {    
        perror("func gjb_mount errorn");    
        return ret;    
    }    
    ……    
    ret = umount(MOUNT);    
    if(ret != 0)    
    {    
        perror("func gjb_umount errorn");    
        return ret;    
    }    
    return (0);    
}    
```    
    
## format ：存储设备格式化
    
### 函数原型：
    
```c    
#include<gjbext.h>    
int format    
(    
    const char*fs,    
    const char*dev    
);    
```    
    
### 描 述：
    
格式化指定的设备，NULL表示格式化当前设备（x86环境测试）。    
    
### 参 数：
    
- fs ：存储设备要格式化的文件系统类型。文件系统（类型）名称，格式有"vfat" "iso9660" "ntfs" "nfs" "romfs" "ramfs" 等    
    
- dev ：存储设备路径。    
    
### 返回值：
    
成功返回-1，失败返回0，并置相应的错误码。    
    
### 错误码： 
    
EACCES ：权限不足。    
EINVAL ：参数无效。    
ENOENT ：文件或设备不存在。    
EFAULT ：地址错误。    
EXDEV ：交叉设备连接。    
ELOOP ：链接文件层数太多。    
EBADF ：描述符无效。    
ERROR_IOS_DRIVER_NOT_SUP ：驱动程序，不支持。    
    
### 备 注：
    
GJB 7714-2012错误码为：无。    
    
### 样 例    
    
```c    
#include<stdio.h>    
#define MOUNT_1 "/media/hdd0" /* 设备名宏定义*/    
int main (int argc, char**argv)    
{    
    int ret = 0;    
    ……    
    ret = format("ntfs", MOUNT_1);    
    if(ret != 0)    
    {    
        perror("func format errorn");    
        return ret;    
    }    
    ……    
    return (0);    
}    
```    
    
## global_std_get：获取全局标准文件描述符映射
    
### 函数原型：
    
```c    
#include<gjbext.h>    
int global_std_get    
(    
    int stdfd    
);    
```    
    
### 描 述：
    
该接口用于获取全局标准IO（标准输入、标准输出和标准错误，有stdfd确定本次设置），对应的实际的文件描述符（供内核模块使用）。    
    
### 参 数：
    
- stdfd ：全局标准文件描述符宏。    
    
|设置宏|解释|    
|---|---|    
|STD_IN|标准输入|    
|STD_OUT|标准输出|    
|STD_ERR|标准错误|    
    
### 返回值：
    
如果全局标准IO已设置则返回，未设置返回-1，并置相应的错误码。    
    
### 错误码：
    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
    
### 样 例    
    
```c    
#define__SYLIXOS_KERNEL    
#include<SylixOS.h>    
#include<module.h>    
#include<pthread.h>    
#define FILE "/etc/out" /* 标准IO输出文件名*/    
static int G_file; /* 标准IO输出文件描述符*/    
static int G_out = 0; /* 记录默认IO输出文件描述符*/    
int module_init (void)    
{    
    int new = 0;    
    G_file = open(FILE, O_CREAT|O_WRONLY, 0666);    
    if(G_file< 0)    
    {    
        printk("func open G_file error");    
        return PX_ERROR;    
    }    
    G_out = global_std_get(STD_OUT);    
    if(G_out< 0 )    
    {    
        printk("func global_std_get errorn");    
        return PX_ERROR;    
    }    
    global_std_set(STD_OUT, G_file);    
    new = global_std_get(STD_OUT);    
    if(new< 0 )    
    {    
        printk("func global_std_get errorn");    
        return PX_ERROR;    
    }    
    if(new != G_file)    
    {    
        printk("global_std_set set errorn");    
        global_std_set(STD_OUT, G_out);    
        close(G_file);    
        return PX_ERROR;    
    }    
    printk("global_std_set successn");    
    return 0;    
}    
void module_exit (void)    
{    
    global_std_set(STD_OUT, G_out);    
    close(G_file);    
    printk("hello_module exit!n");    
}    
```    
    
## global_std_set ：获取全局标准文件描述符映射
    
### 函数原型：
    
```c    
#include<gjbext.h>    
void global_std_set    
(    
    int stdfd,    
    int newfd    
);    
```    
    
### 描 述：
    
该接口用于设置全局标准IO（标准输入、标准输出和标准错误），（供内核模块使用）。    
    
### 参 数：
    
- stdfd ：全局标准文件描述符宏。    
    
|设置宏|解释|    
|---|---|    
|STD_IN|标准输入|    
|STD_OUT|标准输出|    
|STD_ERR|标准错误|    
    
- newfd：要设置为标准IO的文件描述符。    
    
### 返回值：
    
成功返回-1，失败返回0，并置相应的���误码。    
    
### 错误码： 
    
EACCES ：权限不足。    
EINVAL ：参数无效。    
    
### 备 注：
    
GJB 7714-2012错误码为：    
EBADF ：句柄无效。    
    
### 样 例    
    
```c    
#define__SYLIXOS_KERNEL    
#include<SylixOS.h>    
#include<module.h>    
#include<pthread.h>    
#define FILE "/etc/out" /* 标准IO输出文件名*/    
static int G_file; /* 标准IO输出文件描述符*/    
static int G_out = 0; /* 记录默认IO输出文件描述符*/    
int module_init (void)    
{    
    int new = 0;    
    G_file = open(FILE, O_CREAT|O_WRONLY, 0666);    
    if(G_file< 0)    
    {    
        printk("func open G_file error");    
        return PX_ERROR;    
    }    
    G_out = global_std_get(STD_OUT);    
    if(G_out< 0 )    
    {    
        printk("func global_std_get errorn");    
        return PX_ERROR;    
    }    
    global_std_set(STD_OUT, G_file);    
    new = global_std_get(STD_OUT);    
    if(new< 0 )    
    {    
        printk("func global_std_get errorn");    
        return PX_ERROR;    
    }    
    if(new != G_file)    
    {    
        printk("global_std_set set errorn");    
        global_std_set(STD_OUT, G_out);    
        close(G_file);    
        return PX_ERROR;    
    }    
    printk("global_std_set successn");    
    return 0;    
}    
void module_exit (void)    
{    
    global_std_set(STD_OUT, G_out);    
    close(G_file);    
    printk("hello_module exit!n");    
}    
```    
    
## select ：等待多个IO操作
    
### 函数原型：
    
```c    
#include<stdlib.h>    
INT select    
(    
    INT iWidth,    
    fd_set*pfdsetRead,    
    fd_set*pfdsetWrite,    
    fd_set*pfdsetExcept,    
    struct timeval*ptmvalTO    
);    
```    
    
### 描 述：
    
多路IO不仅支持任务同时等待多个设备进行IO操作，还能够指定等待过程的最长时间。在数据变为有效或设备变为可写状态之前，任务一直处于阻塞状态。通过select()函数可以可以知道何时一个或多个文件描述符变为有效状态或发生了超时的情况。通过select()函数可以指定某一个任务等待哪些文件描述符变为活动状态。当ptmvalTO等于NULL时，永远等待。当指定的描述字中的一个已经准备好或捕捉到一个信号则返回。如果是捕捉到返回信号，select返回-1。当ptmvalTO的tv_sec等于0且tv_usec等于0时，完全不等待，测试所有指定的描述字并立即而返回。当ptmvalTO的tv_sec不等于0或tv_usec不等于0时，等待指定的时间。当指定的描述字中的一个已经准备好，或当指定的时间值已经超时时立即返回。    
    
### 参 数：
    
- iWidth ：最大的文件描述符加1。    
- pfdsetRead ：读操作文件描述符集。    
- pfdsetWrite ：写操作文件描述符集。    
- pfdsetExcept ：例外操作文件描述符集。    
- ptmvalTO ：类型为struct timeval的超时设置。    
    
### 返回值：
    
成功返回0，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
ERROR_KERNEL_IN_ISR：在中断中使用    
ERROR_IO_SELECT_CONTEXT：线程没有 select context 结构    
ERROR_IO_SELECT_WIDTH ：最大文件号错误    
ERROR_IO_SELECT_FDSET_NULL ：文件集为空。    
ERROR_IO_SELECT_UNSUPPORT_IN_DRIVER：驱动程序不支��    
    
### 备 注：
    
GJB 7714-2012错误码：无。    
    
### 样 例    
    
```c    
int main (int argc, char*argv[])    
{    
    fd_set fdset;    
    int ret;    
    struct timeval timeout;    
    char ch;    
    timeout.tv_sec = 10;    
    timeout.tv_usec = 0;    
    for (;;)    
    {    
        FD_ZERO(&fdset);    
        FD_SET(STDIN_FILENO,&fdset); /* STDIN_FILENO 表示键盘输入*/    
        ret = select(STDIN_FILENO + 1, &fdset, NULL, NULL,&timeout);    
        if (ret<= 0)    
        {    
            break; /**判断是否式STDIN_FILENO有数据*/    
        }    
        else if (FD_ISSET(STDIN_FILENO, &fdset)){    
            read(STDIN_FILENO, &ch, 1);    
            if (ch == 'n') {    
                continue;    
            }    
            fprintf(stdout, "input char: %cn", ch);    
            if (ch == 'q')    
            {    
                /* 输入字符‘q’退出*/    
                break;    
            }    
        }    
    }    
    return (0);    
}    
```    
    
## pselect ：等待多个IO操作
    
### 函数原型：
    
```c    
#include<stdlib.h>    
INT pselect    
(    
    INT iWidth,    
    fd_set*pfdsetRead,    
    fd_set*pfdsetWrite,    
    fd_set*pfdsetExcept,    
    struct timeval*ptmvalTO,    
    const sigset_t*sigsetMask    
);    
```    
    
### 描 述：
    
多路IO不仅支持任务同时等待多个设备进行IO操作，还能够指定等待过程的最长时间。在数据变为有效或设备变为可写状态之前，任务一直处于阻塞状态。通过select()函数可以可以知道何时一个或多个文件描述符变为有效状态或发生了超时的情况。通过select()函数可以指定某一个任务等待哪些文件描述符变为活动状态。当ptmvalTO等于NULL时，永远等待。当指定的描述字中的一个已经准备好或捕捉到一个信号则返回。如果是捕捉到返回信号，select返回-1。当ptmvalTO的tv_sec等于0且tv_usec等于0时，完全不等待，测试所有指定的描述字并立即而返回。当ptmvalTO的tv_sec不等于0或tv_usec不等于0时，等待指定的时间。当指定的描述字中的一个已经准备好，或当指定的时间值已经超时时立即返回。    
    
### 参 数：
    
- iWidth ：最大的文件描述符加1。    
- pfdsetRead ：读操作文件描述符集    
- pfdsetWrite ：写操作文件描述符集。    
- pfdsetExcept ：例外操作文件描述符集。    
- ptmvalTO ：类型为struct timeval的超时设置。    
- sigsetMask ：等待时阻塞的信号    
    
### 返回值：
    
成功返回0，失败返回-1，并置相应的错误码。    
    
### 错误码：
    
ERROR_KERNEL_IN_ISR：在中断中使用    
ERROR_IO_SELECT_CONTEXT：线程没有 select context 结构    
ERROR_IO_SELECT_WIDTH ：最大文件号错误    
ERROR_IO_SELECT_FDSET_NULL ：文件集为空。    
ERROR_IO_SELECT_UNSUPPORT_IN_DRIVER：驱动程序不支持。    
    
### 备 注：
    
GJB 7714-2012未定义此函数。    
    
### 样 例    
    
```c    
int main (int argc, char*argv[])    
{    
    fd_set fdset;    
    int ret;    
    struct timeval timeout;    
    char ch;    
    timeout.tv_sec = 10;    
    timeout.tv_usec = 0;    
    for (;;)    
    {    
        FD_ZERO(&fdset);    
        FD_SET(STDIN_FILENO,&fdset); /* STDIN_FILENO 表示键盘输入*/    
        ret = pselect(STDIN_FILENO + 1, &fdset, NULL, NULL, &timeout, NULL);    
        if (ret<= 0)    
        {    
            break; /**判断是否式STDIN_FILENO有数据*/    
        }    
        else if(FD_ISSET(STDIN_FILENO, &fdset)){    
            read(STDIN_FILENO, &ch, 1);    
            if (ch == 'n')    
            {    
                continue;    
            }    
            fprintf(stdout, "input char: %cn", ch);    
            if (ch == 'q')    
            {    
                /* 输入字符‘q’退出*/    
                break;    
            }    
        }    
    }    
    return (0);    
}    
```    
